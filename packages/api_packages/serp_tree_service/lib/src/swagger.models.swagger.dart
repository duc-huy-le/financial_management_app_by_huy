// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';
import 'swagger.enums.swagger.dart' as enums;

part 'swagger.models.swagger.g.dart';

@JsonSerializable(explicitToJson: true)
class ACLItem {
  ACLItem({
    this.objectId,
    this.objectCode,
    this.objectName,
    this.objectType,
    this.accessType,
  });

  factory ACLItem.fromJson(Map<String, dynamic> json) =>
      _$ACLItemFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectCode', includeIfNull: false)
  final String? objectCode;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(
      name: 'objectType',
      includeIfNull: false,
      toJson: objectTypeToJson,
      fromJson: objectTypeFromJson)
  final enums.ObjectType? objectType;
  @JsonKey(
      name: 'accessType',
      includeIfNull: false,
      toJson: accessTypeToJson,
      fromJson: accessTypeFromJson)
  final enums.AccessType? accessType;
  static const fromJsonFactory = _$ACLItemFromJson;
  static const toJsonFactory = _$ACLItemToJson;
  Map<String, dynamic> toJson() => _$ACLItemToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ACLItem &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectCode, objectCode) ||
                const DeepCollectionEquality()
                    .equals(other.objectCode, objectCode)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.accessType, accessType) ||
                const DeepCollectionEquality()
                    .equals(other.accessType, accessType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectCode) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(accessType) ^
      runtimeType.hashCode;
}

extension $ACLItemExtension on ACLItem {
  ACLItem copyWith(
      {String? objectId,
      String? objectCode,
      String? objectName,
      enums.ObjectType? objectType,
      enums.AccessType? accessType}) {
    return ACLItem(
        objectId: objectId ?? this.objectId,
        objectCode: objectCode ?? this.objectCode,
        objectName: objectName ?? this.objectName,
        objectType: objectType ?? this.objectType,
        accessType: accessType ?? this.accessType);
  }
}

@JsonSerializable(explicitToJson: true)
class ACLObject {
  ACLObject({
    this.objectId,
    this.aclItems,
  });

  factory ACLObject.fromJson(Map<String, dynamic> json) =>
      _$ACLObjectFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'aclItems', includeIfNull: false, defaultValue: <ACLItem>[])
  final List<ACLItem>? aclItems;
  static const fromJsonFactory = _$ACLObjectFromJson;
  static const toJsonFactory = _$ACLObjectToJson;
  Map<String, dynamic> toJson() => _$ACLObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ACLObject &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.aclItems, aclItems) ||
                const DeepCollectionEquality()
                    .equals(other.aclItems, aclItems)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(aclItems) ^
      runtimeType.hashCode;
}

extension $ACLObjectExtension on ACLObject {
  ACLObject copyWith({String? objectId, List<ACLItem>? aclItems}) {
    return ACLObject(
        objectId: objectId ?? this.objectId,
        aclItems: aclItems ?? this.aclItems);
  }
}

@JsonSerializable(explicitToJson: true)
class ACLObjectResponseList {
  ACLObjectResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ACLObjectResponseList.fromJson(Map<String, dynamic> json) =>
      _$ACLObjectResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <ACLObject>[])
  final List<ACLObject>? data;
  static const fromJsonFactory = _$ACLObjectResponseListFromJson;
  static const toJsonFactory = _$ACLObjectResponseListToJson;
  Map<String, dynamic> toJson() => _$ACLObjectResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ACLObjectResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ACLObjectResponseListExtension on ACLObjectResponseList {
  ACLObjectResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<ACLObject>? data}) {
    return ACLObjectResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class Address {
  Address({
    this.type,
    this.countryCode,
    this.countryName,
    this.province,
    this.provinceName,
    this.district,
    this.districtName,
    this.ward,
    this.wardName,
    this.street,
    this.street2,
    this.zip,
  });

  factory Address.fromJson(Map<String, dynamic> json) =>
      _$AddressFromJson(json);

  @JsonKey(name: 'type', includeIfNull: false, defaultValue: <String>[])
  final List<String>? type;
  @JsonKey(name: 'countryCode', includeIfNull: false)
  final String? countryCode;
  @JsonKey(name: 'countryName', includeIfNull: false)
  final String? countryName;
  @JsonKey(name: 'province', includeIfNull: false)
  final String? province;
  @JsonKey(name: 'provinceName', includeIfNull: false)
  final String? provinceName;
  @JsonKey(name: 'district', includeIfNull: false)
  final String? district;
  @JsonKey(name: 'districtName', includeIfNull: false)
  final String? districtName;
  @JsonKey(name: 'ward', includeIfNull: false)
  final String? ward;
  @JsonKey(name: 'wardName', includeIfNull: false)
  final String? wardName;
  @JsonKey(name: 'street', includeIfNull: false)
  final String? street;
  @JsonKey(name: 'street2', includeIfNull: false)
  final String? street2;
  @JsonKey(name: 'zip', includeIfNull: false)
  final String? zip;
  static const fromJsonFactory = _$AddressFromJson;
  static const toJsonFactory = _$AddressToJson;
  Map<String, dynamic> toJson() => _$AddressToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Address &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality()
                    .equals(other.countryCode, countryCode)) &&
            (identical(other.countryName, countryName) ||
                const DeepCollectionEquality()
                    .equals(other.countryName, countryName)) &&
            (identical(other.province, province) ||
                const DeepCollectionEquality()
                    .equals(other.province, province)) &&
            (identical(other.provinceName, provinceName) ||
                const DeepCollectionEquality()
                    .equals(other.provinceName, provinceName)) &&
            (identical(other.district, district) ||
                const DeepCollectionEquality()
                    .equals(other.district, district)) &&
            (identical(other.districtName, districtName) ||
                const DeepCollectionEquality()
                    .equals(other.districtName, districtName)) &&
            (identical(other.ward, ward) ||
                const DeepCollectionEquality().equals(other.ward, ward)) &&
            (identical(other.wardName, wardName) ||
                const DeepCollectionEquality()
                    .equals(other.wardName, wardName)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.street2, street2) ||
                const DeepCollectionEquality()
                    .equals(other.street2, street2)) &&
            (identical(other.zip, zip) ||
                const DeepCollectionEquality().equals(other.zip, zip)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(countryName) ^
      const DeepCollectionEquality().hash(province) ^
      const DeepCollectionEquality().hash(provinceName) ^
      const DeepCollectionEquality().hash(district) ^
      const DeepCollectionEquality().hash(districtName) ^
      const DeepCollectionEquality().hash(ward) ^
      const DeepCollectionEquality().hash(wardName) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(street2) ^
      const DeepCollectionEquality().hash(zip) ^
      runtimeType.hashCode;
}

extension $AddressExtension on Address {
  Address copyWith(
      {List<String>? type,
      String? countryCode,
      String? countryName,
      String? province,
      String? provinceName,
      String? district,
      String? districtName,
      String? ward,
      String? wardName,
      String? street,
      String? street2,
      String? zip}) {
    return Address(
        type: type ?? this.type,
        countryCode: countryCode ?? this.countryCode,
        countryName: countryName ?? this.countryName,
        province: province ?? this.province,
        provinceName: provinceName ?? this.provinceName,
        district: district ?? this.district,
        districtName: districtName ?? this.districtName,
        ward: ward ?? this.ward,
        wardName: wardName ?? this.wardName,
        street: street ?? this.street,
        street2: street2 ?? this.street2,
        zip: zip ?? this.zip);
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCategory {
  BaseCategory({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.parentId,
    this.parentPath,
    required this.name,
    required this.displayName,
    required this.type,
    required this.alias,
    this.detail,
    this.description,
    this.order,
    this.statusObj,
    this.status,
    this.isDeleted,
    this.imageUrl,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.aclObject,
    this.acl,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.labelsObjs,
    this.labelsJson,
    this.isActive,
  });

  factory BaseCategory.fromJson(Map<String, dynamic> json) =>
      _$BaseCategoryFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentPath', includeIfNull: false)
  final String? parentPath;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'displayName', includeIfNull: false)
  final String displayName;
  @JsonKey(name: 'type', includeIfNull: false)
  final String type;
  @JsonKey(name: 'alias', includeIfNull: false)
  final String alias;
  @JsonKey(name: 'detail', includeIfNull: false)
  final String? detail;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: statusEnumsToJson,
      fromJson: statusEnumsFromJson)
  final enums.StatusEnums? statusObj;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'isDeleted', includeIfNull: false)
  final bool? isDeleted;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'acl', includeIfNull: false)
  final String? acl;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labelsJson', includeIfNull: false)
  final String? labelsJson;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  static const fromJsonFactory = _$BaseCategoryFromJson;
  static const toJsonFactory = _$BaseCategoryToJson;
  Map<String, dynamic> toJson() => _$BaseCategoryToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BaseCategory &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentPath, parentPath) ||
                const DeepCollectionEquality()
                    .equals(other.parentPath, parentPath)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.alias, alias) ||
                const DeepCollectionEquality().equals(other.alias, alias)) &&
            (identical(other.detail, detail) ||
                const DeepCollectionEquality().equals(other.detail, detail)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.statusObj, statusObj) ||
                const DeepCollectionEquality()
                    .equals(other.statusObj, statusObj)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.isDeleted, isDeleted) ||
                const DeepCollectionEquality()
                    .equals(other.isDeleted, isDeleted)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.cLeft, cLeft) ||
                const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) ||
                const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) ||
                const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.aclObject, aclObject) ||
                const DeepCollectionEquality()
                    .equals(other.aclObject, aclObject)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.labelsObjs, labelsObjs) || const DeepCollectionEquality().equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labelsJson, labelsJson) || const DeepCollectionEquality().equals(other.labelsJson, labelsJson)) &&
            (identical(other.isActive, isActive) || const DeepCollectionEquality().equals(other.isActive, isActive)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentPath) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(alias) ^
      const DeepCollectionEquality().hash(detail) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(isDeleted) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labelsJson) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $BaseCategoryExtension on BaseCategory {
  BaseCategory copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? parentId,
      String? parentPath,
      String? name,
      String? displayName,
      String? type,
      String? alias,
      String? detail,
      String? description,
      int? order,
      enums.StatusEnums? statusObj,
      int? status,
      bool? isDeleted,
      String? imageUrl,
      int? cLeft,
      int? cRight,
      int? cLevel,
      ACLObject? aclObject,
      String? acl,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      List<LabelsObj>? labelsObjs,
      String? labelsJson,
      bool? isActive}) {
    return BaseCategory(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        parentId: parentId ?? this.parentId,
        parentPath: parentPath ?? this.parentPath,
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        type: type ?? this.type,
        alias: alias ?? this.alias,
        detail: detail ?? this.detail,
        description: description ?? this.description,
        order: order ?? this.order,
        statusObj: statusObj ?? this.statusObj,
        status: status ?? this.status,
        isDeleted: isDeleted ?? this.isDeleted,
        imageUrl: imageUrl ?? this.imageUrl,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        aclObject: aclObject ?? this.aclObject,
        acl: acl ?? this.acl,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labelsJson: labelsJson ?? this.labelsJson,
        isActive: isActive ?? this.isActive);
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCategoryPagination {
  BaseCategoryPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory BaseCategoryPagination.fromJson(Map<String, dynamic> json) =>
      _$BaseCategoryPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content', includeIfNull: false, defaultValue: <BaseCategory>[])
  final List<BaseCategory>? content;
  static const fromJsonFactory = _$BaseCategoryPaginationFromJson;
  static const toJsonFactory = _$BaseCategoryPaginationToJson;
  Map<String, dynamic> toJson() => _$BaseCategoryPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BaseCategoryPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $BaseCategoryPaginationExtension on BaseCategoryPagination {
  BaseCategoryPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<BaseCategory>? content}) {
    return BaseCategoryPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCategoryResponseObject {
  BaseCategoryResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BaseCategoryResponseObject.fromJson(Map<String, dynamic> json) =>
      _$BaseCategoryResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final BaseCategory? data;
  static const fromJsonFactory = _$BaseCategoryResponseObjectFromJson;
  static const toJsonFactory = _$BaseCategoryResponseObjectToJson;
  Map<String, dynamic> toJson() => _$BaseCategoryResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BaseCategoryResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BaseCategoryResponseObjectExtension on BaseCategoryResponseObject {
  BaseCategoryResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, BaseCategory? data}) {
    return BaseCategoryResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCategoryResponsePagination {
  BaseCategoryResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BaseCategoryResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$BaseCategoryResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final BaseCategoryPagination? data;
  static const fromJsonFactory = _$BaseCategoryResponsePaginationFromJson;
  static const toJsonFactory = _$BaseCategoryResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$BaseCategoryResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BaseCategoryResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BaseCategoryResponsePaginationExtension
    on BaseCategoryResponsePagination {
  BaseCategoryResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      BaseCategoryPagination? data}) {
    return BaseCategoryResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCategoryViewModel {
  BaseCategoryViewModel({
    this.categoryId,
    this.parentId,
    this.parentPath,
    required this.name,
    this.displayName,
    required this.type,
    required this.alias,
    this.detail,
    this.description,
    this.order,
    this.isActive,
    this.status,
    this.imageUrl,
    this.metadataContentObjs,
    this.parent,
    this.children,
  });

  factory BaseCategoryViewModel.fromJson(Map<String, dynamic> json) =>
      _$BaseCategoryViewModelFromJson(json);

  @JsonKey(name: 'categoryId', includeIfNull: false)
  final String? categoryId;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentPath', includeIfNull: false)
  final String? parentPath;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'displayName', includeIfNull: false)
  final String? displayName;
  @JsonKey(name: 'type', includeIfNull: false)
  final String type;
  @JsonKey(name: 'alias', includeIfNull: false)
  final String alias;
  @JsonKey(name: 'detail', includeIfNull: false)
  final String? detail;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'parent', includeIfNull: false)
  final BaseCategoryViewModel? parent;
  @JsonKey(
      name: 'children',
      includeIfNull: false,
      defaultValue: <BaseCategoryViewModel>[])
  final List<BaseCategoryViewModel>? children;
  static const fromJsonFactory = _$BaseCategoryViewModelFromJson;
  static const toJsonFactory = _$BaseCategoryViewModelToJson;
  Map<String, dynamic> toJson() => _$BaseCategoryViewModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BaseCategoryViewModel &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentPath, parentPath) ||
                const DeepCollectionEquality()
                    .equals(other.parentPath, parentPath)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.alias, alias) ||
                const DeepCollectionEquality().equals(other.alias, alias)) &&
            (identical(other.detail, detail) ||
                const DeepCollectionEquality().equals(other.detail, detail)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.parent, parent) ||
                const DeepCollectionEquality().equals(other.parent, parent)) &&
            (identical(other.children, children) ||
                const DeepCollectionEquality()
                    .equals(other.children, children)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentPath) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(alias) ^
      const DeepCollectionEquality().hash(detail) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(parent) ^
      const DeepCollectionEquality().hash(children) ^
      runtimeType.hashCode;
}

extension $BaseCategoryViewModelExtension on BaseCategoryViewModel {
  BaseCategoryViewModel copyWith(
      {String? categoryId,
      String? parentId,
      String? parentPath,
      String? name,
      String? displayName,
      String? type,
      String? alias,
      String? detail,
      String? description,
      int? order,
      bool? isActive,
      int? status,
      String? imageUrl,
      List<MetadataValue>? metadataContentObjs,
      BaseCategoryViewModel? parent,
      List<BaseCategoryViewModel>? children}) {
    return BaseCategoryViewModel(
        categoryId: categoryId ?? this.categoryId,
        parentId: parentId ?? this.parentId,
        parentPath: parentPath ?? this.parentPath,
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        type: type ?? this.type,
        alias: alias ?? this.alias,
        detail: detail ?? this.detail,
        description: description ?? this.description,
        order: order ?? this.order,
        isActive: isActive ?? this.isActive,
        status: status ?? this.status,
        imageUrl: imageUrl ?? this.imageUrl,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        parent: parent ?? this.parent,
        children: children ?? this.children);
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCategoryViewModelPagination {
  BaseCategoryViewModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory BaseCategoryViewModelPagination.fromJson(Map<String, dynamic> json) =>
      _$BaseCategoryViewModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content',
      includeIfNull: false,
      defaultValue: <BaseCategoryViewModel>[])
  final List<BaseCategoryViewModel>? content;
  static const fromJsonFactory = _$BaseCategoryViewModelPaginationFromJson;
  static const toJsonFactory = _$BaseCategoryViewModelPaginationToJson;
  Map<String, dynamic> toJson() =>
      _$BaseCategoryViewModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BaseCategoryViewModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $BaseCategoryViewModelPaginationExtension
    on BaseCategoryViewModelPagination {
  BaseCategoryViewModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<BaseCategoryViewModel>? content}) {
    return BaseCategoryViewModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCategoryViewModelResponseObject {
  BaseCategoryViewModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BaseCategoryViewModelResponseObject.fromJson(
          Map<String, dynamic> json) =>
      _$BaseCategoryViewModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final BaseCategoryViewModel? data;
  static const fromJsonFactory = _$BaseCategoryViewModelResponseObjectFromJson;
  static const toJsonFactory = _$BaseCategoryViewModelResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$BaseCategoryViewModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BaseCategoryViewModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BaseCategoryViewModelResponseObjectExtension
    on BaseCategoryViewModelResponseObject {
  BaseCategoryViewModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      BaseCategoryViewModel? data}) {
    return BaseCategoryViewModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class BaseCategoryViewModelResponsePagination {
  BaseCategoryViewModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BaseCategoryViewModelResponsePagination.fromJson(
          Map<String, dynamic> json) =>
      _$BaseCategoryViewModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final BaseCategoryViewModelPagination? data;
  static const fromJsonFactory =
      _$BaseCategoryViewModelResponsePaginationFromJson;
  static const toJsonFactory = _$BaseCategoryViewModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$BaseCategoryViewModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BaseCategoryViewModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BaseCategoryViewModelResponsePaginationExtension
    on BaseCategoryViewModelResponsePagination {
  BaseCategoryViewModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      BaseCategoryViewModelPagination? data}) {
    return BaseCategoryViewModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class BomTemp {
  BomTemp({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.objectId,
    this.objectName,
    this.objectType,
    this.quantity,
    required this.unitId,
    this.unitName,
    this.routingId,
    this.routingName,
    this.description,
    this.deXe,
    this.code,
    this.isActive,
    this.type,
    this.order,
    this.readyToProduce,
    this.pickingTypeId,
    this.companyId,
    this.companyName,
  });

  factory BomTemp.fromJson(Map<String, dynamic> json) =>
      _$BomTempFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String unitId;
  @JsonKey(name: 'unitName', includeIfNull: false)
  final String? unitName;
  @JsonKey(name: 'routingId', includeIfNull: false)
  final String? routingId;
  @JsonKey(name: 'routingName', includeIfNull: false)
  final String? routingName;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'deXe', includeIfNull: false)
  final double? deXe;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'readyToProduce', includeIfNull: false)
  final String? readyToProduce;
  @JsonKey(name: 'pickingTypeId', includeIfNull: false)
  final String? pickingTypeId;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  @JsonKey(name: 'companyName', includeIfNull: false)
  final String? companyName;
  static const fromJsonFactory = _$BomTempFromJson;
  static const toJsonFactory = _$BomTempToJson;
  Map<String, dynamic> toJson() => _$BomTempToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BomTemp &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unitName, unitName) ||
                const DeepCollectionEquality()
                    .equals(other.unitName, unitName)) &&
            (identical(other.routingId, routingId) ||
                const DeepCollectionEquality()
                    .equals(other.routingId, routingId)) &&
            (identical(other.routingName, routingName) ||
                const DeepCollectionEquality()
                    .equals(other.routingName, routingName)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.deXe, deXe) ||
                const DeepCollectionEquality().equals(other.deXe, deXe)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.readyToProduce, readyToProduce) ||
                const DeepCollectionEquality()
                    .equals(other.readyToProduce, readyToProduce)) &&
            (identical(other.pickingTypeId, pickingTypeId) ||
                const DeepCollectionEquality().equals(other.pickingTypeId, pickingTypeId)) &&
            (identical(other.companyId, companyId) || const DeepCollectionEquality().equals(other.companyId, companyId)) &&
            (identical(other.companyName, companyName) || const DeepCollectionEquality().equals(other.companyName, companyName)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unitName) ^
      const DeepCollectionEquality().hash(routingId) ^
      const DeepCollectionEquality().hash(routingName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(deXe) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(readyToProduce) ^
      const DeepCollectionEquality().hash(pickingTypeId) ^
      const DeepCollectionEquality().hash(companyId) ^
      const DeepCollectionEquality().hash(companyName) ^
      runtimeType.hashCode;
}

extension $BomTempExtension on BomTemp {
  BomTemp copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? objectId,
      String? objectName,
      String? objectType,
      double? quantity,
      String? unitId,
      String? unitName,
      String? routingId,
      String? routingName,
      String? description,
      double? deXe,
      String? code,
      bool? isActive,
      String? type,
      int? order,
      String? readyToProduce,
      String? pickingTypeId,
      String? companyId,
      String? companyName}) {
    return BomTemp(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        objectId: objectId ?? this.objectId,
        objectName: objectName ?? this.objectName,
        objectType: objectType ?? this.objectType,
        quantity: quantity ?? this.quantity,
        unitId: unitId ?? this.unitId,
        unitName: unitName ?? this.unitName,
        routingId: routingId ?? this.routingId,
        routingName: routingName ?? this.routingName,
        description: description ?? this.description,
        deXe: deXe ?? this.deXe,
        code: code ?? this.code,
        isActive: isActive ?? this.isActive,
        type: type ?? this.type,
        order: order ?? this.order,
        readyToProduce: readyToProduce ?? this.readyToProduce,
        pickingTypeId: pickingTypeId ?? this.pickingTypeId,
        companyId: companyId ?? this.companyId,
        companyName: companyName ?? this.companyName);
  }
}

@JsonSerializable(explicitToJson: true)
class BomTempLineModel {
  BomTempLineModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.objectId,
    this.objectName,
    this.objectType,
    this.quantity,
    this.objectAttributeValueId,
    this.objectAttributeValueName,
    this.objectGroup,
    required this.bomTempId,
    required this.unitId,
    this.unitName,
    this.order,
    this.routingId,
    this.routingName,
    this.operationId,
    this.description,
    this.workCenterId,
  });

  factory BomTempLineModel.fromJson(Map<String, dynamic> json) =>
      _$BomTempLineModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'objectAttributeValueId', includeIfNull: false)
  final String? objectAttributeValueId;
  @JsonKey(name: 'objectAttributeValueName', includeIfNull: false)
  final String? objectAttributeValueName;
  @JsonKey(name: 'objectGroup', includeIfNull: false)
  final String? objectGroup;
  @JsonKey(name: 'bomTempId', includeIfNull: false)
  final String bomTempId;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String unitId;
  @JsonKey(name: 'unitName', includeIfNull: false)
  final String? unitName;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'routingId', includeIfNull: false)
  final String? routingId;
  @JsonKey(name: 'routingName', includeIfNull: false)
  final String? routingName;
  @JsonKey(name: 'operationId', includeIfNull: false)
  final String? operationId;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'workCenterId', includeIfNull: false)
  final String? workCenterId;
  static const fromJsonFactory = _$BomTempLineModelFromJson;
  static const toJsonFactory = _$BomTempLineModelToJson;
  Map<String, dynamic> toJson() => _$BomTempLineModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BomTempLineModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.objectAttributeValueId, objectAttributeValueId) ||
                const DeepCollectionEquality().equals(
                    other.objectAttributeValueId, objectAttributeValueId)) &&
            (identical(other.objectAttributeValueName, objectAttributeValueName) ||
                const DeepCollectionEquality().equals(
                    other.objectAttributeValueName,
                    objectAttributeValueName)) &&
            (identical(other.objectGroup, objectGroup) ||
                const DeepCollectionEquality()
                    .equals(other.objectGroup, objectGroup)) &&
            (identical(other.bomTempId, bomTempId) ||
                const DeepCollectionEquality()
                    .equals(other.bomTempId, bomTempId)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unitName, unitName) ||
                const DeepCollectionEquality()
                    .equals(other.unitName, unitName)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.routingId, routingId) ||
                const DeepCollectionEquality()
                    .equals(other.routingId, routingId)) &&
            (identical(other.routingName, routingName) ||
                const DeepCollectionEquality().equals(other.routingName, routingName)) &&
            (identical(other.operationId, operationId) || const DeepCollectionEquality().equals(other.operationId, operationId)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.workCenterId, workCenterId) || const DeepCollectionEquality().equals(other.workCenterId, workCenterId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(objectAttributeValueId) ^
      const DeepCollectionEquality().hash(objectAttributeValueName) ^
      const DeepCollectionEquality().hash(objectGroup) ^
      const DeepCollectionEquality().hash(bomTempId) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unitName) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(routingId) ^
      const DeepCollectionEquality().hash(routingName) ^
      const DeepCollectionEquality().hash(operationId) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(workCenterId) ^
      runtimeType.hashCode;
}

extension $BomTempLineModelExtension on BomTempLineModel {
  BomTempLineModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? objectId,
      String? objectName,
      String? objectType,
      double? quantity,
      String? objectAttributeValueId,
      String? objectAttributeValueName,
      String? objectGroup,
      String? bomTempId,
      String? unitId,
      String? unitName,
      int? order,
      String? routingId,
      String? routingName,
      String? operationId,
      String? description,
      String? workCenterId}) {
    return BomTempLineModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        objectId: objectId ?? this.objectId,
        objectName: objectName ?? this.objectName,
        objectType: objectType ?? this.objectType,
        quantity: quantity ?? this.quantity,
        objectAttributeValueId:
            objectAttributeValueId ?? this.objectAttributeValueId,
        objectAttributeValueName:
            objectAttributeValueName ?? this.objectAttributeValueName,
        objectGroup: objectGroup ?? this.objectGroup,
        bomTempId: bomTempId ?? this.bomTempId,
        unitId: unitId ?? this.unitId,
        unitName: unitName ?? this.unitName,
        order: order ?? this.order,
        routingId: routingId ?? this.routingId,
        routingName: routingName ?? this.routingName,
        operationId: operationId ?? this.operationId,
        description: description ?? this.description,
        workCenterId: workCenterId ?? this.workCenterId);
  }
}

@JsonSerializable(explicitToJson: true)
class BomTempModel {
  BomTempModel({
    this.id,
    this.objectId,
    this.objectName,
    this.objectType,
    this.quantity,
    this.unitId,
    this.unitName,
    this.routingId,
    this.routingName,
    this.description,
    this.deXe,
    this.code,
    this.isActive,
    this.type,
    this.order,
    this.readyToProduce,
    this.pickingTypeId,
    this.companyId,
    this.companyName,
    this.metadataContentObjs,
    this.bomTempDetails,
  });

  factory BomTempModel.fromJson(Map<String, dynamic> json) =>
      _$BomTempModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'unitName', includeIfNull: false)
  final String? unitName;
  @JsonKey(name: 'routingId', includeIfNull: false)
  final String? routingId;
  @JsonKey(name: 'routingName', includeIfNull: false)
  final String? routingName;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'deXe', includeIfNull: false)
  final double? deXe;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'readyToProduce', includeIfNull: false)
  final String? readyToProduce;
  @JsonKey(name: 'pickingTypeId', includeIfNull: false)
  final String? pickingTypeId;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  @JsonKey(name: 'companyName', includeIfNull: false)
  final String? companyName;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(
      name: 'bomTempDetails',
      includeIfNull: false,
      defaultValue: <BomTempLineModel>[])
  final List<BomTempLineModel>? bomTempDetails;
  static const fromJsonFactory = _$BomTempModelFromJson;
  static const toJsonFactory = _$BomTempModelToJson;
  Map<String, dynamic> toJson() => _$BomTempModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BomTempModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unitName, unitName) ||
                const DeepCollectionEquality()
                    .equals(other.unitName, unitName)) &&
            (identical(other.routingId, routingId) ||
                const DeepCollectionEquality()
                    .equals(other.routingId, routingId)) &&
            (identical(other.routingName, routingName) ||
                const DeepCollectionEquality()
                    .equals(other.routingName, routingName)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.deXe, deXe) ||
                const DeepCollectionEquality().equals(other.deXe, deXe)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.readyToProduce, readyToProduce) ||
                const DeepCollectionEquality()
                    .equals(other.readyToProduce, readyToProduce)) &&
            (identical(other.pickingTypeId, pickingTypeId) ||
                const DeepCollectionEquality()
                    .equals(other.pickingTypeId, pickingTypeId)) &&
            (identical(other.companyId, companyId) ||
                const DeepCollectionEquality()
                    .equals(other.companyId, companyId)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.bomTempDetails, bomTempDetails) ||
                const DeepCollectionEquality()
                    .equals(other.bomTempDetails, bomTempDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unitName) ^
      const DeepCollectionEquality().hash(routingId) ^
      const DeepCollectionEquality().hash(routingName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(deXe) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(readyToProduce) ^
      const DeepCollectionEquality().hash(pickingTypeId) ^
      const DeepCollectionEquality().hash(companyId) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(bomTempDetails) ^
      runtimeType.hashCode;
}

extension $BomTempModelExtension on BomTempModel {
  BomTempModel copyWith(
      {String? id,
      String? objectId,
      String? objectName,
      String? objectType,
      double? quantity,
      String? unitId,
      String? unitName,
      String? routingId,
      String? routingName,
      String? description,
      double? deXe,
      String? code,
      bool? isActive,
      String? type,
      int? order,
      String? readyToProduce,
      String? pickingTypeId,
      String? companyId,
      String? companyName,
      List<MetadataValue>? metadataContentObjs,
      List<BomTempLineModel>? bomTempDetails}) {
    return BomTempModel(
        id: id ?? this.id,
        objectId: objectId ?? this.objectId,
        objectName: objectName ?? this.objectName,
        objectType: objectType ?? this.objectType,
        quantity: quantity ?? this.quantity,
        unitId: unitId ?? this.unitId,
        unitName: unitName ?? this.unitName,
        routingId: routingId ?? this.routingId,
        routingName: routingName ?? this.routingName,
        description: description ?? this.description,
        deXe: deXe ?? this.deXe,
        code: code ?? this.code,
        isActive: isActive ?? this.isActive,
        type: type ?? this.type,
        order: order ?? this.order,
        readyToProduce: readyToProduce ?? this.readyToProduce,
        pickingTypeId: pickingTypeId ?? this.pickingTypeId,
        companyId: companyId ?? this.companyId,
        companyName: companyName ?? this.companyName,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        bomTempDetails: bomTempDetails ?? this.bomTempDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class BomTempModelResponseObject {
  BomTempModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BomTempModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$BomTempModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final BomTempModel? data;
  static const fromJsonFactory = _$BomTempModelResponseObjectFromJson;
  static const toJsonFactory = _$BomTempModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$BomTempModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BomTempModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BomTempModelResponseObjectExtension on BomTempModelResponseObject {
  BomTempModelResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, BomTempModel? data}) {
    return BomTempModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class BomTempPagination {
  BomTempPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory BomTempPagination.fromJson(Map<String, dynamic> json) =>
      _$BomTempPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: <BomTemp>[])
  final List<BomTemp>? content;
  static const fromJsonFactory = _$BomTempPaginationFromJson;
  static const toJsonFactory = _$BomTempPaginationToJson;
  Map<String, dynamic> toJson() => _$BomTempPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BomTempPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $BomTempPaginationExtension on BomTempPagination {
  BomTempPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<BomTemp>? content}) {
    return BomTempPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class BomTempResponseList {
  BomTempResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BomTempResponseList.fromJson(Map<String, dynamic> json) =>
      _$BomTempResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <BomTemp>[])
  final List<BomTemp>? data;
  static const fromJsonFactory = _$BomTempResponseListFromJson;
  static const toJsonFactory = _$BomTempResponseListToJson;
  Map<String, dynamic> toJson() => _$BomTempResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BomTempResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BomTempResponseListExtension on BomTempResponseList {
  BomTempResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<BomTemp>? data}) {
    return BomTempResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class BomTempResponseObject {
  BomTempResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BomTempResponseObject.fromJson(Map<String, dynamic> json) =>
      _$BomTempResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final BomTemp? data;
  static const fromJsonFactory = _$BomTempResponseObjectFromJson;
  static const toJsonFactory = _$BomTempResponseObjectToJson;
  Map<String, dynamic> toJson() => _$BomTempResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BomTempResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BomTempResponseObjectExtension on BomTempResponseObject {
  BomTempResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, BomTemp? data}) {
    return BomTempResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class BomTempResponsePagination {
  BomTempResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BomTempResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$BomTempResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final BomTempPagination? data;
  static const fromJsonFactory = _$BomTempResponsePaginationFromJson;
  static const toJsonFactory = _$BomTempResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$BomTempResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BomTempResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BomTempResponsePaginationExtension on BomTempResponsePagination {
  BomTempResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      BomTempPagination? data}) {
    return BomTempResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class BooleanResponseObject {
  BooleanResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory BooleanResponseObject.fromJson(Map<String, dynamic> json) =>
      _$BooleanResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final bool? data;
  static const fromJsonFactory = _$BooleanResponseObjectFromJson;
  static const toJsonFactory = _$BooleanResponseObjectToJson;
  Map<String, dynamic> toJson() => _$BooleanResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BooleanResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $BooleanResponseObjectExtension on BooleanResponseObject {
  BooleanResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, bool? data}) {
    return BooleanResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class CategoryOrderModel {
  CategoryOrderModel({
    this.id,
    this.order,
  });

  factory CategoryOrderModel.fromJson(Map<String, dynamic> json) =>
      _$CategoryOrderModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  static const fromJsonFactory = _$CategoryOrderModelFromJson;
  static const toJsonFactory = _$CategoryOrderModelToJson;
  Map<String, dynamic> toJson() => _$CategoryOrderModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CategoryOrderModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(order) ^
      runtimeType.hashCode;
}

extension $CategoryOrderModelExtension on CategoryOrderModel {
  CategoryOrderModel copyWith({String? id, int? order}) {
    return CategoryOrderModel(id: id ?? this.id, order: order ?? this.order);
  }
}

@JsonSerializable(explicitToJson: true)
class CategoryPatchRequestModel {
  CategoryPatchRequestModel({
    this.parentId,
    this.name,
    this.displayName,
    this.type,
    this.alias,
    this.detail,
    this.description,
    this.order,
    this.isActive,
    this.statusObj,
    this.imageUrl,
    this.metadataContentObjs,
    this.labelsObjs,
  });

  factory CategoryPatchRequestModel.fromJson(Map<String, dynamic> json) =>
      _$CategoryPatchRequestModelFromJson(json);

  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'displayName', includeIfNull: false)
  final String? displayName;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'alias', includeIfNull: false)
  final String? alias;
  @JsonKey(name: 'detail', includeIfNull: false)
  final String? detail;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: statusEnumsToJson,
      fromJson: statusEnumsFromJson)
  final enums.StatusEnums? statusObj;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  static const fromJsonFactory = _$CategoryPatchRequestModelFromJson;
  static const toJsonFactory = _$CategoryPatchRequestModelToJson;
  Map<String, dynamic> toJson() => _$CategoryPatchRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CategoryPatchRequestModel &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.alias, alias) ||
                const DeepCollectionEquality().equals(other.alias, alias)) &&
            (identical(other.detail, detail) ||
                const DeepCollectionEquality().equals(other.detail, detail)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.statusObj, statusObj) ||
                const DeepCollectionEquality()
                    .equals(other.statusObj, statusObj)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(alias) ^
      const DeepCollectionEquality().hash(detail) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      runtimeType.hashCode;
}

extension $CategoryPatchRequestModelExtension on CategoryPatchRequestModel {
  CategoryPatchRequestModel copyWith(
      {String? parentId,
      String? name,
      String? displayName,
      String? type,
      String? alias,
      String? detail,
      String? description,
      int? order,
      bool? isActive,
      enums.StatusEnums? statusObj,
      String? imageUrl,
      List<MetadataValue>? metadataContentObjs,
      List<LabelsObj>? labelsObjs}) {
    return CategoryPatchRequestModel(
        parentId: parentId ?? this.parentId,
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        type: type ?? this.type,
        alias: alias ?? this.alias,
        detail: detail ?? this.detail,
        description: description ?? this.description,
        order: order ?? this.order,
        isActive: isActive ?? this.isActive,
        statusObj: statusObj ?? this.statusObj,
        imageUrl: imageUrl ?? this.imageUrl,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        labelsObjs: labelsObjs ?? this.labelsObjs);
  }
}

@JsonSerializable(explicitToJson: true)
class CategoryRequestModel {
  CategoryRequestModel({
    this.id,
    this.parentId,
    required this.name,
    this.displayName,
    required this.type,
    required this.alias,
    this.detail,
    this.description,
    this.statusObj,
    this.imageUrl,
    this.metadataContentObjs,
    this.labelsObjs,
    this.order,
    this.isActive,
  });

  factory CategoryRequestModel.fromJson(Map<String, dynamic> json) =>
      _$CategoryRequestModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'displayName', includeIfNull: false)
  final String? displayName;
  @JsonKey(name: 'type', includeIfNull: false)
  final String type;
  @JsonKey(name: 'alias', includeIfNull: false)
  final String alias;
  @JsonKey(name: 'detail', includeIfNull: false)
  final String? detail;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: statusEnumsToJson,
      fromJson: statusEnumsFromJson)
  final enums.StatusEnums? statusObj;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  static const fromJsonFactory = _$CategoryRequestModelFromJson;
  static const toJsonFactory = _$CategoryRequestModelToJson;
  Map<String, dynamic> toJson() => _$CategoryRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CategoryRequestModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.alias, alias) ||
                const DeepCollectionEquality().equals(other.alias, alias)) &&
            (identical(other.detail, detail) ||
                const DeepCollectionEquality().equals(other.detail, detail)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.statusObj, statusObj) ||
                const DeepCollectionEquality()
                    .equals(other.statusObj, statusObj)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(alias) ^
      const DeepCollectionEquality().hash(detail) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $CategoryRequestModelExtension on CategoryRequestModel {
  CategoryRequestModel copyWith(
      {String? id,
      String? parentId,
      String? name,
      String? displayName,
      String? type,
      String? alias,
      String? detail,
      String? description,
      enums.StatusEnums? statusObj,
      String? imageUrl,
      List<MetadataValue>? metadataContentObjs,
      List<LabelsObj>? labelsObjs,
      int? order,
      bool? isActive}) {
    return CategoryRequestModel(
        id: id ?? this.id,
        parentId: parentId ?? this.parentId,
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        type: type ?? this.type,
        alias: alias ?? this.alias,
        detail: detail ?? this.detail,
        description: description ?? this.description,
        statusObj: statusObj ?? this.statusObj,
        imageUrl: imageUrl ?? this.imageUrl,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        order: order ?? this.order,
        isActive: isActive ?? this.isActive);
  }
}

@JsonSerializable(explicitToJson: true)
class Comment {
  Comment({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.objectId,
    this.objectType,
    this.ref,
    this.message,
    this.statusObj,
    this.status,
    this.attachment,
    this.username,
    this.userdisplay,
  });

  factory Comment.fromJson(Map<String, dynamic> json) =>
      _$CommentFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'ref', includeIfNull: false)
  final String? ref;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: commentStatusEnumsToJson,
      fromJson: commentStatusEnumsFromJson)
  final enums.CommentStatusEnums? statusObj;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'attachment', includeIfNull: false)
  final String? attachment;
  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'userdisplay', includeIfNull: false)
  final String? userdisplay;
  static const fromJsonFactory = _$CommentFromJson;
  static const toJsonFactory = _$CommentToJson;
  Map<String, dynamic> toJson() => _$CommentToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Comment &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.ref, ref) ||
                const DeepCollectionEquality().equals(other.ref, ref)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.statusObj, statusObj) ||
                const DeepCollectionEquality()
                    .equals(other.statusObj, statusObj)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.attachment, attachment) ||
                const DeepCollectionEquality()
                    .equals(other.attachment, attachment)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.userdisplay, userdisplay) ||
                const DeepCollectionEquality()
                    .equals(other.userdisplay, userdisplay)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(ref) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(attachment) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(userdisplay) ^
      runtimeType.hashCode;
}

extension $CommentExtension on Comment {
  Comment copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? objectId,
      String? objectType,
      String? ref,
      String? message,
      enums.CommentStatusEnums? statusObj,
      int? status,
      String? attachment,
      String? username,
      String? userdisplay}) {
    return Comment(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        ref: ref ?? this.ref,
        message: message ?? this.message,
        statusObj: statusObj ?? this.statusObj,
        status: status ?? this.status,
        attachment: attachment ?? this.attachment,
        username: username ?? this.username,
        userdisplay: userdisplay ?? this.userdisplay);
  }
}

@JsonSerializable(explicitToJson: true)
class CommentPagination {
  CommentPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory CommentPagination.fromJson(Map<String, dynamic> json) =>
      _$CommentPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: <Comment>[])
  final List<Comment>? content;
  static const fromJsonFactory = _$CommentPaginationFromJson;
  static const toJsonFactory = _$CommentPaginationToJson;
  Map<String, dynamic> toJson() => _$CommentPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CommentPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $CommentPaginationExtension on CommentPagination {
  CommentPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<Comment>? content}) {
    return CommentPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class CommentRequestModel {
  CommentRequestModel({
    this.objectId,
    this.objectType,
    this.ref,
    this.message,
    this.statusObj,
    this.attachment,
  });

  factory CommentRequestModel.fromJson(Map<String, dynamic> json) =>
      _$CommentRequestModelFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'ref', includeIfNull: false)
  final String? ref;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: commentStatusEnumsToJson,
      fromJson: commentStatusEnumsFromJson)
  final enums.CommentStatusEnums? statusObj;
  @JsonKey(name: 'attachment', includeIfNull: false)
  final String? attachment;
  static const fromJsonFactory = _$CommentRequestModelFromJson;
  static const toJsonFactory = _$CommentRequestModelToJson;
  Map<String, dynamic> toJson() => _$CommentRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CommentRequestModel &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.ref, ref) ||
                const DeepCollectionEquality().equals(other.ref, ref)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.statusObj, statusObj) ||
                const DeepCollectionEquality()
                    .equals(other.statusObj, statusObj)) &&
            (identical(other.attachment, attachment) ||
                const DeepCollectionEquality()
                    .equals(other.attachment, attachment)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(ref) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(attachment) ^
      runtimeType.hashCode;
}

extension $CommentRequestModelExtension on CommentRequestModel {
  CommentRequestModel copyWith(
      {String? objectId,
      String? objectType,
      String? ref,
      String? message,
      enums.CommentStatusEnums? statusObj,
      String? attachment}) {
    return CommentRequestModel(
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        ref: ref ?? this.ref,
        message: message ?? this.message,
        statusObj: statusObj ?? this.statusObj,
        attachment: attachment ?? this.attachment);
  }
}

@JsonSerializable(explicitToJson: true)
class CommentResponseObject {
  CommentResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory CommentResponseObject.fromJson(Map<String, dynamic> json) =>
      _$CommentResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final Comment? data;
  static const fromJsonFactory = _$CommentResponseObjectFromJson;
  static const toJsonFactory = _$CommentResponseObjectToJson;
  Map<String, dynamic> toJson() => _$CommentResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CommentResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $CommentResponseObjectExtension on CommentResponseObject {
  CommentResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, Comment? data}) {
    return CommentResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class CommentResponsePagination {
  CommentResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory CommentResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$CommentResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final CommentPagination? data;
  static const fromJsonFactory = _$CommentResponsePaginationFromJson;
  static const toJsonFactory = _$CommentResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$CommentResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CommentResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $CommentResponsePaginationExtension on CommentResponsePagination {
  CommentResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      CommentPagination? data}) {
    return CommentResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class CommentStatusRequestModel {
  CommentStatusRequestModel({
    this.statusObj,
  });

  factory CommentStatusRequestModel.fromJson(Map<String, dynamic> json) =>
      _$CommentStatusRequestModelFromJson(json);

  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: commentStatusEnumsToJson,
      fromJson: commentStatusEnumsFromJson)
  final enums.CommentStatusEnums? statusObj;
  static const fromJsonFactory = _$CommentStatusRequestModelFromJson;
  static const toJsonFactory = _$CommentStatusRequestModelToJson;
  Map<String, dynamic> toJson() => _$CommentStatusRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CommentStatusRequestModel &&
            (identical(other.statusObj, statusObj) ||
                const DeepCollectionEquality()
                    .equals(other.statusObj, statusObj)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(statusObj) ^ runtimeType.hashCode;
}

extension $CommentStatusRequestModelExtension on CommentStatusRequestModel {
  CommentStatusRequestModel copyWith({enums.CommentStatusEnums? statusObj}) {
    return CommentStatusRequestModel(statusObj: statusObj ?? this.statusObj);
  }
}

@JsonSerializable(explicitToJson: true)
class CreateTreeInventoryAdjustmentRequest {
  CreateTreeInventoryAdjustmentRequest({
    this.objectId,
    this.lotId,
    this.locationDestId,
    this.locationDestName,
    this.referenceDestId,
    this.referenceDest,
    this.parentLocationDestId,
    this.objectName,
    this.quantity,
    this.voucherType,
    this.description,
  });

  factory CreateTreeInventoryAdjustmentRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreateTreeInventoryAdjustmentRequestFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'lotId', includeIfNull: false)
  final String? lotId;
  @JsonKey(name: 'locationDestId', includeIfNull: false)
  final String? locationDestId;
  @JsonKey(name: 'locationDestName', includeIfNull: false)
  final String? locationDestName;
  @JsonKey(name: 'referenceDestId', includeIfNull: false)
  final String? referenceDestId;
  @JsonKey(name: 'referenceDest', includeIfNull: false)
  final String? referenceDest;
  @JsonKey(name: 'parentLocationDestId', includeIfNull: false)
  final String? parentLocationDestId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'voucherType', includeIfNull: false)
  final String? voucherType;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  static const fromJsonFactory = _$CreateTreeInventoryAdjustmentRequestFromJson;
  static const toJsonFactory = _$CreateTreeInventoryAdjustmentRequestToJson;
  Map<String, dynamic> toJson() =>
      _$CreateTreeInventoryAdjustmentRequestToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreateTreeInventoryAdjustmentRequest &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.lotId, lotId) ||
                const DeepCollectionEquality().equals(other.lotId, lotId)) &&
            (identical(other.locationDestId, locationDestId) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestId, locationDestId)) &&
            (identical(other.locationDestName, locationDestName) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestName, locationDestName)) &&
            (identical(other.referenceDestId, referenceDestId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceDestId, referenceDestId)) &&
            (identical(other.referenceDest, referenceDest) ||
                const DeepCollectionEquality()
                    .equals(other.referenceDest, referenceDest)) &&
            (identical(other.parentLocationDestId, parentLocationDestId) ||
                const DeepCollectionEquality().equals(
                    other.parentLocationDestId, parentLocationDestId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.voucherType, voucherType) ||
                const DeepCollectionEquality()
                    .equals(other.voucherType, voucherType)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(lotId) ^
      const DeepCollectionEquality().hash(locationDestId) ^
      const DeepCollectionEquality().hash(locationDestName) ^
      const DeepCollectionEquality().hash(referenceDestId) ^
      const DeepCollectionEquality().hash(referenceDest) ^
      const DeepCollectionEquality().hash(parentLocationDestId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(voucherType) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $CreateTreeInventoryAdjustmentRequestExtension
    on CreateTreeInventoryAdjustmentRequest {
  CreateTreeInventoryAdjustmentRequest copyWith(
      {String? objectId,
      String? lotId,
      String? locationDestId,
      String? locationDestName,
      String? referenceDestId,
      String? referenceDest,
      String? parentLocationDestId,
      String? objectName,
      double? quantity,
      String? voucherType,
      String? description}) {
    return CreateTreeInventoryAdjustmentRequest(
        objectId: objectId ?? this.objectId,
        lotId: lotId ?? this.lotId,
        locationDestId: locationDestId ?? this.locationDestId,
        locationDestName: locationDestName ?? this.locationDestName,
        referenceDestId: referenceDestId ?? this.referenceDestId,
        referenceDest: referenceDest ?? this.referenceDest,
        parentLocationDestId: parentLocationDestId ?? this.parentLocationDestId,
        objectName: objectName ?? this.objectName,
        quantity: quantity ?? this.quantity,
        voucherType: voucherType ?? this.voucherType,
        description: description ?? this.description);
  }
}

@JsonSerializable(explicitToJson: true)
class CreateTreePickingDetailModel {
  CreateTreePickingDetailModel({
    this.referenceSrc,
    this.referenceSrcId,
    this.referenceDest,
    this.referenceDestId,
    this.parentLocationId,
    this.parentLocationName,
    this.parentPath,
    this.locationDestId,
    this.locationDestName,
    this.quantity,
    this.quantityMark,
    this.unitId,
    this.unitName,
    this.objectType,
    this.objectName,
    this.isAutoGenerateLine,
    this.productTmpId,
    this.isConfirm,
    this.metadataContentObjs,
  });

  factory CreateTreePickingDetailModel.fromJson(Map<String, dynamic> json) =>
      _$CreateTreePickingDetailModelFromJson(json);

  @JsonKey(name: 'referenceSrc', includeIfNull: false)
  final String? referenceSrc;
  @JsonKey(name: 'referenceSrcId', includeIfNull: false)
  final String? referenceSrcId;
  @JsonKey(name: 'referenceDest', includeIfNull: false)
  final String? referenceDest;
  @JsonKey(name: 'referenceDestId', includeIfNull: false)
  final String? referenceDestId;
  @JsonKey(name: 'parentLocationId', includeIfNull: false)
  final String? parentLocationId;
  @JsonKey(name: 'parentLocationName', includeIfNull: false)
  final String? parentLocationName;
  @JsonKey(name: 'parentPath', includeIfNull: false)
  final String? parentPath;
  @JsonKey(name: 'locationDestId', includeIfNull: false)
  final String? locationDestId;
  @JsonKey(name: 'locationDestName', includeIfNull: false)
  final String? locationDestName;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'quantityMark', includeIfNull: false)
  final double? quantityMark;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'unitName', includeIfNull: false)
  final String? unitName;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'isAutoGenerateLine', includeIfNull: false)
  final bool? isAutoGenerateLine;
  @JsonKey(name: 'productTmpId', includeIfNull: false)
  final String? productTmpId;
  @JsonKey(name: 'isConfirm', includeIfNull: false)
  final bool? isConfirm;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  static const fromJsonFactory = _$CreateTreePickingDetailModelFromJson;
  static const toJsonFactory = _$CreateTreePickingDetailModelToJson;
  Map<String, dynamic> toJson() => _$CreateTreePickingDetailModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreateTreePickingDetailModel &&
            (identical(other.referenceSrc, referenceSrc) ||
                const DeepCollectionEquality()
                    .equals(other.referenceSrc, referenceSrc)) &&
            (identical(other.referenceSrcId, referenceSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceSrcId, referenceSrcId)) &&
            (identical(other.referenceDest, referenceDest) ||
                const DeepCollectionEquality()
                    .equals(other.referenceDest, referenceDest)) &&
            (identical(other.referenceDestId, referenceDestId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceDestId, referenceDestId)) &&
            (identical(other.parentLocationId, parentLocationId) ||
                const DeepCollectionEquality()
                    .equals(other.parentLocationId, parentLocationId)) &&
            (identical(other.parentLocationName, parentLocationName) ||
                const DeepCollectionEquality()
                    .equals(other.parentLocationName, parentLocationName)) &&
            (identical(other.parentPath, parentPath) ||
                const DeepCollectionEquality()
                    .equals(other.parentPath, parentPath)) &&
            (identical(other.locationDestId, locationDestId) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestId, locationDestId)) &&
            (identical(other.locationDestName, locationDestName) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestName, locationDestName)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.quantityMark, quantityMark) ||
                const DeepCollectionEquality()
                    .equals(other.quantityMark, quantityMark)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unitName, unitName) ||
                const DeepCollectionEquality()
                    .equals(other.unitName, unitName)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.isAutoGenerateLine, isAutoGenerateLine) ||
                const DeepCollectionEquality()
                    .equals(other.isAutoGenerateLine, isAutoGenerateLine)) &&
            (identical(other.productTmpId, productTmpId) ||
                const DeepCollectionEquality()
                    .equals(other.productTmpId, productTmpId)) &&
            (identical(other.isConfirm, isConfirm) ||
                const DeepCollectionEquality()
                    .equals(other.isConfirm, isConfirm)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(referenceSrc) ^
      const DeepCollectionEquality().hash(referenceSrcId) ^
      const DeepCollectionEquality().hash(referenceDest) ^
      const DeepCollectionEquality().hash(referenceDestId) ^
      const DeepCollectionEquality().hash(parentLocationId) ^
      const DeepCollectionEquality().hash(parentLocationName) ^
      const DeepCollectionEquality().hash(parentPath) ^
      const DeepCollectionEquality().hash(locationDestId) ^
      const DeepCollectionEquality().hash(locationDestName) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(quantityMark) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unitName) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(isAutoGenerateLine) ^
      const DeepCollectionEquality().hash(productTmpId) ^
      const DeepCollectionEquality().hash(isConfirm) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      runtimeType.hashCode;
}

extension $CreateTreePickingDetailModelExtension
    on CreateTreePickingDetailModel {
  CreateTreePickingDetailModel copyWith(
      {String? referenceSrc,
      String? referenceSrcId,
      String? referenceDest,
      String? referenceDestId,
      String? parentLocationId,
      String? parentLocationName,
      String? parentPath,
      String? locationDestId,
      String? locationDestName,
      double? quantity,
      double? quantityMark,
      String? unitId,
      String? unitName,
      String? objectType,
      String? objectName,
      bool? isAutoGenerateLine,
      String? productTmpId,
      bool? isConfirm,
      List<MetadataValue>? metadataContentObjs}) {
    return CreateTreePickingDetailModel(
        referenceSrc: referenceSrc ?? this.referenceSrc,
        referenceSrcId: referenceSrcId ?? this.referenceSrcId,
        referenceDest: referenceDest ?? this.referenceDest,
        referenceDestId: referenceDestId ?? this.referenceDestId,
        parentLocationId: parentLocationId ?? this.parentLocationId,
        parentLocationName: parentLocationName ?? this.parentLocationName,
        parentPath: parentPath ?? this.parentPath,
        locationDestId: locationDestId ?? this.locationDestId,
        locationDestName: locationDestName ?? this.locationDestName,
        quantity: quantity ?? this.quantity,
        quantityMark: quantityMark ?? this.quantityMark,
        unitId: unitId ?? this.unitId,
        unitName: unitName ?? this.unitName,
        objectType: objectType ?? this.objectType,
        objectName: objectName ?? this.objectName,
        isAutoGenerateLine: isAutoGenerateLine ?? this.isAutoGenerateLine,
        productTmpId: productTmpId ?? this.productTmpId,
        isConfirm: isConfirm ?? this.isConfirm,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs);
  }
}

@JsonSerializable(explicitToJson: true)
class CreateTreePickingLotRequestModel {
  CreateTreePickingLotRequestModel({
    this.treePickingDetails,
    this.isConfirm,
  });

  factory CreateTreePickingLotRequestModel.fromJson(
          Map<String, dynamic> json) =>
      _$CreateTreePickingLotRequestModelFromJson(json);

  @JsonKey(
      name: 'treePickingDetails',
      includeIfNull: false,
      defaultValue: <CreateTreePickingDetailModel>[])
  final List<CreateTreePickingDetailModel>? treePickingDetails;
  @JsonKey(name: 'isConfirm', includeIfNull: false)
  final bool? isConfirm;
  static const fromJsonFactory = _$CreateTreePickingLotRequestModelFromJson;
  static const toJsonFactory = _$CreateTreePickingLotRequestModelToJson;
  Map<String, dynamic> toJson() =>
      _$CreateTreePickingLotRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreateTreePickingLotRequestModel &&
            (identical(other.treePickingDetails, treePickingDetails) ||
                const DeepCollectionEquality()
                    .equals(other.treePickingDetails, treePickingDetails)) &&
            (identical(other.isConfirm, isConfirm) ||
                const DeepCollectionEquality()
                    .equals(other.isConfirm, isConfirm)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(treePickingDetails) ^
      const DeepCollectionEquality().hash(isConfirm) ^
      runtimeType.hashCode;
}

extension $CreateTreePickingLotRequestModelExtension
    on CreateTreePickingLotRequestModel {
  CreateTreePickingLotRequestModel copyWith(
      {List<CreateTreePickingDetailModel>? treePickingDetails,
      bool? isConfirm}) {
    return CreateTreePickingLotRequestModel(
        treePickingDetails: treePickingDetails ?? this.treePickingDetails,
        isConfirm: isConfirm ?? this.isConfirm);
  }
}

@JsonSerializable(explicitToJson: true)
class CreateWorkOrderRequestModel {
  CreateWorkOrderRequestModel({
    this.prodId,
    this.description,
  });

  factory CreateWorkOrderRequestModel.fromJson(Map<String, dynamic> json) =>
      _$CreateWorkOrderRequestModelFromJson(json);

  @JsonKey(name: 'prodId', includeIfNull: false)
  final String? prodId;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  static const fromJsonFactory = _$CreateWorkOrderRequestModelFromJson;
  static const toJsonFactory = _$CreateWorkOrderRequestModelToJson;
  Map<String, dynamic> toJson() => _$CreateWorkOrderRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreateWorkOrderRequestModel &&
            (identical(other.prodId, prodId) ||
                const DeepCollectionEquality().equals(other.prodId, prodId)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(prodId) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $CreateWorkOrderRequestModelExtension on CreateWorkOrderRequestModel {
  CreateWorkOrderRequestModel copyWith({String? prodId, String? description}) {
    return CreateWorkOrderRequestModel(
        prodId: prodId ?? this.prodId,
        description: description ?? this.description);
  }
}

@JsonSerializable(explicitToJson: true)
class DetailAttribute {
  DetailAttribute({
    this.attributeId,
    this.attributeName,
    this.totalCost,
    this.totalCostLastTerm,
    this.difference,
  });

  factory DetailAttribute.fromJson(Map<String, dynamic> json) =>
      _$DetailAttributeFromJson(json);

  @JsonKey(name: 'attributeId', includeIfNull: false)
  final String? attributeId;
  @JsonKey(name: 'attributeName', includeIfNull: false)
  final String? attributeName;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'totalCostLastTerm', includeIfNull: false)
  final double? totalCostLastTerm;
  @JsonKey(name: 'difference', includeIfNull: false)
  final double? difference;
  static const fromJsonFactory = _$DetailAttributeFromJson;
  static const toJsonFactory = _$DetailAttributeToJson;
  Map<String, dynamic> toJson() => _$DetailAttributeToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DetailAttribute &&
            (identical(other.attributeId, attributeId) ||
                const DeepCollectionEquality()
                    .equals(other.attributeId, attributeId)) &&
            (identical(other.attributeName, attributeName) ||
                const DeepCollectionEquality()
                    .equals(other.attributeName, attributeName)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.totalCostLastTerm, totalCostLastTerm) ||
                const DeepCollectionEquality()
                    .equals(other.totalCostLastTerm, totalCostLastTerm)) &&
            (identical(other.difference, difference) ||
                const DeepCollectionEquality()
                    .equals(other.difference, difference)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attributeId) ^
      const DeepCollectionEquality().hash(attributeName) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(totalCostLastTerm) ^
      const DeepCollectionEquality().hash(difference) ^
      runtimeType.hashCode;
}

extension $DetailAttributeExtension on DetailAttribute {
  DetailAttribute copyWith(
      {String? attributeId,
      String? attributeName,
      double? totalCost,
      double? totalCostLastTerm,
      double? difference}) {
    return DetailAttribute(
        attributeId: attributeId ?? this.attributeId,
        attributeName: attributeName ?? this.attributeName,
        totalCost: totalCost ?? this.totalCost,
        totalCostLastTerm: totalCostLastTerm ?? this.totalCostLastTerm,
        difference: difference ?? this.difference);
  }
}

@JsonSerializable(explicitToJson: true)
class DetailFinanceByRef {
  DetailFinanceByRef({
    this.objectGroup,
    this.totalCost,
    this.totalCostLastTerm,
    this.difference,
    this.detailAttributes,
  });

  factory DetailFinanceByRef.fromJson(Map<String, dynamic> json) =>
      _$DetailFinanceByRefFromJson(json);

  @JsonKey(name: 'objectGroup', includeIfNull: false)
  final String? objectGroup;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'totalCostLastTerm', includeIfNull: false)
  final double? totalCostLastTerm;
  @JsonKey(name: 'difference', includeIfNull: false)
  final double? difference;
  @JsonKey(
      name: 'detailAttributes',
      includeIfNull: false,
      defaultValue: <DetailAttribute>[])
  final List<DetailAttribute>? detailAttributes;
  static const fromJsonFactory = _$DetailFinanceByRefFromJson;
  static const toJsonFactory = _$DetailFinanceByRefToJson;
  Map<String, dynamic> toJson() => _$DetailFinanceByRefToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DetailFinanceByRef &&
            (identical(other.objectGroup, objectGroup) ||
                const DeepCollectionEquality()
                    .equals(other.objectGroup, objectGroup)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.totalCostLastTerm, totalCostLastTerm) ||
                const DeepCollectionEquality()
                    .equals(other.totalCostLastTerm, totalCostLastTerm)) &&
            (identical(other.difference, difference) ||
                const DeepCollectionEquality()
                    .equals(other.difference, difference)) &&
            (identical(other.detailAttributes, detailAttributes) ||
                const DeepCollectionEquality()
                    .equals(other.detailAttributes, detailAttributes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectGroup) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(totalCostLastTerm) ^
      const DeepCollectionEquality().hash(difference) ^
      const DeepCollectionEquality().hash(detailAttributes) ^
      runtimeType.hashCode;
}

extension $DetailFinanceByRefExtension on DetailFinanceByRef {
  DetailFinanceByRef copyWith(
      {String? objectGroup,
      double? totalCost,
      double? totalCostLastTerm,
      double? difference,
      List<DetailAttribute>? detailAttributes}) {
    return DetailFinanceByRef(
        objectGroup: objectGroup ?? this.objectGroup,
        totalCost: totalCost ?? this.totalCost,
        totalCostLastTerm: totalCostLastTerm ?? this.totalCostLastTerm,
        difference: difference ?? this.difference,
        detailAttributes: detailAttributes ?? this.detailAttributes);
  }
}

@JsonSerializable(explicitToJson: true)
class DetailLocation {
  DetailLocation({
    this.productionId,
    this.objectId,
    this.objectName,
    this.state,
  });

  factory DetailLocation.fromJson(Map<String, dynamic> json) =>
      _$DetailLocationFromJson(json);

  @JsonKey(name: 'productionId', includeIfNull: false)
  final String? productionId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  static const fromJsonFactory = _$DetailLocationFromJson;
  static const toJsonFactory = _$DetailLocationToJson;
  Map<String, dynamic> toJson() => _$DetailLocationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DetailLocation &&
            (identical(other.productionId, productionId) ||
                const DeepCollectionEquality()
                    .equals(other.productionId, productionId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(productionId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(state) ^
      runtimeType.hashCode;
}

extension $DetailLocationExtension on DetailLocation {
  DetailLocation copyWith(
      {String? productionId,
      String? objectId,
      String? objectName,
      String? state}) {
    return DetailLocation(
        productionId: productionId ?? this.productionId,
        objectId: objectId ?? this.objectId,
        objectName: objectName ?? this.objectName,
        state: state ?? this.state);
  }
}

@JsonSerializable(explicitToJson: true)
class DetailMonth {
  DetailMonth({
    this.workingTimeId,
    this.time,
    this.totalCost,
    this.locationId,
  });

  factory DetailMonth.fromJson(Map<String, dynamic> json) =>
      _$DetailMonthFromJson(json);

  @JsonKey(name: 'workingTimeId', includeIfNull: false)
  final String? workingTimeId;
  @JsonKey(name: 'time', includeIfNull: false)
  final String? time;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  static const fromJsonFactory = _$DetailMonthFromJson;
  static const toJsonFactory = _$DetailMonthToJson;
  Map<String, dynamic> toJson() => _$DetailMonthToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DetailMonth &&
            (identical(other.workingTimeId, workingTimeId) ||
                const DeepCollectionEquality()
                    .equals(other.workingTimeId, workingTimeId)) &&
            (identical(other.time, time) ||
                const DeepCollectionEquality().equals(other.time, time)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(workingTimeId) ^
      const DeepCollectionEquality().hash(time) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(locationId) ^
      runtimeType.hashCode;
}

extension $DetailMonthExtension on DetailMonth {
  DetailMonth copyWith(
      {String? workingTimeId,
      String? time,
      double? totalCost,
      String? locationId}) {
    return DetailMonth(
        workingTimeId: workingTimeId ?? this.workingTimeId,
        time: time ?? this.time,
        totalCost: totalCost ?? this.totalCost,
        locationId: locationId ?? this.locationId);
  }
}

@JsonSerializable(explicitToJson: true)
class DetailObjectGroup {
  DetailObjectGroup({
    this.objectGroup,
    this.locationId,
    this.totalCost,
    this.totalCostLastTerm,
    this.difference,
    this.detailsMonth,
  });

  factory DetailObjectGroup.fromJson(Map<String, dynamic> json) =>
      _$DetailObjectGroupFromJson(json);

  @JsonKey(name: 'objectGroup', includeIfNull: false)
  final String? objectGroup;
  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'totalCostLastTerm', includeIfNull: false)
  final double? totalCostLastTerm;
  @JsonKey(name: 'difference', includeIfNull: false)
  final double? difference;
  @JsonKey(
      name: 'detailsMonth', includeIfNull: false, defaultValue: <DetailMonth>[])
  final List<DetailMonth>? detailsMonth;
  static const fromJsonFactory = _$DetailObjectGroupFromJson;
  static const toJsonFactory = _$DetailObjectGroupToJson;
  Map<String, dynamic> toJson() => _$DetailObjectGroupToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DetailObjectGroup &&
            (identical(other.objectGroup, objectGroup) ||
                const DeepCollectionEquality()
                    .equals(other.objectGroup, objectGroup)) &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.totalCostLastTerm, totalCostLastTerm) ||
                const DeepCollectionEquality()
                    .equals(other.totalCostLastTerm, totalCostLastTerm)) &&
            (identical(other.difference, difference) ||
                const DeepCollectionEquality()
                    .equals(other.difference, difference)) &&
            (identical(other.detailsMonth, detailsMonth) ||
                const DeepCollectionEquality()
                    .equals(other.detailsMonth, detailsMonth)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectGroup) ^
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(totalCostLastTerm) ^
      const DeepCollectionEquality().hash(difference) ^
      const DeepCollectionEquality().hash(detailsMonth) ^
      runtimeType.hashCode;
}

extension $DetailObjectGroupExtension on DetailObjectGroup {
  DetailObjectGroup copyWith(
      {String? objectGroup,
      String? locationId,
      double? totalCost,
      double? totalCostLastTerm,
      double? difference,
      List<DetailMonth>? detailsMonth}) {
    return DetailObjectGroup(
        objectGroup: objectGroup ?? this.objectGroup,
        locationId: locationId ?? this.locationId,
        totalCost: totalCost ?? this.totalCost,
        totalCostLastTerm: totalCostLastTerm ?? this.totalCostLastTerm,
        difference: difference ?? this.difference,
        detailsMonth: detailsMonth ?? this.detailsMonth);
  }
}

@JsonSerializable(explicitToJson: true)
class Email {
  Email({
    this.type,
    this.uri,
  });

  factory Email.fromJson(Map<String, dynamic> json) => _$EmailFromJson(json);

  @JsonKey(name: 'type', includeIfNull: false, defaultValue: <String>[])
  final List<String>? type;
  @JsonKey(name: 'uri', includeIfNull: false)
  final String? uri;
  static const fromJsonFactory = _$EmailFromJson;
  static const toJsonFactory = _$EmailToJson;
  Map<String, dynamic> toJson() => _$EmailToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Email &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.uri, uri) ||
                const DeepCollectionEquality().equals(other.uri, uri)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(uri) ^
      runtimeType.hashCode;
}

extension $EmailExtension on Email {
  Email copyWith({List<String>? type, String? uri}) {
    return Email(type: type ?? this.type, uri: uri ?? this.uri);
  }
}

@JsonSerializable(explicitToJson: true)
class EmailBodyRequestModel {
  EmailBodyRequestModel({
    this.listAvailableCommand,
    this.listUserEntity,
    this.leaderPosition,
    this.year,
    this.version,
  });

  factory EmailBodyRequestModel.fromJson(Map<String, dynamic> json) =>
      _$EmailBodyRequestModelFromJson(json);

  @JsonKey(
      name: 'listAvailableCommand',
      includeIfNull: false,
      defaultValue: <WorkflowEntity>[])
  final List<WorkflowEntity>? listAvailableCommand;
  @JsonKey(
      name: 'listUserEntity',
      includeIfNull: false,
      defaultValue: <UserEntity>[])
  final List<UserEntity>? listUserEntity;
  @JsonKey(name: 'leaderPosition', includeIfNull: false)
  final String? leaderPosition;
  @JsonKey(name: 'year', includeIfNull: false)
  final int? year;
  @JsonKey(name: 'version', includeIfNull: false)
  final int? version;
  static const fromJsonFactory = _$EmailBodyRequestModelFromJson;
  static const toJsonFactory = _$EmailBodyRequestModelToJson;
  Map<String, dynamic> toJson() => _$EmailBodyRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmailBodyRequestModel &&
            (identical(other.listAvailableCommand, listAvailableCommand) ||
                const DeepCollectionEquality().equals(
                    other.listAvailableCommand, listAvailableCommand)) &&
            (identical(other.listUserEntity, listUserEntity) ||
                const DeepCollectionEquality()
                    .equals(other.listUserEntity, listUserEntity)) &&
            (identical(other.leaderPosition, leaderPosition) ||
                const DeepCollectionEquality()
                    .equals(other.leaderPosition, leaderPosition)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(listAvailableCommand) ^
      const DeepCollectionEquality().hash(listUserEntity) ^
      const DeepCollectionEquality().hash(leaderPosition) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $EmailBodyRequestModelExtension on EmailBodyRequestModel {
  EmailBodyRequestModel copyWith(
      {List<WorkflowEntity>? listAvailableCommand,
      List<UserEntity>? listUserEntity,
      String? leaderPosition,
      int? year,
      int? version}) {
    return EmailBodyRequestModel(
        listAvailableCommand: listAvailableCommand ?? this.listAvailableCommand,
        listUserEntity: listUserEntity ?? this.listUserEntity,
        leaderPosition: leaderPosition ?? this.leaderPosition,
        year: year ?? this.year,
        version: version ?? this.version);
  }
}

@JsonSerializable(explicitToJson: true)
class Event {
  Event({
    this.label,
    this.eventDate,
  });

  factory Event.fromJson(Map<String, dynamic> json) => _$EventFromJson(json);

  @JsonKey(name: 'label', includeIfNull: false)
  final String? label;
  @JsonKey(name: 'eventDate', includeIfNull: false)
  final DateTime? eventDate;
  static const fromJsonFactory = _$EventFromJson;
  static const toJsonFactory = _$EventToJson;
  Map<String, dynamic> toJson() => _$EventToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Event &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.eventDate, eventDate) ||
                const DeepCollectionEquality()
                    .equals(other.eventDate, eventDate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(eventDate) ^
      runtimeType.hashCode;
}

extension $EventExtension on Event {
  Event copyWith({String? label, DateTime? eventDate}) {
    return Event(
        label: label ?? this.label, eventDate: eventDate ?? this.eventDate);
  }
}

@JsonSerializable(explicitToJson: true)
class FileDownloadRequestModel {
  FileDownloadRequestModel({
    this.userId,
    this.expiredTime,
    this.numberOfUsers,
    this.origin,
  });

  factory FileDownloadRequestModel.fromJson(Map<String, dynamic> json) =>
      _$FileDownloadRequestModelFromJson(json);

  @JsonKey(name: 'userId', includeIfNull: false)
  final String? userId;
  @JsonKey(name: 'expiredTime', includeIfNull: false)
  final DateTime? expiredTime;
  @JsonKey(name: 'numberOfUsers', includeIfNull: false)
  final int? numberOfUsers;
  @JsonKey(name: 'origin', includeIfNull: false)
  final bool? origin;
  static const fromJsonFactory = _$FileDownloadRequestModelFromJson;
  static const toJsonFactory = _$FileDownloadRequestModelToJson;
  Map<String, dynamic> toJson() => _$FileDownloadRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileDownloadRequestModel &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.expiredTime, expiredTime) ||
                const DeepCollectionEquality()
                    .equals(other.expiredTime, expiredTime)) &&
            (identical(other.numberOfUsers, numberOfUsers) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfUsers, numberOfUsers)) &&
            (identical(other.origin, origin) ||
                const DeepCollectionEquality().equals(other.origin, origin)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(expiredTime) ^
      const DeepCollectionEquality().hash(numberOfUsers) ^
      const DeepCollectionEquality().hash(origin) ^
      runtimeType.hashCode;
}

extension $FileDownloadRequestModelExtension on FileDownloadRequestModel {
  FileDownloadRequestModel copyWith(
      {String? userId,
      DateTime? expiredTime,
      int? numberOfUsers,
      bool? origin}) {
    return FileDownloadRequestModel(
        userId: userId ?? this.userId,
        expiredTime: expiredTime ?? this.expiredTime,
        numberOfUsers: numberOfUsers ?? this.numberOfUsers,
        origin: origin ?? this.origin);
  }
}

@JsonSerializable(explicitToJson: true)
class FileMetadata {
  FileMetadata({
    this.fileId,
    this.filePath,
    this.fileName,
    this.fileType,
    this.type,
    this.fileSize,
    this.absoluteUri,
    this.container,
  });

  factory FileMetadata.fromJson(Map<String, dynamic> json) =>
      _$FileMetadataFromJson(json);

  @JsonKey(name: 'fileId', includeIfNull: false)
  final String? fileId;
  @JsonKey(name: 'filePath', includeIfNull: false)
  final String? filePath;
  @JsonKey(name: 'fileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'fileType', includeIfNull: false)
  final String? fileType;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'fileSize', includeIfNull: false)
  final num? fileSize;
  @JsonKey(name: 'absoluteUri', includeIfNull: false)
  final String? absoluteUri;
  @JsonKey(name: 'container', includeIfNull: false)
  final String? container;
  static const fromJsonFactory = _$FileMetadataFromJson;
  static const toJsonFactory = _$FileMetadataToJson;
  Map<String, dynamic> toJson() => _$FileMetadataToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileMetadata &&
            (identical(other.fileId, fileId) ||
                const DeepCollectionEquality().equals(other.fileId, fileId)) &&
            (identical(other.filePath, filePath) ||
                const DeepCollectionEquality()
                    .equals(other.filePath, filePath)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.fileType, fileType) ||
                const DeepCollectionEquality()
                    .equals(other.fileType, fileType)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.fileSize, fileSize) ||
                const DeepCollectionEquality()
                    .equals(other.fileSize, fileSize)) &&
            (identical(other.absoluteUri, absoluteUri) ||
                const DeepCollectionEquality()
                    .equals(other.absoluteUri, absoluteUri)) &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fileId) ^
      const DeepCollectionEquality().hash(filePath) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(fileType) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(fileSize) ^
      const DeepCollectionEquality().hash(absoluteUri) ^
      const DeepCollectionEquality().hash(container) ^
      runtimeType.hashCode;
}

extension $FileMetadataExtension on FileMetadata {
  FileMetadata copyWith(
      {String? fileId,
      String? filePath,
      String? fileName,
      String? fileType,
      String? type,
      num? fileSize,
      String? absoluteUri,
      String? container}) {
    return FileMetadata(
        fileId: fileId ?? this.fileId,
        filePath: filePath ?? this.filePath,
        fileName: fileName ?? this.fileName,
        fileType: fileType ?? this.fileType,
        type: type ?? this.type,
        fileSize: fileSize ?? this.fileSize,
        absoluteUri: absoluteUri ?? this.absoluteUri,
        container: container ?? this.container);
  }
}

@JsonSerializable(explicitToJson: true)
class FileObjectsRelation {
  FileObjectsRelation({
    this.fileId,
    this.relatedObjectId,
  });

  factory FileObjectsRelation.fromJson(Map<String, dynamic> json) =>
      _$FileObjectsRelationFromJson(json);

  @JsonKey(name: 'fileId', includeIfNull: false)
  final String? fileId;
  @JsonKey(name: 'relatedObjectId', includeIfNull: false)
  final String? relatedObjectId;
  static const fromJsonFactory = _$FileObjectsRelationFromJson;
  static const toJsonFactory = _$FileObjectsRelationToJson;
  Map<String, dynamic> toJson() => _$FileObjectsRelationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileObjectsRelation &&
            (identical(other.fileId, fileId) ||
                const DeepCollectionEquality().equals(other.fileId, fileId)) &&
            (identical(other.relatedObjectId, relatedObjectId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObjectId, relatedObjectId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fileId) ^
      const DeepCollectionEquality().hash(relatedObjectId) ^
      runtimeType.hashCode;
}

extension $FileObjectsRelationExtension on FileObjectsRelation {
  FileObjectsRelation copyWith({String? fileId, String? relatedObjectId}) {
    return FileObjectsRelation(
        fileId: fileId ?? this.fileId,
        relatedObjectId: relatedObjectId ?? this.relatedObjectId);
  }
}

@JsonSerializable(explicitToJson: true)
class FileResponseModel {
  FileResponseModel({
    this.objectId,
    this.objectType,
    this.relatedObjectIdList,
    this.relatedBaseCategory,
    this.relatedFondId,
    this.relatedArchiveTypeId,
    this.relatedRecordCollectionId,
    this.relatedRecordId,
    this.relatedProjectId,
    this.relatedTaskId,
    this.relatedRespartnerId,
    this.relatedObject1,
    this.relatedObject1Type,
    this.relatedObject2,
    this.relatedObject2Type,
    this.id,
    required this.name,
    this.imageUrl,
    this.labelsObjs,
    this.description,
    this.nodeTypeObj,
    this.parentId,
    this.metaContentType,
    this.type,
    this.metadataContentObj,
    this.metadataObj,
    this.ownerId,
    this.isDeleted,
    this.isPublish,
    this.isSearchable,
    this.ancestors,
    this.descendents,
    this.aclObject,
    this.relatedFileId,
    this.relatedRoleCodeObjects,
    this.relatedRoleCode,
    this.hasChildren,
    this.statusObj,
    this.allowToView,
    this.allowToDelete,
    this.allowToMove,
    this.allowToSharing,
    this.allowToModify,
    this.allowToSetPermission,
    this.allowToSetRoleMapping,
    this.allowToChangeOwner,
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.completePath,
    this.completeName,
    this.fileUrl,
    this.metadata,
    this.metaContent,
  });

  factory FileResponseModel.fromJson(Map<String, dynamic> json) =>
      _$FileResponseModelFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(
      name: 'relatedObjectIdList',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? relatedObjectIdList;
  @JsonKey(name: 'relatedBaseCategory', includeIfNull: false)
  final String? relatedBaseCategory;
  @JsonKey(name: 'relatedFondId', includeIfNull: false)
  final String? relatedFondId;
  @JsonKey(name: 'relatedArchiveTypeId', includeIfNull: false)
  final String? relatedArchiveTypeId;
  @JsonKey(name: 'relatedRecordCollectionId', includeIfNull: false)
  final String? relatedRecordCollectionId;
  @JsonKey(name: 'relatedRecordId', includeIfNull: false)
  final String? relatedRecordId;
  @JsonKey(name: 'relatedProjectId', includeIfNull: false)
  final String? relatedProjectId;
  @JsonKey(name: 'relatedTaskId', includeIfNull: false)
  final String? relatedTaskId;
  @JsonKey(name: 'relatedRespartnerId', includeIfNull: false)
  final String? relatedRespartnerId;
  @JsonKey(name: 'relatedObject1', includeIfNull: false)
  final String? relatedObject1;
  @JsonKey(name: 'relatedObject1Type', includeIfNull: false)
  final String? relatedObject1Type;
  @JsonKey(name: 'relatedObject2', includeIfNull: false)
  final String? relatedObject2;
  @JsonKey(name: 'relatedObject2Type', includeIfNull: false)
  final String? relatedObject2Type;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(
      name: 'nodeTypeObj',
      includeIfNull: false,
      toJson: nodeTypeEnumToJson,
      fromJson: nodeTypeEnumFromJson)
  final enums.NodeTypeEnum? nodeTypeObj;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(
      name: 'metadataContentObj',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObj;
  @JsonKey(
      name: 'metadataObj',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataObj;
  @JsonKey(name: 'ownerId', includeIfNull: false)
  final String? ownerId;
  @JsonKey(name: 'isDeleted', includeIfNull: false)
  final bool? isDeleted;
  @JsonKey(name: 'isPublish', includeIfNull: false)
  final bool? isPublish;
  @JsonKey(name: 'isSearchable', includeIfNull: false)
  final bool? isSearchable;
  @JsonKey(
      name: 'ancestors',
      includeIfNull: false,
      defaultValue: <SimpleNodeBaseResponseModel>[])
  final List<SimpleNodeBaseResponseModel>? ancestors;
  @JsonKey(
      name: 'descendents',
      includeIfNull: false,
      defaultValue: <SimpleNodeBaseResponseModel>[])
  final List<SimpleNodeBaseResponseModel>? descendents;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'relatedFileId', includeIfNull: false)
  final String? relatedFileId;
  @JsonKey(
      name: 'relatedRoleCodeObjects',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? relatedRoleCodeObjects;
  @JsonKey(name: 'relatedRoleCode', includeIfNull: false)
  final String? relatedRoleCode;
  @JsonKey(name: 'hasChildren', includeIfNull: false)
  final bool? hasChildren;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: statusEnumToJson,
      fromJson: statusEnumFromJson)
  final enums.StatusEnum? statusObj;
  @JsonKey(name: 'allowToView', includeIfNull: false)
  final bool? allowToView;
  @JsonKey(name: 'allowToDelete', includeIfNull: false)
  final bool? allowToDelete;
  @JsonKey(name: 'allowToMove', includeIfNull: false)
  final bool? allowToMove;
  @JsonKey(name: 'allowToSharing', includeIfNull: false)
  final bool? allowToSharing;
  @JsonKey(name: 'allowToModify', includeIfNull: false)
  final bool? allowToModify;
  @JsonKey(name: 'allowToSetPermission', includeIfNull: false)
  final bool? allowToSetPermission;
  @JsonKey(name: 'allowToSetRoleMapping', includeIfNull: false)
  final bool? allowToSetRoleMapping;
  @JsonKey(name: 'allowToChangeOwner', includeIfNull: false)
  final bool? allowToChangeOwner;
  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'completePath', includeIfNull: false)
  final String? completePath;
  @JsonKey(name: 'completeName', includeIfNull: false)
  final String? completeName;
  @JsonKey(name: 'fileUrl', includeIfNull: false)
  final String? fileUrl;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final FileMetadata? metadata;
  @JsonKey(name: 'metaContent', includeIfNull: false)
  final String? metaContent;
  static const fromJsonFactory = _$FileResponseModelFromJson;
  static const toJsonFactory = _$FileResponseModelToJson;
  Map<String, dynamic> toJson() => _$FileResponseModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileResponseModel &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.relatedObjectIdList, relatedObjectIdList) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObjectIdList, relatedObjectIdList)) &&
            (identical(other.relatedBaseCategory, relatedBaseCategory) ||
                const DeepCollectionEquality()
                    .equals(other.relatedBaseCategory, relatedBaseCategory)) &&
            (identical(other.relatedFondId, relatedFondId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedFondId, relatedFondId)) &&
            (identical(other.relatedArchiveTypeId, relatedArchiveTypeId) ||
                const DeepCollectionEquality().equals(
                    other.relatedArchiveTypeId, relatedArchiveTypeId)) &&
            (identical(other.relatedRecordCollectionId, relatedRecordCollectionId) ||
                const DeepCollectionEquality().equals(
                    other.relatedRecordCollectionId,
                    relatedRecordCollectionId)) &&
            (identical(other.relatedRecordId, relatedRecordId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRecordId, relatedRecordId)) &&
            (identical(other.relatedProjectId, relatedProjectId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedProjectId, relatedProjectId)) &&
            (identical(other.relatedTaskId, relatedTaskId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedTaskId, relatedTaskId)) &&
            (identical(other.relatedRespartnerId, relatedRespartnerId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRespartnerId, relatedRespartnerId)) &&
            (identical(other.relatedObject1, relatedObject1) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject1, relatedObject1)) &&
            (identical(other.relatedObject1Type, relatedObject1Type) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject1Type, relatedObject1Type)) &&
            (identical(other.relatedObject2, relatedObject2) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject2, relatedObject2)) &&
            (identical(other.relatedObject2Type, relatedObject2Type) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject2Type, relatedObject2Type)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality().equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.nodeTypeObj, nodeTypeObj) || const DeepCollectionEquality().equals(other.nodeTypeObj, nodeTypeObj)) &&
            (identical(other.parentId, parentId) || const DeepCollectionEquality().equals(other.parentId, parentId)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.metadataContentObj, metadataContentObj) || const DeepCollectionEquality().equals(other.metadataContentObj, metadataContentObj)) &&
            (identical(other.metadataObj, metadataObj) || const DeepCollectionEquality().equals(other.metadataObj, metadataObj)) &&
            (identical(other.ownerId, ownerId) || const DeepCollectionEquality().equals(other.ownerId, ownerId)) &&
            (identical(other.isDeleted, isDeleted) || const DeepCollectionEquality().equals(other.isDeleted, isDeleted)) &&
            (identical(other.isPublish, isPublish) || const DeepCollectionEquality().equals(other.isPublish, isPublish)) &&
            (identical(other.isSearchable, isSearchable) || const DeepCollectionEquality().equals(other.isSearchable, isSearchable)) &&
            (identical(other.ancestors, ancestors) || const DeepCollectionEquality().equals(other.ancestors, ancestors)) &&
            (identical(other.descendents, descendents) || const DeepCollectionEquality().equals(other.descendents, descendents)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.relatedFileId, relatedFileId) || const DeepCollectionEquality().equals(other.relatedFileId, relatedFileId)) &&
            (identical(other.relatedRoleCodeObjects, relatedRoleCodeObjects) || const DeepCollectionEquality().equals(other.relatedRoleCodeObjects, relatedRoleCodeObjects)) &&
            (identical(other.relatedRoleCode, relatedRoleCode) || const DeepCollectionEquality().equals(other.relatedRoleCode, relatedRoleCode)) &&
            (identical(other.hasChildren, hasChildren) || const DeepCollectionEquality().equals(other.hasChildren, hasChildren)) &&
            (identical(other.statusObj, statusObj) || const DeepCollectionEquality().equals(other.statusObj, statusObj)) &&
            (identical(other.allowToView, allowToView) || const DeepCollectionEquality().equals(other.allowToView, allowToView)) &&
            (identical(other.allowToDelete, allowToDelete) || const DeepCollectionEquality().equals(other.allowToDelete, allowToDelete)) &&
            (identical(other.allowToMove, allowToMove) || const DeepCollectionEquality().equals(other.allowToMove, allowToMove)) &&
            (identical(other.allowToSharing, allowToSharing) || const DeepCollectionEquality().equals(other.allowToSharing, allowToSharing)) &&
            (identical(other.allowToModify, allowToModify) || const DeepCollectionEquality().equals(other.allowToModify, allowToModify)) &&
            (identical(other.allowToSetPermission, allowToSetPermission) || const DeepCollectionEquality().equals(other.allowToSetPermission, allowToSetPermission)) &&
            (identical(other.allowToSetRoleMapping, allowToSetRoleMapping) || const DeepCollectionEquality().equals(other.allowToSetRoleMapping, allowToSetRoleMapping)) &&
            (identical(other.allowToChangeOwner, allowToChangeOwner) || const DeepCollectionEquality().equals(other.allowToChangeOwner, allowToChangeOwner)) &&
            (identical(other.createdByUserId, createdByUserId) || const DeepCollectionEquality().equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) || const DeepCollectionEquality().equals(other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) || const DeepCollectionEquality().equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) || const DeepCollectionEquality().equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) || const DeepCollectionEquality().equals(other.applicationId, applicationId)) &&
            (identical(other.cLeft, cLeft) || const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) || const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) || const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.completePath, completePath) || const DeepCollectionEquality().equals(other.completePath, completePath)) &&
            (identical(other.completeName, completeName) || const DeepCollectionEquality().equals(other.completeName, completeName)) &&
            (identical(other.fileUrl, fileUrl) || const DeepCollectionEquality().equals(other.fileUrl, fileUrl)) &&
            (identical(other.metadata, metadata) || const DeepCollectionEquality().equals(other.metadata, metadata)) &&
            (identical(other.metaContent, metaContent) || const DeepCollectionEquality().equals(other.metaContent, metaContent)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(relatedObjectIdList) ^
      const DeepCollectionEquality().hash(relatedBaseCategory) ^
      const DeepCollectionEquality().hash(relatedFondId) ^
      const DeepCollectionEquality().hash(relatedArchiveTypeId) ^
      const DeepCollectionEquality().hash(relatedRecordCollectionId) ^
      const DeepCollectionEquality().hash(relatedRecordId) ^
      const DeepCollectionEquality().hash(relatedProjectId) ^
      const DeepCollectionEquality().hash(relatedTaskId) ^
      const DeepCollectionEquality().hash(relatedRespartnerId) ^
      const DeepCollectionEquality().hash(relatedObject1) ^
      const DeepCollectionEquality().hash(relatedObject1Type) ^
      const DeepCollectionEquality().hash(relatedObject2) ^
      const DeepCollectionEquality().hash(relatedObject2Type) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(nodeTypeObj) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(metadataContentObj) ^
      const DeepCollectionEquality().hash(metadataObj) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(isDeleted) ^
      const DeepCollectionEquality().hash(isPublish) ^
      const DeepCollectionEquality().hash(isSearchable) ^
      const DeepCollectionEquality().hash(ancestors) ^
      const DeepCollectionEquality().hash(descendents) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(relatedFileId) ^
      const DeepCollectionEquality().hash(relatedRoleCodeObjects) ^
      const DeepCollectionEquality().hash(relatedRoleCode) ^
      const DeepCollectionEquality().hash(hasChildren) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(allowToView) ^
      const DeepCollectionEquality().hash(allowToDelete) ^
      const DeepCollectionEquality().hash(allowToMove) ^
      const DeepCollectionEquality().hash(allowToSharing) ^
      const DeepCollectionEquality().hash(allowToModify) ^
      const DeepCollectionEquality().hash(allowToSetPermission) ^
      const DeepCollectionEquality().hash(allowToSetRoleMapping) ^
      const DeepCollectionEquality().hash(allowToChangeOwner) ^
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(completePath) ^
      const DeepCollectionEquality().hash(completeName) ^
      const DeepCollectionEquality().hash(fileUrl) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(metaContent) ^
      runtimeType.hashCode;
}

extension $FileResponseModelExtension on FileResponseModel {
  FileResponseModel copyWith(
      {String? objectId,
      String? objectType,
      List<String>? relatedObjectIdList,
      String? relatedBaseCategory,
      String? relatedFondId,
      String? relatedArchiveTypeId,
      String? relatedRecordCollectionId,
      String? relatedRecordId,
      String? relatedProjectId,
      String? relatedTaskId,
      String? relatedRespartnerId,
      String? relatedObject1,
      String? relatedObject1Type,
      String? relatedObject2,
      String? relatedObject2Type,
      String? id,
      String? name,
      String? imageUrl,
      List<LabelsObj>? labelsObjs,
      String? description,
      enums.NodeTypeEnum? nodeTypeObj,
      String? parentId,
      String? metaContentType,
      String? type,
      List<MetadataValue>? metadataContentObj,
      List<MetadataValue>? metadataObj,
      String? ownerId,
      bool? isDeleted,
      bool? isPublish,
      bool? isSearchable,
      List<SimpleNodeBaseResponseModel>? ancestors,
      List<SimpleNodeBaseResponseModel>? descendents,
      ACLObject? aclObject,
      String? relatedFileId,
      List<String>? relatedRoleCodeObjects,
      String? relatedRoleCode,
      bool? hasChildren,
      enums.StatusEnum? statusObj,
      bool? allowToView,
      bool? allowToDelete,
      bool? allowToMove,
      bool? allowToSharing,
      bool? allowToModify,
      bool? allowToSetPermission,
      bool? allowToSetRoleMapping,
      bool? allowToChangeOwner,
      String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      int? cLeft,
      int? cRight,
      int? cLevel,
      String? completePath,
      String? completeName,
      String? fileUrl,
      FileMetadata? metadata,
      String? metaContent}) {
    return FileResponseModel(
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        relatedObjectIdList: relatedObjectIdList ?? this.relatedObjectIdList,
        relatedBaseCategory: relatedBaseCategory ?? this.relatedBaseCategory,
        relatedFondId: relatedFondId ?? this.relatedFondId,
        relatedArchiveTypeId: relatedArchiveTypeId ?? this.relatedArchiveTypeId,
        relatedRecordCollectionId:
            relatedRecordCollectionId ?? this.relatedRecordCollectionId,
        relatedRecordId: relatedRecordId ?? this.relatedRecordId,
        relatedProjectId: relatedProjectId ?? this.relatedProjectId,
        relatedTaskId: relatedTaskId ?? this.relatedTaskId,
        relatedRespartnerId: relatedRespartnerId ?? this.relatedRespartnerId,
        relatedObject1: relatedObject1 ?? this.relatedObject1,
        relatedObject1Type: relatedObject1Type ?? this.relatedObject1Type,
        relatedObject2: relatedObject2 ?? this.relatedObject2,
        relatedObject2Type: relatedObject2Type ?? this.relatedObject2Type,
        id: id ?? this.id,
        name: name ?? this.name,
        imageUrl: imageUrl ?? this.imageUrl,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        description: description ?? this.description,
        nodeTypeObj: nodeTypeObj ?? this.nodeTypeObj,
        parentId: parentId ?? this.parentId,
        metaContentType: metaContentType ?? this.metaContentType,
        type: type ?? this.type,
        metadataContentObj: metadataContentObj ?? this.metadataContentObj,
        metadataObj: metadataObj ?? this.metadataObj,
        ownerId: ownerId ?? this.ownerId,
        isDeleted: isDeleted ?? this.isDeleted,
        isPublish: isPublish ?? this.isPublish,
        isSearchable: isSearchable ?? this.isSearchable,
        ancestors: ancestors ?? this.ancestors,
        descendents: descendents ?? this.descendents,
        aclObject: aclObject ?? this.aclObject,
        relatedFileId: relatedFileId ?? this.relatedFileId,
        relatedRoleCodeObjects:
            relatedRoleCodeObjects ?? this.relatedRoleCodeObjects,
        relatedRoleCode: relatedRoleCode ?? this.relatedRoleCode,
        hasChildren: hasChildren ?? this.hasChildren,
        statusObj: statusObj ?? this.statusObj,
        allowToView: allowToView ?? this.allowToView,
        allowToDelete: allowToDelete ?? this.allowToDelete,
        allowToMove: allowToMove ?? this.allowToMove,
        allowToSharing: allowToSharing ?? this.allowToSharing,
        allowToModify: allowToModify ?? this.allowToModify,
        allowToSetPermission: allowToSetPermission ?? this.allowToSetPermission,
        allowToSetRoleMapping:
            allowToSetRoleMapping ?? this.allowToSetRoleMapping,
        allowToChangeOwner: allowToChangeOwner ?? this.allowToChangeOwner,
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        completePath: completePath ?? this.completePath,
        completeName: completeName ?? this.completeName,
        fileUrl: fileUrl ?? this.fileUrl,
        metadata: metadata ?? this.metadata,
        metaContent: metaContent ?? this.metaContent);
  }
}

@JsonSerializable(explicitToJson: true)
class FileResponseModelPagination {
  FileResponseModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory FileResponseModelPagination.fromJson(Map<String, dynamic> json) =>
      _$FileResponseModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content',
      includeIfNull: false,
      defaultValue: <FileResponseModel>[])
  final List<FileResponseModel>? content;
  static const fromJsonFactory = _$FileResponseModelPaginationFromJson;
  static const toJsonFactory = _$FileResponseModelPaginationToJson;
  Map<String, dynamic> toJson() => _$FileResponseModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileResponseModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $FileResponseModelPaginationExtension on FileResponseModelPagination {
  FileResponseModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<FileResponseModel>? content}) {
    return FileResponseModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class FileResponseModelResponseList {
  FileResponseModelResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory FileResponseModelResponseList.fromJson(Map<String, dynamic> json) =>
      _$FileResponseModelResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(
      name: 'data', includeIfNull: false, defaultValue: <FileResponseModel>[])
  final List<FileResponseModel>? data;
  static const fromJsonFactory = _$FileResponseModelResponseListFromJson;
  static const toJsonFactory = _$FileResponseModelResponseListToJson;
  Map<String, dynamic> toJson() => _$FileResponseModelResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileResponseModelResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $FileResponseModelResponseListExtension
    on FileResponseModelResponseList {
  FileResponseModelResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<FileResponseModel>? data}) {
    return FileResponseModelResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class FileResponseModelResponseObject {
  FileResponseModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory FileResponseModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$FileResponseModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final FileResponseModel? data;
  static const fromJsonFactory = _$FileResponseModelResponseObjectFromJson;
  static const toJsonFactory = _$FileResponseModelResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$FileResponseModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileResponseModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $FileResponseModelResponseObjectExtension
    on FileResponseModelResponseObject {
  FileResponseModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      FileResponseModel? data}) {
    return FileResponseModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class FileResponseModelResponsePagination {
  FileResponseModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory FileResponseModelResponsePagination.fromJson(
          Map<String, dynamic> json) =>
      _$FileResponseModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final FileResponseModelPagination? data;
  static const fromJsonFactory = _$FileResponseModelResponsePaginationFromJson;
  static const toJsonFactory = _$FileResponseModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$FileResponseModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FileResponseModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $FileResponseModelResponsePaginationExtension
    on FileResponseModelResponsePagination {
  FileResponseModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      FileResponseModelPagination? data}) {
    return FileResponseModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class FilesDownloadRequestModel {
  FilesDownloadRequestModel({
    this.userId,
    this.username,
    this.expiredTime,
    this.fileIds,
    this.origin,
  });

  factory FilesDownloadRequestModel.fromJson(Map<String, dynamic> json) =>
      _$FilesDownloadRequestModelFromJson(json);

  @JsonKey(name: 'userId', includeIfNull: false)
  final String? userId;
  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'expiredTime', includeIfNull: false)
  final DateTime? expiredTime;
  @JsonKey(name: 'fileIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? fileIds;
  @JsonKey(name: 'origin', includeIfNull: false)
  final bool? origin;
  static const fromJsonFactory = _$FilesDownloadRequestModelFromJson;
  static const toJsonFactory = _$FilesDownloadRequestModelToJson;
  Map<String, dynamic> toJson() => _$FilesDownloadRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FilesDownloadRequestModel &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.expiredTime, expiredTime) ||
                const DeepCollectionEquality()
                    .equals(other.expiredTime, expiredTime)) &&
            (identical(other.fileIds, fileIds) ||
                const DeepCollectionEquality()
                    .equals(other.fileIds, fileIds)) &&
            (identical(other.origin, origin) ||
                const DeepCollectionEquality().equals(other.origin, origin)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(expiredTime) ^
      const DeepCollectionEquality().hash(fileIds) ^
      const DeepCollectionEquality().hash(origin) ^
      runtimeType.hashCode;
}

extension $FilesDownloadRequestModelExtension on FilesDownloadRequestModel {
  FilesDownloadRequestModel copyWith(
      {String? userId,
      String? username,
      DateTime? expiredTime,
      List<String>? fileIds,
      bool? origin}) {
    return FilesDownloadRequestModel(
        userId: userId ?? this.userId,
        username: username ?? this.username,
        expiredTime: expiredTime ?? this.expiredTime,
        fileIds: fileIds ?? this.fileIds,
        origin: origin ?? this.origin);
  }
}

@JsonSerializable(explicitToJson: true)
class Finance {
  Finance({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.timeOfFinance,
    this.state,
    this.totalCost,
    this.version,
    this.workflowState,
    this.workflowStatus,
  });

  factory Finance.fromJson(Map<String, dynamic> json) =>
      _$FinanceFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'timeOfFinance', includeIfNull: false)
  final DateTime? timeOfFinance;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'version', includeIfNull: false)
  final int? version;
  @JsonKey(name: 'workflowState', includeIfNull: false)
  final String? workflowState;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final String? workflowStatus;
  static const fromJsonFactory = _$FinanceFromJson;
  static const toJsonFactory = _$FinanceToJson;
  Map<String, dynamic> toJson() => _$FinanceToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Finance &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.timeOfFinance, timeOfFinance) ||
                const DeepCollectionEquality()
                    .equals(other.timeOfFinance, timeOfFinance)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.workflowState, workflowState) ||
                const DeepCollectionEquality()
                    .equals(other.workflowState, workflowState)) &&
            (identical(other.workflowStatus, workflowStatus) ||
                const DeepCollectionEquality()
                    .equals(other.workflowStatus, workflowStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(timeOfFinance) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(workflowState) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      runtimeType.hashCode;
}

extension $FinanceExtension on Finance {
  Finance copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      DateTime? timeOfFinance,
      String? state,
      double? totalCost,
      int? version,
      String? workflowState,
      String? workflowStatus}) {
    return Finance(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        timeOfFinance: timeOfFinance ?? this.timeOfFinance,
        state: state ?? this.state,
        totalCost: totalCost ?? this.totalCost,
        version: version ?? this.version,
        workflowState: workflowState ?? this.workflowState,
        workflowStatus: workflowStatus ?? this.workflowStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceByAttribute {
  FinanceByAttribute({
    this.locationId,
    this.locationName,
    this.attributeId,
    this.attributeName,
    this.year,
    this.totalCost,
    this.financeByAttributeDetails,
  });

  factory FinanceByAttribute.fromJson(Map<String, dynamic> json) =>
      _$FinanceByAttributeFromJson(json);

  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'attributeId', includeIfNull: false)
  final String? attributeId;
  @JsonKey(name: 'attributeName', includeIfNull: false)
  final String? attributeName;
  @JsonKey(name: 'year', includeIfNull: false)
  final int? year;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(
      name: 'financeByAttributeDetails',
      includeIfNull: false,
      defaultValue: <FinanceByAttributeDetail>[])
  final List<FinanceByAttributeDetail>? financeByAttributeDetails;
  static const fromJsonFactory = _$FinanceByAttributeFromJson;
  static const toJsonFactory = _$FinanceByAttributeToJson;
  Map<String, dynamic> toJson() => _$FinanceByAttributeToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceByAttribute &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.attributeId, attributeId) ||
                const DeepCollectionEquality()
                    .equals(other.attributeId, attributeId)) &&
            (identical(other.attributeName, attributeName) ||
                const DeepCollectionEquality()
                    .equals(other.attributeName, attributeName)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.financeByAttributeDetails,
                    financeByAttributeDetails) ||
                const DeepCollectionEquality().equals(
                    other.financeByAttributeDetails,
                    financeByAttributeDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(attributeId) ^
      const DeepCollectionEquality().hash(attributeName) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(financeByAttributeDetails) ^
      runtimeType.hashCode;
}

extension $FinanceByAttributeExtension on FinanceByAttribute {
  FinanceByAttribute copyWith(
      {String? locationId,
      String? locationName,
      String? attributeId,
      String? attributeName,
      int? year,
      double? totalCost,
      List<FinanceByAttributeDetail>? financeByAttributeDetails}) {
    return FinanceByAttribute(
        locationId: locationId ?? this.locationId,
        locationName: locationName ?? this.locationName,
        attributeId: attributeId ?? this.attributeId,
        attributeName: attributeName ?? this.attributeName,
        year: year ?? this.year,
        totalCost: totalCost ?? this.totalCost,
        financeByAttributeDetails:
            financeByAttributeDetails ?? this.financeByAttributeDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceByAttributeDetail {
  FinanceByAttributeDetail({
    this.objectId,
    this.objectName,
    this.objectUnitId,
    this.objectUnitName,
    this.total,
    this.totalCost,
    this.unitPrice,
    this.financeByDetails,
  });

  factory FinanceByAttributeDetail.fromJson(Map<String, dynamic> json) =>
      _$FinanceByAttributeDetailFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectUnitId', includeIfNull: false)
  final String? objectUnitId;
  @JsonKey(name: 'objectUnitName', includeIfNull: false)
  final String? objectUnitName;
  @JsonKey(name: 'total', includeIfNull: false)
  final double? total;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'unitPrice', includeIfNull: false)
  final double? unitPrice;
  @JsonKey(
      name: 'financeByDetails',
      includeIfNull: false,
      defaultValue: <FinanceInCell>[])
  final List<FinanceInCell>? financeByDetails;
  static const fromJsonFactory = _$FinanceByAttributeDetailFromJson;
  static const toJsonFactory = _$FinanceByAttributeDetailToJson;
  Map<String, dynamic> toJson() => _$FinanceByAttributeDetailToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceByAttributeDetail &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectUnitId, objectUnitId) ||
                const DeepCollectionEquality()
                    .equals(other.objectUnitId, objectUnitId)) &&
            (identical(other.objectUnitName, objectUnitName) ||
                const DeepCollectionEquality()
                    .equals(other.objectUnitName, objectUnitName)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.unitPrice, unitPrice) ||
                const DeepCollectionEquality()
                    .equals(other.unitPrice, unitPrice)) &&
            (identical(other.financeByDetails, financeByDetails) ||
                const DeepCollectionEquality()
                    .equals(other.financeByDetails, financeByDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectUnitId) ^
      const DeepCollectionEquality().hash(objectUnitName) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(unitPrice) ^
      const DeepCollectionEquality().hash(financeByDetails) ^
      runtimeType.hashCode;
}

extension $FinanceByAttributeDetailExtension on FinanceByAttributeDetail {
  FinanceByAttributeDetail copyWith(
      {String? objectId,
      String? objectName,
      String? objectUnitId,
      String? objectUnitName,
      double? total,
      double? totalCost,
      double? unitPrice,
      List<FinanceInCell>? financeByDetails}) {
    return FinanceByAttributeDetail(
        objectId: objectId ?? this.objectId,
        objectName: objectName ?? this.objectName,
        objectUnitId: objectUnitId ?? this.objectUnitId,
        objectUnitName: objectUnitName ?? this.objectUnitName,
        total: total ?? this.total,
        totalCost: totalCost ?? this.totalCost,
        unitPrice: unitPrice ?? this.unitPrice,
        financeByDetails: financeByDetails ?? this.financeByDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceByAttributeResponseObject {
  FinanceByAttributeResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory FinanceByAttributeResponseObject.fromJson(
          Map<String, dynamic> json) =>
      _$FinanceByAttributeResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final FinanceByAttribute? data;
  static const fromJsonFactory = _$FinanceByAttributeResponseObjectFromJson;
  static const toJsonFactory = _$FinanceByAttributeResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$FinanceByAttributeResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceByAttributeResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $FinanceByAttributeResponseObjectExtension
    on FinanceByAttributeResponseObject {
  FinanceByAttributeResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      FinanceByAttribute? data}) {
    return FinanceByAttributeResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceByLocation {
  FinanceByLocation({
    this.locationId,
    this.locationName,
    this.year,
    this.totalCost,
    this.totalCostLastTerm,
    this.difference,
    this.financeDetails,
  });

  factory FinanceByLocation.fromJson(Map<String, dynamic> json) =>
      _$FinanceByLocationFromJson(json);

  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'year', includeIfNull: false)
  final int? year;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'totalCostLastTerm', includeIfNull: false)
  final double? totalCostLastTerm;
  @JsonKey(name: 'difference', includeIfNull: false)
  final double? difference;
  @JsonKey(
      name: 'financeDetails',
      includeIfNull: false,
      defaultValue: <DetailFinanceByRef>[])
  final List<DetailFinanceByRef>? financeDetails;
  static const fromJsonFactory = _$FinanceByLocationFromJson;
  static const toJsonFactory = _$FinanceByLocationToJson;
  Map<String, dynamic> toJson() => _$FinanceByLocationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceByLocation &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.totalCostLastTerm, totalCostLastTerm) ||
                const DeepCollectionEquality()
                    .equals(other.totalCostLastTerm, totalCostLastTerm)) &&
            (identical(other.difference, difference) ||
                const DeepCollectionEquality()
                    .equals(other.difference, difference)) &&
            (identical(other.financeDetails, financeDetails) ||
                const DeepCollectionEquality()
                    .equals(other.financeDetails, financeDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(totalCostLastTerm) ^
      const DeepCollectionEquality().hash(difference) ^
      const DeepCollectionEquality().hash(financeDetails) ^
      runtimeType.hashCode;
}

extension $FinanceByLocationExtension on FinanceByLocation {
  FinanceByLocation copyWith(
      {String? locationId,
      String? locationName,
      int? year,
      double? totalCost,
      double? totalCostLastTerm,
      double? difference,
      List<DetailFinanceByRef>? financeDetails}) {
    return FinanceByLocation(
        locationId: locationId ?? this.locationId,
        locationName: locationName ?? this.locationName,
        year: year ?? this.year,
        totalCost: totalCost ?? this.totalCost,
        totalCostLastTerm: totalCostLastTerm ?? this.totalCostLastTerm,
        difference: difference ?? this.difference,
        financeDetails: financeDetails ?? this.financeDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceByLocationResponseObject {
  FinanceByLocationResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory FinanceByLocationResponseObject.fromJson(Map<String, dynamic> json) =>
      _$FinanceByLocationResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final FinanceByLocation? data;
  static const fromJsonFactory = _$FinanceByLocationResponseObjectFromJson;
  static const toJsonFactory = _$FinanceByLocationResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$FinanceByLocationResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceByLocationResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $FinanceByLocationResponseObjectExtension
    on FinanceByLocationResponseObject {
  FinanceByLocationResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      FinanceByLocation? data}) {
    return FinanceByLocationResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceInCell {
  FinanceInCell({
    this.attributeValueId,
    this.attributeValueName,
    this.workCenterId,
    this.workCenterName,
    this.totalBomQty,
  });

  factory FinanceInCell.fromJson(Map<String, dynamic> json) =>
      _$FinanceInCellFromJson(json);

  @JsonKey(name: 'attributeValueId', includeIfNull: false)
  final String? attributeValueId;
  @JsonKey(name: 'attributeValueName', includeIfNull: false)
  final String? attributeValueName;
  @JsonKey(name: 'workCenterId', includeIfNull: false)
  final String? workCenterId;
  @JsonKey(name: 'workCenterName', includeIfNull: false)
  final String? workCenterName;
  @JsonKey(name: 'totalBomQty', includeIfNull: false)
  final double? totalBomQty;
  static const fromJsonFactory = _$FinanceInCellFromJson;
  static const toJsonFactory = _$FinanceInCellToJson;
  Map<String, dynamic> toJson() => _$FinanceInCellToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceInCell &&
            (identical(other.attributeValueId, attributeValueId) ||
                const DeepCollectionEquality()
                    .equals(other.attributeValueId, attributeValueId)) &&
            (identical(other.attributeValueName, attributeValueName) ||
                const DeepCollectionEquality()
                    .equals(other.attributeValueName, attributeValueName)) &&
            (identical(other.workCenterId, workCenterId) ||
                const DeepCollectionEquality()
                    .equals(other.workCenterId, workCenterId)) &&
            (identical(other.workCenterName, workCenterName) ||
                const DeepCollectionEquality()
                    .equals(other.workCenterName, workCenterName)) &&
            (identical(other.totalBomQty, totalBomQty) ||
                const DeepCollectionEquality()
                    .equals(other.totalBomQty, totalBomQty)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(attributeValueId) ^
      const DeepCollectionEquality().hash(attributeValueName) ^
      const DeepCollectionEquality().hash(workCenterId) ^
      const DeepCollectionEquality().hash(workCenterName) ^
      const DeepCollectionEquality().hash(totalBomQty) ^
      runtimeType.hashCode;
}

extension $FinanceInCellExtension on FinanceInCell {
  FinanceInCell copyWith(
      {String? attributeValueId,
      String? attributeValueName,
      String? workCenterId,
      String? workCenterName,
      double? totalBomQty}) {
    return FinanceInCell(
        attributeValueId: attributeValueId ?? this.attributeValueId,
        attributeValueName: attributeValueName ?? this.attributeValueName,
        workCenterId: workCenterId ?? this.workCenterId,
        workCenterName: workCenterName ?? this.workCenterName,
        totalBomQty: totalBomQty ?? this.totalBomQty);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceInYearDetail {
  FinanceInYearDetail({
    this.locationName,
    this.locationId,
    this.caringQualify,
    this.order,
    this.totalCost,
    this.totalCostLastTerm,
    this.difference,
    this.detailsMonth,
    this.detailObjectGroups,
  });

  factory FinanceInYearDetail.fromJson(Map<String, dynamic> json) =>
      _$FinanceInYearDetailFromJson(json);

  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'caringQualify', includeIfNull: false)
  final String? caringQualify;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'totalCostLastTerm', includeIfNull: false)
  final double? totalCostLastTerm;
  @JsonKey(name: 'difference', includeIfNull: false)
  final double? difference;
  @JsonKey(
      name: 'detailsMonth', includeIfNull: false, defaultValue: <DetailMonth>[])
  final List<DetailMonth>? detailsMonth;
  @JsonKey(
      name: 'detailObjectGroups',
      includeIfNull: false,
      defaultValue: <DetailObjectGroup>[])
  final List<DetailObjectGroup>? detailObjectGroups;
  static const fromJsonFactory = _$FinanceInYearDetailFromJson;
  static const toJsonFactory = _$FinanceInYearDetailToJson;
  Map<String, dynamic> toJson() => _$FinanceInYearDetailToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceInYearDetail &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.caringQualify, caringQualify) ||
                const DeepCollectionEquality()
                    .equals(other.caringQualify, caringQualify)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.totalCostLastTerm, totalCostLastTerm) ||
                const DeepCollectionEquality()
                    .equals(other.totalCostLastTerm, totalCostLastTerm)) &&
            (identical(other.difference, difference) ||
                const DeepCollectionEquality()
                    .equals(other.difference, difference)) &&
            (identical(other.detailsMonth, detailsMonth) ||
                const DeepCollectionEquality()
                    .equals(other.detailsMonth, detailsMonth)) &&
            (identical(other.detailObjectGroups, detailObjectGroups) ||
                const DeepCollectionEquality()
                    .equals(other.detailObjectGroups, detailObjectGroups)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(caringQualify) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(totalCostLastTerm) ^
      const DeepCollectionEquality().hash(difference) ^
      const DeepCollectionEquality().hash(detailsMonth) ^
      const DeepCollectionEquality().hash(detailObjectGroups) ^
      runtimeType.hashCode;
}

extension $FinanceInYearDetailExtension on FinanceInYearDetail {
  FinanceInYearDetail copyWith(
      {String? locationName,
      String? locationId,
      String? caringQualify,
      int? order,
      double? totalCost,
      double? totalCostLastTerm,
      double? difference,
      List<DetailMonth>? detailsMonth,
      List<DetailObjectGroup>? detailObjectGroups}) {
    return FinanceInYearDetail(
        locationName: locationName ?? this.locationName,
        locationId: locationId ?? this.locationId,
        caringQualify: caringQualify ?? this.caringQualify,
        order: order ?? this.order,
        totalCost: totalCost ?? this.totalCost,
        totalCostLastTerm: totalCostLastTerm ?? this.totalCostLastTerm,
        difference: difference ?? this.difference,
        detailsMonth: detailsMonth ?? this.detailsMonth,
        detailObjectGroups: detailObjectGroups ?? this.detailObjectGroups);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceInYearModel {
  FinanceInYearModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.timeOfFinance,
    this.state,
    this.totalCost,
    this.totalCostLastTerm,
    this.difference,
    this.version,
    this.workflowState,
    this.workflowStatus,
    this.financeDetails,
    this.detailsMonth,
    this.financeLaborProtection,
  });

  factory FinanceInYearModel.fromJson(Map<String, dynamic> json) =>
      _$FinanceInYearModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'timeOfFinance', includeIfNull: false)
  final DateTime? timeOfFinance;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'totalCostLastTerm', includeIfNull: false)
  final double? totalCostLastTerm;
  @JsonKey(name: 'difference', includeIfNull: false)
  final double? difference;
  @JsonKey(name: 'version', includeIfNull: false)
  final int? version;
  @JsonKey(name: 'workflowState', includeIfNull: false)
  final String? workflowState;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final String? workflowStatus;
  @JsonKey(
      name: 'financeDetails',
      includeIfNull: false,
      defaultValue: <FinanceInYearDetail>[])
  final List<FinanceInYearDetail>? financeDetails;
  @JsonKey(
      name: 'detailsMonth', includeIfNull: false, defaultValue: <DetailMonth>[])
  final List<DetailMonth>? detailsMonth;
  @JsonKey(name: 'financeLaborProtection', includeIfNull: false)
  final FinanceLaborProtection? financeLaborProtection;
  static const fromJsonFactory = _$FinanceInYearModelFromJson;
  static const toJsonFactory = _$FinanceInYearModelToJson;
  Map<String, dynamic> toJson() => _$FinanceInYearModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceInYearModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.timeOfFinance, timeOfFinance) ||
                const DeepCollectionEquality()
                    .equals(other.timeOfFinance, timeOfFinance)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.totalCostLastTerm, totalCostLastTerm) ||
                const DeepCollectionEquality()
                    .equals(other.totalCostLastTerm, totalCostLastTerm)) &&
            (identical(other.difference, difference) ||
                const DeepCollectionEquality()
                    .equals(other.difference, difference)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.workflowState, workflowState) ||
                const DeepCollectionEquality()
                    .equals(other.workflowState, workflowState)) &&
            (identical(other.workflowStatus, workflowStatus) ||
                const DeepCollectionEquality()
                    .equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.financeDetails, financeDetails) ||
                const DeepCollectionEquality()
                    .equals(other.financeDetails, financeDetails)) &&
            (identical(other.detailsMonth, detailsMonth) ||
                const DeepCollectionEquality()
                    .equals(other.detailsMonth, detailsMonth)) &&
            (identical(other.financeLaborProtection, financeLaborProtection) ||
                const DeepCollectionEquality().equals(
                    other.financeLaborProtection, financeLaborProtection)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(timeOfFinance) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(totalCostLastTerm) ^
      const DeepCollectionEquality().hash(difference) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(workflowState) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(financeDetails) ^
      const DeepCollectionEquality().hash(detailsMonth) ^
      const DeepCollectionEquality().hash(financeLaborProtection) ^
      runtimeType.hashCode;
}

extension $FinanceInYearModelExtension on FinanceInYearModel {
  FinanceInYearModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      DateTime? timeOfFinance,
      String? state,
      double? totalCost,
      double? totalCostLastTerm,
      double? difference,
      int? version,
      String? workflowState,
      String? workflowStatus,
      List<FinanceInYearDetail>? financeDetails,
      List<DetailMonth>? detailsMonth,
      FinanceLaborProtection? financeLaborProtection}) {
    return FinanceInYearModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        timeOfFinance: timeOfFinance ?? this.timeOfFinance,
        state: state ?? this.state,
        totalCost: totalCost ?? this.totalCost,
        totalCostLastTerm: totalCostLastTerm ?? this.totalCostLastTerm,
        difference: difference ?? this.difference,
        version: version ?? this.version,
        workflowState: workflowState ?? this.workflowState,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        financeDetails: financeDetails ?? this.financeDetails,
        detailsMonth: detailsMonth ?? this.detailsMonth,
        financeLaborProtection:
            financeLaborProtection ?? this.financeLaborProtection);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceInYearModelResponseObject {
  FinanceInYearModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory FinanceInYearModelResponseObject.fromJson(
          Map<String, dynamic> json) =>
      _$FinanceInYearModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final FinanceInYearModel? data;
  static const fromJsonFactory = _$FinanceInYearModelResponseObjectFromJson;
  static const toJsonFactory = _$FinanceInYearModelResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$FinanceInYearModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceInYearModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $FinanceInYearModelResponseObjectExtension
    on FinanceInYearModelResponseObject {
  FinanceInYearModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      FinanceInYearModel? data}) {
    return FinanceInYearModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceLaborProtection {
  FinanceLaborProtection({
    this.name,
    this.totalCost,
    this.totalCostLastTerm,
    this.difference,
    this.financeLaborProtectionDetails,
    this.detailsMonth,
  });

  factory FinanceLaborProtection.fromJson(Map<String, dynamic> json) =>
      _$FinanceLaborProtectionFromJson(json);

  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'totalCostLastTerm', includeIfNull: false)
  final double? totalCostLastTerm;
  @JsonKey(name: 'difference', includeIfNull: false)
  final double? difference;
  @JsonKey(
      name: 'financeLaborProtectionDetails',
      includeIfNull: false,
      defaultValue: <FinanceLaborProtectionDetail>[])
  final List<FinanceLaborProtectionDetail>? financeLaborProtectionDetails;
  @JsonKey(
      name: 'detailsMonth', includeIfNull: false, defaultValue: <DetailMonth>[])
  final List<DetailMonth>? detailsMonth;
  static const fromJsonFactory = _$FinanceLaborProtectionFromJson;
  static const toJsonFactory = _$FinanceLaborProtectionToJson;
  Map<String, dynamic> toJson() => _$FinanceLaborProtectionToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceLaborProtection &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.totalCostLastTerm, totalCostLastTerm) ||
                const DeepCollectionEquality()
                    .equals(other.totalCostLastTerm, totalCostLastTerm)) &&
            (identical(other.difference, difference) ||
                const DeepCollectionEquality()
                    .equals(other.difference, difference)) &&
            (identical(other.financeLaborProtectionDetails,
                    financeLaborProtectionDetails) ||
                const DeepCollectionEquality().equals(
                    other.financeLaborProtectionDetails,
                    financeLaborProtectionDetails)) &&
            (identical(other.detailsMonth, detailsMonth) ||
                const DeepCollectionEquality()
                    .equals(other.detailsMonth, detailsMonth)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(totalCostLastTerm) ^
      const DeepCollectionEquality().hash(difference) ^
      const DeepCollectionEquality().hash(financeLaborProtectionDetails) ^
      const DeepCollectionEquality().hash(detailsMonth) ^
      runtimeType.hashCode;
}

extension $FinanceLaborProtectionExtension on FinanceLaborProtection {
  FinanceLaborProtection copyWith(
      {String? name,
      double? totalCost,
      double? totalCostLastTerm,
      double? difference,
      List<FinanceLaborProtectionDetail>? financeLaborProtectionDetails,
      List<DetailMonth>? detailsMonth}) {
    return FinanceLaborProtection(
        name: name ?? this.name,
        totalCost: totalCost ?? this.totalCost,
        totalCostLastTerm: totalCostLastTerm ?? this.totalCostLastTerm,
        difference: difference ?? this.difference,
        financeLaborProtectionDetails:
            financeLaborProtectionDetails ?? this.financeLaborProtectionDetails,
        detailsMonth: detailsMonth ?? this.detailsMonth);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceLaborProtectionDetail {
  FinanceLaborProtectionDetail({
    this.locationName,
    this.locationId,
    this.totalCost,
    this.totalCostLastTerm,
    this.difference,
    this.detailsMonth,
  });

  factory FinanceLaborProtectionDetail.fromJson(Map<String, dynamic> json) =>
      _$FinanceLaborProtectionDetailFromJson(json);

  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'totalCost', includeIfNull: false)
  final double? totalCost;
  @JsonKey(name: 'totalCostLastTerm', includeIfNull: false)
  final double? totalCostLastTerm;
  @JsonKey(name: 'difference', includeIfNull: false)
  final double? difference;
  @JsonKey(
      name: 'detailsMonth', includeIfNull: false, defaultValue: <DetailMonth>[])
  final List<DetailMonth>? detailsMonth;
  static const fromJsonFactory = _$FinanceLaborProtectionDetailFromJson;
  static const toJsonFactory = _$FinanceLaborProtectionDetailToJson;
  Map<String, dynamic> toJson() => _$FinanceLaborProtectionDetailToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceLaborProtectionDetail &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.totalCost, totalCost) ||
                const DeepCollectionEquality()
                    .equals(other.totalCost, totalCost)) &&
            (identical(other.totalCostLastTerm, totalCostLastTerm) ||
                const DeepCollectionEquality()
                    .equals(other.totalCostLastTerm, totalCostLastTerm)) &&
            (identical(other.difference, difference) ||
                const DeepCollectionEquality()
                    .equals(other.difference, difference)) &&
            (identical(other.detailsMonth, detailsMonth) ||
                const DeepCollectionEquality()
                    .equals(other.detailsMonth, detailsMonth)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(totalCost) ^
      const DeepCollectionEquality().hash(totalCostLastTerm) ^
      const DeepCollectionEquality().hash(difference) ^
      const DeepCollectionEquality().hash(detailsMonth) ^
      runtimeType.hashCode;
}

extension $FinanceLaborProtectionDetailExtension
    on FinanceLaborProtectionDetail {
  FinanceLaborProtectionDetail copyWith(
      {String? locationName,
      String? locationId,
      double? totalCost,
      double? totalCostLastTerm,
      double? difference,
      List<DetailMonth>? detailsMonth}) {
    return FinanceLaborProtectionDetail(
        locationName: locationName ?? this.locationName,
        locationId: locationId ?? this.locationId,
        totalCost: totalCost ?? this.totalCost,
        totalCostLastTerm: totalCostLastTerm ?? this.totalCostLastTerm,
        difference: difference ?? this.difference,
        detailsMonth: detailsMonth ?? this.detailsMonth);
  }
}

@JsonSerializable(explicitToJson: true)
class FinanceResponseObject {
  FinanceResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory FinanceResponseObject.fromJson(Map<String, dynamic> json) =>
      _$FinanceResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final Finance? data;
  static const fromJsonFactory = _$FinanceResponseObjectFromJson;
  static const toJsonFactory = _$FinanceResponseObjectToJson;
  Map<String, dynamic> toJson() => _$FinanceResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FinanceResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $FinanceResponseObjectExtension on FinanceResponseObject {
  FinanceResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, Finance? data}) {
    return FinanceResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class GuidListResponseObject {
  GuidListResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory GuidListResponseObject.fromJson(Map<String, dynamic> json) =>
      _$GuidListResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <String>[])
  final List<String>? data;
  static const fromJsonFactory = _$GuidListResponseObjectFromJson;
  static const toJsonFactory = _$GuidListResponseObjectToJson;
  Map<String, dynamic> toJson() => _$GuidListResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GuidListResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $GuidListResponseObjectExtension on GuidListResponseObject {
  GuidListResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, List<String>? data}) {
    return GuidListResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ImportTaskRequestModel {
  ImportTaskRequestModel({
    this.templateId,
    required this.templateCode,
  });

  factory ImportTaskRequestModel.fromJson(Map<String, dynamic> json) =>
      _$ImportTaskRequestModelFromJson(json);

  @JsonKey(name: 'templateId', includeIfNull: false)
  final String? templateId;
  @JsonKey(name: 'templateCode', includeIfNull: false)
  final String templateCode;
  static const fromJsonFactory = _$ImportTaskRequestModelFromJson;
  static const toJsonFactory = _$ImportTaskRequestModelToJson;
  Map<String, dynamic> toJson() => _$ImportTaskRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ImportTaskRequestModel &&
            (identical(other.templateId, templateId) ||
                const DeepCollectionEquality()
                    .equals(other.templateId, templateId)) &&
            (identical(other.templateCode, templateCode) ||
                const DeepCollectionEquality()
                    .equals(other.templateCode, templateCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(templateId) ^
      const DeepCollectionEquality().hash(templateCode) ^
      runtimeType.hashCode;
}

extension $ImportTaskRequestModelExtension on ImportTaskRequestModel {
  ImportTaskRequestModel copyWith({String? templateId, String? templateCode}) {
    return ImportTaskRequestModel(
        templateId: templateId ?? this.templateId,
        templateCode: templateCode ?? this.templateCode);
  }
}

@JsonSerializable(explicitToJson: true)
class Int64ResponseObject {
  Int64ResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory Int64ResponseObject.fromJson(Map<String, dynamic> json) =>
      _$Int64ResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final num? data;
  static const fromJsonFactory = _$Int64ResponseObjectFromJson;
  static const toJsonFactory = _$Int64ResponseObjectToJson;
  Map<String, dynamic> toJson() => _$Int64ResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Int64ResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $Int64ResponseObjectExtension on Int64ResponseObject {
  Int64ResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, num? data}) {
    return Int64ResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class LabelsObj {
  LabelsObj({
    this.objectId,
    this.objectCode,
    this.objectName,
    this.color,
  });

  factory LabelsObj.fromJson(Map<String, dynamic> json) =>
      _$LabelsObjFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectCode', includeIfNull: false)
  final String? objectCode;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'color', includeIfNull: false)
  final String? color;
  static const fromJsonFactory = _$LabelsObjFromJson;
  static const toJsonFactory = _$LabelsObjToJson;
  Map<String, dynamic> toJson() => _$LabelsObjToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LabelsObj &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectCode, objectCode) ||
                const DeepCollectionEquality()
                    .equals(other.objectCode, objectCode)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.color, color) ||
                const DeepCollectionEquality().equals(other.color, color)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectCode) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(color) ^
      runtimeType.hashCode;
}

extension $LabelsObjExtension on LabelsObj {
  LabelsObj copyWith(
      {String? objectId,
      String? objectCode,
      String? objectName,
      String? color}) {
    return LabelsObj(
        objectId: objectId ?? this.objectId,
        objectCode: objectCode ?? this.objectCode,
        objectName: objectName ?? this.objectName,
        color: color ?? this.color);
  }
}

@JsonSerializable(explicitToJson: true)
class LaborProtectionAllocation {
  LaborProtectionAllocation({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.productionMasterId,
    this.maintenanceGroupId,
    this.maintenanceGroupName,
    this.leaderId,
    this.leaderName,
    this.memberQtyDelivery,
    this.maintenanceGroupMember,
    this.workType,
    this.workTypeName,
    this.state,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
  });

  factory LaborProtectionAllocation.fromJson(Map<String, dynamic> json) =>
      _$LaborProtectionAllocationFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'productionMasterId', includeIfNull: false)
  final String? productionMasterId;
  @JsonKey(name: 'maintenanceGroupId', includeIfNull: false)
  final String? maintenanceGroupId;
  @JsonKey(name: 'maintenanceGroupName', includeIfNull: false)
  final String? maintenanceGroupName;
  @JsonKey(name: 'leaderId', includeIfNull: false)
  final String? leaderId;
  @JsonKey(name: 'leaderName', includeIfNull: false)
  final String? leaderName;
  @JsonKey(name: 'memberQtyDelivery', includeIfNull: false)
  final int? memberQtyDelivery;
  @JsonKey(name: 'maintenanceGroupMember', includeIfNull: false)
  final int? maintenanceGroupMember;
  @JsonKey(name: 'workType', includeIfNull: false)
  final String? workType;
  @JsonKey(name: 'workTypeName', includeIfNull: false)
  final String? workTypeName;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  static const fromJsonFactory = _$LaborProtectionAllocationFromJson;
  static const toJsonFactory = _$LaborProtectionAllocationToJson;
  Map<String, dynamic> toJson() => _$LaborProtectionAllocationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LaborProtectionAllocation &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.productionMasterId, productionMasterId) ||
                const DeepCollectionEquality()
                    .equals(other.productionMasterId, productionMasterId)) &&
            (identical(other.maintenanceGroupId, maintenanceGroupId) ||
                const DeepCollectionEquality()
                    .equals(other.maintenanceGroupId, maintenanceGroupId)) &&
            (identical(other.maintenanceGroupName, maintenanceGroupName) ||
                const DeepCollectionEquality().equals(
                    other.maintenanceGroupName, maintenanceGroupName)) &&
            (identical(other.leaderId, leaderId) ||
                const DeepCollectionEquality()
                    .equals(other.leaderId, leaderId)) &&
            (identical(other.leaderName, leaderName) ||
                const DeepCollectionEquality()
                    .equals(other.leaderName, leaderName)) &&
            (identical(other.memberQtyDelivery, memberQtyDelivery) ||
                const DeepCollectionEquality()
                    .equals(other.memberQtyDelivery, memberQtyDelivery)) &&
            (identical(other.maintenanceGroupMember, maintenanceGroupMember) ||
                const DeepCollectionEquality().equals(
                    other.maintenanceGroupMember, maintenanceGroupMember)) &&
            (identical(other.workType, workType) ||
                const DeepCollectionEquality()
                    .equals(other.workType, workType)) &&
            (identical(other.workTypeName, workTypeName) ||
                const DeepCollectionEquality()
                    .equals(other.workTypeName, workTypeName)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(productionMasterId) ^
      const DeepCollectionEquality().hash(maintenanceGroupId) ^
      const DeepCollectionEquality().hash(maintenanceGroupName) ^
      const DeepCollectionEquality().hash(leaderId) ^
      const DeepCollectionEquality().hash(leaderName) ^
      const DeepCollectionEquality().hash(memberQtyDelivery) ^
      const DeepCollectionEquality().hash(maintenanceGroupMember) ^
      const DeepCollectionEquality().hash(workType) ^
      const DeepCollectionEquality().hash(workTypeName) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      runtimeType.hashCode;
}

extension $LaborProtectionAllocationExtension on LaborProtectionAllocation {
  LaborProtectionAllocation copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? productionMasterId,
      String? maintenanceGroupId,
      String? maintenanceGroupName,
      String? leaderId,
      String? leaderName,
      int? memberQtyDelivery,
      int? maintenanceGroupMember,
      String? workType,
      String? workTypeName,
      String? state,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType}) {
    return LaborProtectionAllocation(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        productionMasterId: productionMasterId ?? this.productionMasterId,
        maintenanceGroupId: maintenanceGroupId ?? this.maintenanceGroupId,
        maintenanceGroupName: maintenanceGroupName ?? this.maintenanceGroupName,
        leaderId: leaderId ?? this.leaderId,
        leaderName: leaderName ?? this.leaderName,
        memberQtyDelivery: memberQtyDelivery ?? this.memberQtyDelivery,
        maintenanceGroupMember:
            maintenanceGroupMember ?? this.maintenanceGroupMember,
        workType: workType ?? this.workType,
        workTypeName: workTypeName ?? this.workTypeName,
        state: state ?? this.state,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType);
  }
}

@JsonSerializable(explicitToJson: true)
class LaborProtectionAllocationDetail {
  LaborProtectionAllocationDetail({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.laborProtectionAllocationId,
    this.objectId,
    this.objectName,
    this.allocationBy,
    this.employeeTypeCode,
    this.employeeType,
    this.bomLaborProtectionId,
    this.bomLaborProtectionName,
    this.allocationTimes,
    this.totalPlanningsValue,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
  });

  factory LaborProtectionAllocationDetail.fromJson(Map<String, dynamic> json) =>
      _$LaborProtectionAllocationDetailFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'laborProtectionAllocationId', includeIfNull: false)
  final String? laborProtectionAllocationId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'allocationBy', includeIfNull: false)
  final String? allocationBy;
  @JsonKey(name: 'employeeTypeCode', includeIfNull: false)
  final String? employeeTypeCode;
  @JsonKey(name: 'employeeType', includeIfNull: false)
  final String? employeeType;
  @JsonKey(name: 'bomLaborProtectionId', includeIfNull: false)
  final String? bomLaborProtectionId;
  @JsonKey(name: 'bomLaborProtectionName', includeIfNull: false)
  final String? bomLaborProtectionName;
  @JsonKey(name: 'allocationTimes', includeIfNull: false)
  final int? allocationTimes;
  @JsonKey(name: 'totalPlanningsValue', includeIfNull: false)
  final int? totalPlanningsValue;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  static const fromJsonFactory = _$LaborProtectionAllocationDetailFromJson;
  static const toJsonFactory = _$LaborProtectionAllocationDetailToJson;
  Map<String, dynamic> toJson() =>
      _$LaborProtectionAllocationDetailToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LaborProtectionAllocationDetail &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.laborProtectionAllocationId, laborProtectionAllocationId) ||
                const DeepCollectionEquality().equals(
                    other.laborProtectionAllocationId,
                    laborProtectionAllocationId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.allocationBy, allocationBy) ||
                const DeepCollectionEquality()
                    .equals(other.allocationBy, allocationBy)) &&
            (identical(other.employeeTypeCode, employeeTypeCode) ||
                const DeepCollectionEquality()
                    .equals(other.employeeTypeCode, employeeTypeCode)) &&
            (identical(other.employeeType, employeeType) ||
                const DeepCollectionEquality()
                    .equals(other.employeeType, employeeType)) &&
            (identical(other.bomLaborProtectionId, bomLaborProtectionId) ||
                const DeepCollectionEquality().equals(
                    other.bomLaborProtectionId, bomLaborProtectionId)) &&
            (identical(other.bomLaborProtectionName, bomLaborProtectionName) ||
                const DeepCollectionEquality().equals(
                    other.bomLaborProtectionName, bomLaborProtectionName)) &&
            (identical(other.allocationTimes, allocationTimes) ||
                const DeepCollectionEquality()
                    .equals(other.allocationTimes, allocationTimes)) &&
            (identical(other.totalPlanningsValue, totalPlanningsValue) ||
                const DeepCollectionEquality()
                    .equals(other.totalPlanningsValue, totalPlanningsValue)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality().equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(laborProtectionAllocationId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(allocationBy) ^
      const DeepCollectionEquality().hash(employeeTypeCode) ^
      const DeepCollectionEquality().hash(employeeType) ^
      const DeepCollectionEquality().hash(bomLaborProtectionId) ^
      const DeepCollectionEquality().hash(bomLaborProtectionName) ^
      const DeepCollectionEquality().hash(allocationTimes) ^
      const DeepCollectionEquality().hash(totalPlanningsValue) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      runtimeType.hashCode;
}

extension $LaborProtectionAllocationDetailExtension
    on LaborProtectionAllocationDetail {
  LaborProtectionAllocationDetail copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? laborProtectionAllocationId,
      String? objectId,
      String? objectName,
      String? allocationBy,
      String? employeeTypeCode,
      String? employeeType,
      String? bomLaborProtectionId,
      String? bomLaborProtectionName,
      int? allocationTimes,
      int? totalPlanningsValue,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType}) {
    return LaborProtectionAllocationDetail(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        laborProtectionAllocationId:
            laborProtectionAllocationId ?? this.laborProtectionAllocationId,
        objectId: objectId ?? this.objectId,
        objectName: objectName ?? this.objectName,
        allocationBy: allocationBy ?? this.allocationBy,
        employeeTypeCode: employeeTypeCode ?? this.employeeTypeCode,
        employeeType: employeeType ?? this.employeeType,
        bomLaborProtectionId: bomLaborProtectionId ?? this.bomLaborProtectionId,
        bomLaborProtectionName:
            bomLaborProtectionName ?? this.bomLaborProtectionName,
        allocationTimes: allocationTimes ?? this.allocationTimes,
        totalPlanningsValue: totalPlanningsValue ?? this.totalPlanningsValue,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType);
  }
}

@JsonSerializable(explicitToJson: true)
class LaborProtectionAllocationDetailModel {
  LaborProtectionAllocationDetailModel({
    this.employeeTypeCode,
    this.laborProtectionAllocationDetail,
    this.listLaborProtectionAllocationPlanning,
  });

  factory LaborProtectionAllocationDetailModel.fromJson(
          Map<String, dynamic> json) =>
      _$LaborProtectionAllocationDetailModelFromJson(json);

  @JsonKey(name: 'employeeTypeCode', includeIfNull: false)
  final String? employeeTypeCode;
  @JsonKey(name: 'laborProtectionAllocationDetail', includeIfNull: false)
  final LaborProtectionAllocationDetail? laborProtectionAllocationDetail;
  @JsonKey(
      name: 'listLaborProtectionAllocationPlanning',
      includeIfNull: false,
      defaultValue: <LaborProtectionAllocationPlanning>[])
  final List<LaborProtectionAllocationPlanning>?
      listLaborProtectionAllocationPlanning;
  static const fromJsonFactory = _$LaborProtectionAllocationDetailModelFromJson;
  static const toJsonFactory = _$LaborProtectionAllocationDetailModelToJson;
  Map<String, dynamic> toJson() =>
      _$LaborProtectionAllocationDetailModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LaborProtectionAllocationDetailModel &&
            (identical(other.employeeTypeCode, employeeTypeCode) ||
                const DeepCollectionEquality()
                    .equals(other.employeeTypeCode, employeeTypeCode)) &&
            (identical(other.laborProtectionAllocationDetail,
                    laborProtectionAllocationDetail) ||
                const DeepCollectionEquality().equals(
                    other.laborProtectionAllocationDetail,
                    laborProtectionAllocationDetail)) &&
            (identical(other.listLaborProtectionAllocationPlanning,
                    listLaborProtectionAllocationPlanning) ||
                const DeepCollectionEquality().equals(
                    other.listLaborProtectionAllocationPlanning,
                    listLaborProtectionAllocationPlanning)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employeeTypeCode) ^
      const DeepCollectionEquality().hash(laborProtectionAllocationDetail) ^
      const DeepCollectionEquality()
          .hash(listLaborProtectionAllocationPlanning) ^
      runtimeType.hashCode;
}

extension $LaborProtectionAllocationDetailModelExtension
    on LaborProtectionAllocationDetailModel {
  LaborProtectionAllocationDetailModel copyWith(
      {String? employeeTypeCode,
      LaborProtectionAllocationDetail? laborProtectionAllocationDetail,
      List<LaborProtectionAllocationPlanning>?
          listLaborProtectionAllocationPlanning}) {
    return LaborProtectionAllocationDetailModel(
        employeeTypeCode: employeeTypeCode ?? this.employeeTypeCode,
        laborProtectionAllocationDetail: laborProtectionAllocationDetail ??
            this.laborProtectionAllocationDetail,
        listLaborProtectionAllocationPlanning:
            listLaborProtectionAllocationPlanning ??
                this.listLaborProtectionAllocationPlanning);
  }
}

@JsonSerializable(explicitToJson: true)
class LaborProtectionAllocationPlanning {
  LaborProtectionAllocationPlanning({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.laborProtectionAllocationDetailId,
    this.workingTimeId,
    this.quantity,
  });

  factory LaborProtectionAllocationPlanning.fromJson(
          Map<String, dynamic> json) =>
      _$LaborProtectionAllocationPlanningFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'laborProtectionAllocationDetailId', includeIfNull: false)
  final String? laborProtectionAllocationDetailId;
  @JsonKey(name: 'workingTimeId', includeIfNull: false)
  final String? workingTimeId;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final int? quantity;
  static const fromJsonFactory = _$LaborProtectionAllocationPlanningFromJson;
  static const toJsonFactory = _$LaborProtectionAllocationPlanningToJson;
  Map<String, dynamic> toJson() =>
      _$LaborProtectionAllocationPlanningToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LaborProtectionAllocationPlanning &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.laborProtectionAllocationDetailId,
                    laborProtectionAllocationDetailId) ||
                const DeepCollectionEquality().equals(
                    other.laborProtectionAllocationDetailId,
                    laborProtectionAllocationDetailId)) &&
            (identical(other.workingTimeId, workingTimeId) ||
                const DeepCollectionEquality()
                    .equals(other.workingTimeId, workingTimeId)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(laborProtectionAllocationDetailId) ^
      const DeepCollectionEquality().hash(workingTimeId) ^
      const DeepCollectionEquality().hash(quantity) ^
      runtimeType.hashCode;
}

extension $LaborProtectionAllocationPlanningExtension
    on LaborProtectionAllocationPlanning {
  LaborProtectionAllocationPlanning copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? laborProtectionAllocationDetailId,
      String? workingTimeId,
      int? quantity}) {
    return LaborProtectionAllocationPlanning(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        laborProtectionAllocationDetailId: laborProtectionAllocationDetailId ??
            this.laborProtectionAllocationDetailId,
        workingTimeId: workingTimeId ?? this.workingTimeId,
        quantity: quantity ?? this.quantity);
  }
}

@JsonSerializable(explicitToJson: true)
class LogQueryModel {
  LogQueryModel({
    this.sort,
    this.fields,
    this.currentPage,
    this.pageSize,
    this.filter,
    this.fullTextSearch,
    this.id,
    this.listId,
    this.applicationId,
    this.searchAllApp,
    this.listTextSearch,
    this.level,
    this.action,
    this.userId,
    this.userName,
    this.objectId,
    this.objectType,
    this.module,
    this.dateFrom,
    this.dateTo,
    this.minimumShouldMatch,
  });

  factory LogQueryModel.fromJson(Map<String, dynamic> json) =>
      _$LogQueryModelFromJson(json);

  @JsonKey(name: 'sort', includeIfNull: false)
  final String? sort;
  @JsonKey(name: 'fields', includeIfNull: false)
  final String? fields;
  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'filter', includeIfNull: false)
  final String? filter;
  @JsonKey(name: 'fullTextSearch', includeIfNull: false)
  final String? fullTextSearch;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'listId', includeIfNull: false, defaultValue: <String>[])
  final List<String>? listId;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'searchAllApp', includeIfNull: false)
  final bool? searchAllApp;
  @JsonKey(
      name: 'listTextSearch', includeIfNull: false, defaultValue: <String>[])
  final List<String>? listTextSearch;
  @JsonKey(
      name: 'level',
      includeIfNull: false,
      toJson: logEventLevelToJson,
      fromJson: logEventLevelFromJson)
  final enums.LogEventLevel? level;
  @JsonKey(name: 'action', includeIfNull: false)
  final String? action;
  @JsonKey(name: 'userId', includeIfNull: false)
  final String? userId;
  @JsonKey(name: 'userName', includeIfNull: false)
  final String? userName;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'module', includeIfNull: false)
  final String? module;
  @JsonKey(name: 'dateFrom', includeIfNull: false)
  final DateTime? dateFrom;
  @JsonKey(name: 'dateTo', includeIfNull: false)
  final DateTime? dateTo;
  @JsonKey(name: 'minimumShouldMatch', includeIfNull: false)
  final double? minimumShouldMatch;
  static const fromJsonFactory = _$LogQueryModelFromJson;
  static const toJsonFactory = _$LogQueryModelToJson;
  Map<String, dynamic> toJson() => _$LogQueryModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LogQueryModel &&
            (identical(other.sort, sort) ||
                const DeepCollectionEquality().equals(other.sort, sort)) &&
            (identical(other.fields, fields) ||
                const DeepCollectionEquality().equals(other.fields, fields)) &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)) &&
            (identical(other.fullTextSearch, fullTextSearch) ||
                const DeepCollectionEquality()
                    .equals(other.fullTextSearch, fullTextSearch)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.listId, listId) ||
                const DeepCollectionEquality().equals(other.listId, listId)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.searchAllApp, searchAllApp) ||
                const DeepCollectionEquality()
                    .equals(other.searchAllApp, searchAllApp)) &&
            (identical(other.listTextSearch, listTextSearch) ||
                const DeepCollectionEquality()
                    .equals(other.listTextSearch, listTextSearch)) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.module, module) ||
                const DeepCollectionEquality().equals(other.module, module)) &&
            (identical(other.dateFrom, dateFrom) ||
                const DeepCollectionEquality()
                    .equals(other.dateFrom, dateFrom)) &&
            (identical(other.dateTo, dateTo) ||
                const DeepCollectionEquality().equals(other.dateTo, dateTo)) &&
            (identical(other.minimumShouldMatch, minimumShouldMatch) ||
                const DeepCollectionEquality()
                    .equals(other.minimumShouldMatch, minimumShouldMatch)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sort) ^
      const DeepCollectionEquality().hash(fields) ^
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(filter) ^
      const DeepCollectionEquality().hash(fullTextSearch) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(listId) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(searchAllApp) ^
      const DeepCollectionEquality().hash(listTextSearch) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(action) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(module) ^
      const DeepCollectionEquality().hash(dateFrom) ^
      const DeepCollectionEquality().hash(dateTo) ^
      const DeepCollectionEquality().hash(minimumShouldMatch) ^
      runtimeType.hashCode;
}

extension $LogQueryModelExtension on LogQueryModel {
  LogQueryModel copyWith(
      {String? sort,
      String? fields,
      int? currentPage,
      int? pageSize,
      String? filter,
      String? fullTextSearch,
      String? id,
      List<String>? listId,
      String? applicationId,
      bool? searchAllApp,
      List<String>? listTextSearch,
      enums.LogEventLevel? level,
      String? action,
      String? userId,
      String? userName,
      String? objectId,
      String? objectType,
      String? module,
      DateTime? dateFrom,
      DateTime? dateTo,
      double? minimumShouldMatch}) {
    return LogQueryModel(
        sort: sort ?? this.sort,
        fields: fields ?? this.fields,
        currentPage: currentPage ?? this.currentPage,
        pageSize: pageSize ?? this.pageSize,
        filter: filter ?? this.filter,
        fullTextSearch: fullTextSearch ?? this.fullTextSearch,
        id: id ?? this.id,
        listId: listId ?? this.listId,
        applicationId: applicationId ?? this.applicationId,
        searchAllApp: searchAllApp ?? this.searchAllApp,
        listTextSearch: listTextSearch ?? this.listTextSearch,
        level: level ?? this.level,
        action: action ?? this.action,
        userId: userId ?? this.userId,
        userName: userName ?? this.userName,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        module: module ?? this.module,
        dateFrom: dateFrom ?? this.dateFrom,
        dateTo: dateTo ?? this.dateTo,
        minimumShouldMatch: minimumShouldMatch ?? this.minimumShouldMatch);
  }
}

@JsonSerializable(explicitToJson: true)
class LotDetailModel {
  LotDetailModel({
    this.id,
    this.lotId,
    this.objectId,
    this.objectType,
    this.objectCode,
    this.lotName,
    this.objectName,
    this.locationDestId,
    this.locationDestName,
    this.description,
    this.productQty,
    this.unitId,
    this.unit,
    this.isMark,
    this.lastModifiedOnDate,
    this.pickingId,
    this.metadataContentObjs,
  });

  factory LotDetailModel.fromJson(Map<String, dynamic> json) =>
      _$LotDetailModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'lotId', includeIfNull: false)
  final String? lotId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectCode', includeIfNull: false)
  final String? objectCode;
  @JsonKey(name: 'lotName', includeIfNull: false)
  final String? lotName;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'locationDestId', includeIfNull: false)
  final String? locationDestId;
  @JsonKey(name: 'locationDestName', includeIfNull: false)
  final String? locationDestName;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'productQty', includeIfNull: false)
  final double? productQty;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'unit', includeIfNull: false)
  final String? unit;
  @JsonKey(name: 'isMark', includeIfNull: false)
  final bool? isMark;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'pickingId', includeIfNull: false)
  final String? pickingId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  static const fromJsonFactory = _$LotDetailModelFromJson;
  static const toJsonFactory = _$LotDetailModelToJson;
  Map<String, dynamic> toJson() => _$LotDetailModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LotDetailModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.lotId, lotId) ||
                const DeepCollectionEquality().equals(other.lotId, lotId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.objectCode, objectCode) ||
                const DeepCollectionEquality()
                    .equals(other.objectCode, objectCode)) &&
            (identical(other.lotName, lotName) ||
                const DeepCollectionEquality()
                    .equals(other.lotName, lotName)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.locationDestId, locationDestId) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestId, locationDestId)) &&
            (identical(other.locationDestName, locationDestName) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestName, locationDestName)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.productQty, productQty) ||
                const DeepCollectionEquality()
                    .equals(other.productQty, productQty)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unit, unit) ||
                const DeepCollectionEquality().equals(other.unit, unit)) &&
            (identical(other.isMark, isMark) ||
                const DeepCollectionEquality().equals(other.isMark, isMark)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.pickingId, pickingId) ||
                const DeepCollectionEquality()
                    .equals(other.pickingId, pickingId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(lotId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectCode) ^
      const DeepCollectionEquality().hash(lotName) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(locationDestId) ^
      const DeepCollectionEquality().hash(locationDestName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(productQty) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unit) ^
      const DeepCollectionEquality().hash(isMark) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(pickingId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      runtimeType.hashCode;
}

extension $LotDetailModelExtension on LotDetailModel {
  LotDetailModel copyWith(
      {String? id,
      String? lotId,
      String? objectId,
      String? objectType,
      String? objectCode,
      String? lotName,
      String? objectName,
      String? locationDestId,
      String? locationDestName,
      String? description,
      double? productQty,
      String? unitId,
      String? unit,
      bool? isMark,
      DateTime? lastModifiedOnDate,
      String? pickingId,
      List<MetadataValue>? metadataContentObjs}) {
    return LotDetailModel(
        id: id ?? this.id,
        lotId: lotId ?? this.lotId,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        objectCode: objectCode ?? this.objectCode,
        lotName: lotName ?? this.lotName,
        objectName: objectName ?? this.objectName,
        locationDestId: locationDestId ?? this.locationDestId,
        locationDestName: locationDestName ?? this.locationDestName,
        description: description ?? this.description,
        productQty: productQty ?? this.productQty,
        unitId: unitId ?? this.unitId,
        unit: unit ?? this.unit,
        isMark: isMark ?? this.isMark,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        pickingId: pickingId ?? this.pickingId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs);
  }
}

@JsonSerializable(explicitToJson: true)
class MetaKeyValue {
  MetaKeyValue({
    this.key,
    this.value,
    this.order,
  });

  factory MetaKeyValue.fromJson(Map<String, dynamic> json) =>
      _$MetaKeyValueFromJson(json);

  @JsonKey(name: 'key', includeIfNull: false)
  final String? key;
  @JsonKey(name: 'value', includeIfNull: false)
  final String? value;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  static const fromJsonFactory = _$MetaKeyValueFromJson;
  static const toJsonFactory = _$MetaKeyValueToJson;
  Map<String, dynamic> toJson() => _$MetaKeyValueToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MetaKeyValue &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(order) ^
      runtimeType.hashCode;
}

extension $MetaKeyValueExtension on MetaKeyValue {
  MetaKeyValue copyWith({String? key, String? value, int? order}) {
    return MetaKeyValue(
        key: key ?? this.key,
        value: value ?? this.value,
        order: order ?? this.order);
  }
}

@JsonSerializable(explicitToJson: true)
class MetadataValue {
  MetadataValue({
    this.id,
    this.fieldName,
    this.displayName,
    this.fieldType,
    this.defaultValue,
    this.fieldValues,
    this.fieldSelectionValues,
    this.allowNulls,
    this.sortOrder,
  });

  factory MetadataValue.fromJson(Map<String, dynamic> json) =>
      _$MetadataValueFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'fieldName', includeIfNull: false)
  final String? fieldName;
  @JsonKey(name: 'displayName', includeIfNull: false)
  final String? displayName;
  @JsonKey(
      name: 'fieldType',
      includeIfNull: false,
      toJson: metafieldTypeToJson,
      fromJson: metafieldTypeFromJson)
  final enums.MetafieldType? fieldType;
  @JsonKey(name: 'defaultValue', includeIfNull: false)
  final String? defaultValue;
  @JsonKey(name: 'fieldValues', includeIfNull: false)
  final String? fieldValues;
  @JsonKey(
      name: 'fieldSelectionValues',
      includeIfNull: false,
      defaultValue: <MetaKeyValue>[])
  final List<MetaKeyValue>? fieldSelectionValues;
  @JsonKey(name: 'allowNulls', includeIfNull: false)
  final bool? allowNulls;
  @JsonKey(name: 'sortOrder', includeIfNull: false)
  final int? sortOrder;
  static const fromJsonFactory = _$MetadataValueFromJson;
  static const toJsonFactory = _$MetadataValueToJson;
  Map<String, dynamic> toJson() => _$MetadataValueToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MetadataValue &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.fieldName, fieldName) ||
                const DeepCollectionEquality()
                    .equals(other.fieldName, fieldName)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.fieldType, fieldType) ||
                const DeepCollectionEquality()
                    .equals(other.fieldType, fieldType)) &&
            (identical(other.defaultValue, defaultValue) ||
                const DeepCollectionEquality()
                    .equals(other.defaultValue, defaultValue)) &&
            (identical(other.fieldValues, fieldValues) ||
                const DeepCollectionEquality()
                    .equals(other.fieldValues, fieldValues)) &&
            (identical(other.fieldSelectionValues, fieldSelectionValues) ||
                const DeepCollectionEquality().equals(
                    other.fieldSelectionValues, fieldSelectionValues)) &&
            (identical(other.allowNulls, allowNulls) ||
                const DeepCollectionEquality()
                    .equals(other.allowNulls, allowNulls)) &&
            (identical(other.sortOrder, sortOrder) ||
                const DeepCollectionEquality()
                    .equals(other.sortOrder, sortOrder)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(fieldName) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(fieldType) ^
      const DeepCollectionEquality().hash(defaultValue) ^
      const DeepCollectionEquality().hash(fieldValues) ^
      const DeepCollectionEquality().hash(fieldSelectionValues) ^
      const DeepCollectionEquality().hash(allowNulls) ^
      const DeepCollectionEquality().hash(sortOrder) ^
      runtimeType.hashCode;
}

extension $MetadataValueExtension on MetadataValue {
  MetadataValue copyWith(
      {String? id,
      String? fieldName,
      String? displayName,
      enums.MetafieldType? fieldType,
      String? defaultValue,
      String? fieldValues,
      List<MetaKeyValue>? fieldSelectionValues,
      bool? allowNulls,
      int? sortOrder}) {
    return MetadataValue(
        id: id ?? this.id,
        fieldName: fieldName ?? this.fieldName,
        displayName: displayName ?? this.displayName,
        fieldType: fieldType ?? this.fieldType,
        defaultValue: defaultValue ?? this.defaultValue,
        fieldValues: fieldValues ?? this.fieldValues,
        fieldSelectionValues: fieldSelectionValues ?? this.fieldSelectionValues,
        allowNulls: allowNulls ?? this.allowNulls,
        sortOrder: sortOrder ?? this.sortOrder);
  }
}

@JsonSerializable(explicitToJson: true)
class ModifyFileRequestModel {
  ModifyFileRequestModel({
    this.objectId,
    this.objectType,
    this.relatedRoleCodeObjects,
    this.relatedRoleCode,
    this.relatedObjectIdList,
    this.relatedBaseCategory,
    this.relatedFondId,
    this.relatedArchiveTypeId,
    this.relatedRecordCollectionId,
    this.relatedRecordId,
    this.relatedProjectId,
    this.relatedTaskId,
    this.relatedRespartnerId,
    this.relatedObject1,
    this.relatedObject1Type,
    this.relatedObject2,
    this.relatedObject2Type,
    this.id,
    this.parentId,
    this.name,
    this.type,
    this.labelsObjs,
    this.labels,
    this.imageUrl,
    this.description,
    this.nodeTypeObj,
    this.metaContentType,
    this.metadataContentObj,
    this.metadataObj,
    this.ownerId,
    this.isPublish,
    this.isSearchable,
    this.aclObject,
    this.metaContent,
    this.parentIds,
  });

  factory ModifyFileRequestModel.fromJson(Map<String, dynamic> json) =>
      _$ModifyFileRequestModelFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(
      name: 'relatedRoleCodeObjects',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? relatedRoleCodeObjects;
  @JsonKey(name: 'relatedRoleCode', includeIfNull: false)
  final String? relatedRoleCode;
  @JsonKey(
      name: 'relatedObjectIdList',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? relatedObjectIdList;
  @JsonKey(name: 'relatedBaseCategory', includeIfNull: false)
  final String? relatedBaseCategory;
  @JsonKey(name: 'relatedFondId', includeIfNull: false)
  final String? relatedFondId;
  @JsonKey(name: 'relatedArchiveTypeId', includeIfNull: false)
  final String? relatedArchiveTypeId;
  @JsonKey(name: 'relatedRecordCollectionId', includeIfNull: false)
  final String? relatedRecordCollectionId;
  @JsonKey(name: 'relatedRecordId', includeIfNull: false)
  final String? relatedRecordId;
  @JsonKey(name: 'relatedProjectId', includeIfNull: false)
  final String? relatedProjectId;
  @JsonKey(name: 'relatedTaskId', includeIfNull: false)
  final String? relatedTaskId;
  @JsonKey(name: 'relatedRespartnerId', includeIfNull: false)
  final String? relatedRespartnerId;
  @JsonKey(name: 'relatedObject1', includeIfNull: false)
  final String? relatedObject1;
  @JsonKey(name: 'relatedObject1Type', includeIfNull: false)
  final String? relatedObject1Type;
  @JsonKey(name: 'relatedObject2', includeIfNull: false)
  final String? relatedObject2;
  @JsonKey(name: 'relatedObject2Type', includeIfNull: false)
  final String? relatedObject2Type;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labels', includeIfNull: false)
  final String? labels;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(
      name: 'nodeTypeObj',
      includeIfNull: false,
      toJson: nodeTypeEnumToJson,
      fromJson: nodeTypeEnumFromJson)
  final enums.NodeTypeEnum? nodeTypeObj;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(
      name: 'metadataContentObj',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObj;
  @JsonKey(
      name: 'metadataObj',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataObj;
  @JsonKey(name: 'ownerId', includeIfNull: false)
  final String? ownerId;
  @JsonKey(name: 'isPublish', includeIfNull: false)
  final bool? isPublish;
  @JsonKey(name: 'isSearchable', includeIfNull: false)
  final bool? isSearchable;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'metaContent', includeIfNull: false)
  final String? metaContent;
  @JsonKey(name: 'parentIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? parentIds;
  static const fromJsonFactory = _$ModifyFileRequestModelFromJson;
  static const toJsonFactory = _$ModifyFileRequestModelToJson;
  Map<String, dynamic> toJson() => _$ModifyFileRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ModifyFileRequestModel &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.relatedRoleCodeObjects, relatedRoleCodeObjects) ||
                const DeepCollectionEquality().equals(
                    other.relatedRoleCodeObjects, relatedRoleCodeObjects)) &&
            (identical(other.relatedRoleCode, relatedRoleCode) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRoleCode, relatedRoleCode)) &&
            (identical(other.relatedObjectIdList, relatedObjectIdList) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObjectIdList, relatedObjectIdList)) &&
            (identical(other.relatedBaseCategory, relatedBaseCategory) ||
                const DeepCollectionEquality()
                    .equals(other.relatedBaseCategory, relatedBaseCategory)) &&
            (identical(other.relatedFondId, relatedFondId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedFondId, relatedFondId)) &&
            (identical(other.relatedArchiveTypeId, relatedArchiveTypeId) ||
                const DeepCollectionEquality().equals(
                    other.relatedArchiveTypeId, relatedArchiveTypeId)) &&
            (identical(other.relatedRecordCollectionId, relatedRecordCollectionId) ||
                const DeepCollectionEquality().equals(
                    other.relatedRecordCollectionId,
                    relatedRecordCollectionId)) &&
            (identical(other.relatedRecordId, relatedRecordId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRecordId, relatedRecordId)) &&
            (identical(other.relatedProjectId, relatedProjectId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedProjectId, relatedProjectId)) &&
            (identical(other.relatedTaskId, relatedTaskId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedTaskId, relatedTaskId)) &&
            (identical(other.relatedRespartnerId, relatedRespartnerId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRespartnerId, relatedRespartnerId)) &&
            (identical(other.relatedObject1, relatedObject1) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject1, relatedObject1)) &&
            (identical(other.relatedObject1Type, relatedObject1Type) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject1Type, relatedObject1Type)) &&
            (identical(other.relatedObject2, relatedObject2) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject2, relatedObject2)) &&
            (identical(other.relatedObject2Type, relatedObject2Type) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject2Type, relatedObject2Type)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.labelsObjs, labelsObjs) || const DeepCollectionEquality().equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labels, labels) || const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.imageUrl, imageUrl) || const DeepCollectionEquality().equals(other.imageUrl, imageUrl)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.nodeTypeObj, nodeTypeObj) || const DeepCollectionEquality().equals(other.nodeTypeObj, nodeTypeObj)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContentObj, metadataContentObj) || const DeepCollectionEquality().equals(other.metadataContentObj, metadataContentObj)) &&
            (identical(other.metadataObj, metadataObj) || const DeepCollectionEquality().equals(other.metadataObj, metadataObj)) &&
            (identical(other.ownerId, ownerId) || const DeepCollectionEquality().equals(other.ownerId, ownerId)) &&
            (identical(other.isPublish, isPublish) || const DeepCollectionEquality().equals(other.isPublish, isPublish)) &&
            (identical(other.isSearchable, isSearchable) || const DeepCollectionEquality().equals(other.isSearchable, isSearchable)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.metaContent, metaContent) || const DeepCollectionEquality().equals(other.metaContent, metaContent)) &&
            (identical(other.parentIds, parentIds) || const DeepCollectionEquality().equals(other.parentIds, parentIds)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(relatedRoleCodeObjects) ^
      const DeepCollectionEquality().hash(relatedRoleCode) ^
      const DeepCollectionEquality().hash(relatedObjectIdList) ^
      const DeepCollectionEquality().hash(relatedBaseCategory) ^
      const DeepCollectionEquality().hash(relatedFondId) ^
      const DeepCollectionEquality().hash(relatedArchiveTypeId) ^
      const DeepCollectionEquality().hash(relatedRecordCollectionId) ^
      const DeepCollectionEquality().hash(relatedRecordId) ^
      const DeepCollectionEquality().hash(relatedProjectId) ^
      const DeepCollectionEquality().hash(relatedTaskId) ^
      const DeepCollectionEquality().hash(relatedRespartnerId) ^
      const DeepCollectionEquality().hash(relatedObject1) ^
      const DeepCollectionEquality().hash(relatedObject1Type) ^
      const DeepCollectionEquality().hash(relatedObject2) ^
      const DeepCollectionEquality().hash(relatedObject2Type) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(nodeTypeObj) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContentObj) ^
      const DeepCollectionEquality().hash(metadataObj) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(isPublish) ^
      const DeepCollectionEquality().hash(isSearchable) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(metaContent) ^
      const DeepCollectionEquality().hash(parentIds) ^
      runtimeType.hashCode;
}

extension $ModifyFileRequestModelExtension on ModifyFileRequestModel {
  ModifyFileRequestModel copyWith(
      {String? objectId,
      String? objectType,
      List<String>? relatedRoleCodeObjects,
      String? relatedRoleCode,
      List<String>? relatedObjectIdList,
      String? relatedBaseCategory,
      String? relatedFondId,
      String? relatedArchiveTypeId,
      String? relatedRecordCollectionId,
      String? relatedRecordId,
      String? relatedProjectId,
      String? relatedTaskId,
      String? relatedRespartnerId,
      String? relatedObject1,
      String? relatedObject1Type,
      String? relatedObject2,
      String? relatedObject2Type,
      String? id,
      String? parentId,
      String? name,
      String? type,
      List<LabelsObj>? labelsObjs,
      String? labels,
      String? imageUrl,
      String? description,
      enums.NodeTypeEnum? nodeTypeObj,
      String? metaContentType,
      List<MetadataValue>? metadataContentObj,
      List<MetadataValue>? metadataObj,
      String? ownerId,
      bool? isPublish,
      bool? isSearchable,
      ACLObject? aclObject,
      String? metaContent,
      List<String>? parentIds}) {
    return ModifyFileRequestModel(
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        relatedRoleCodeObjects:
            relatedRoleCodeObjects ?? this.relatedRoleCodeObjects,
        relatedRoleCode: relatedRoleCode ?? this.relatedRoleCode,
        relatedObjectIdList: relatedObjectIdList ?? this.relatedObjectIdList,
        relatedBaseCategory: relatedBaseCategory ?? this.relatedBaseCategory,
        relatedFondId: relatedFondId ?? this.relatedFondId,
        relatedArchiveTypeId: relatedArchiveTypeId ?? this.relatedArchiveTypeId,
        relatedRecordCollectionId:
            relatedRecordCollectionId ?? this.relatedRecordCollectionId,
        relatedRecordId: relatedRecordId ?? this.relatedRecordId,
        relatedProjectId: relatedProjectId ?? this.relatedProjectId,
        relatedTaskId: relatedTaskId ?? this.relatedTaskId,
        relatedRespartnerId: relatedRespartnerId ?? this.relatedRespartnerId,
        relatedObject1: relatedObject1 ?? this.relatedObject1,
        relatedObject1Type: relatedObject1Type ?? this.relatedObject1Type,
        relatedObject2: relatedObject2 ?? this.relatedObject2,
        relatedObject2Type: relatedObject2Type ?? this.relatedObject2Type,
        id: id ?? this.id,
        parentId: parentId ?? this.parentId,
        name: name ?? this.name,
        type: type ?? this.type,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labels: labels ?? this.labels,
        imageUrl: imageUrl ?? this.imageUrl,
        description: description ?? this.description,
        nodeTypeObj: nodeTypeObj ?? this.nodeTypeObj,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContentObj: metadataContentObj ?? this.metadataContentObj,
        metadataObj: metadataObj ?? this.metadataObj,
        ownerId: ownerId ?? this.ownerId,
        isPublish: isPublish ?? this.isPublish,
        isSearchable: isSearchable ?? this.isSearchable,
        aclObject: aclObject ?? this.aclObject,
        metaContent: metaContent ?? this.metaContent,
        parentIds: parentIds ?? this.parentIds);
  }
}

@JsonSerializable(explicitToJson: true)
class ObjectPagination {
  ObjectPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory ObjectPagination.fromJson(Map<String, dynamic> json) =>
      _$ObjectPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? content;
  static const fromJsonFactory = _$ObjectPaginationFromJson;
  static const toJsonFactory = _$ObjectPaginationToJson;
  Map<String, dynamic> toJson() => _$ObjectPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ObjectPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $ObjectPaginationExtension on ObjectPagination {
  ObjectPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<Object>? content}) {
    return ObjectPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class ObjectResponseList {
  ObjectResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ObjectResponseList.fromJson(Map<String, dynamic> json) =>
      _$ObjectResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? data;
  static const fromJsonFactory = _$ObjectResponseListFromJson;
  static const toJsonFactory = _$ObjectResponseListToJson;
  Map<String, dynamic> toJson() => _$ObjectResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ObjectResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ObjectResponseListExtension on ObjectResponseList {
  ObjectResponseList copyWith(
      {enums.Code? code, String? message, num? totalTime, List<Object>? data}) {
    return ObjectResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ObjectResponseObject {
  ObjectResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ObjectResponseObject.fromJson(Map<String, dynamic> json) =>
      _$ObjectResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final dynamic data;
  static const fromJsonFactory = _$ObjectResponseObjectFromJson;
  static const toJsonFactory = _$ObjectResponseObjectToJson;
  Map<String, dynamic> toJson() => _$ObjectResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ObjectResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ObjectResponseObjectExtension on ObjectResponseObject {
  ObjectResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, dynamic data}) {
    return ObjectResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ObjectResponsePagination {
  ObjectResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ObjectResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$ObjectResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ObjectPagination? data;
  static const fromJsonFactory = _$ObjectResponsePaginationFromJson;
  static const toJsonFactory = _$ObjectResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$ObjectResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ObjectResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ObjectResponsePaginationExtension on ObjectResponsePagination {
  ObjectResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ObjectPagination? data}) {
    return ObjectResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class Org {
  Org({
    this.title,
    this.organization,
    this.startTime,
    this.endTime,
    this.description,
  });

  factory Org.fromJson(Map<String, dynamic> json) => _$OrgFromJson(json);

  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'organization', includeIfNull: false)
  final String? organization;
  @JsonKey(name: 'startTime', includeIfNull: false)
  final DateTime? startTime;
  @JsonKey(name: 'endTime', includeIfNull: false)
  final DateTime? endTime;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  static const fromJsonFactory = _$OrgFromJson;
  static const toJsonFactory = _$OrgToJson;
  Map<String, dynamic> toJson() => _$OrgToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Org &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.organization, organization) ||
                const DeepCollectionEquality()
                    .equals(other.organization, organization)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(organization) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $OrgExtension on Org {
  Org copyWith(
      {String? title,
      String? organization,
      DateTime? startTime,
      DateTime? endTime,
      String? description}) {
    return Org(
        title: title ?? this.title,
        organization: organization ?? this.organization,
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        description: description ?? this.description);
  }
}

@JsonSerializable(explicitToJson: true)
class PMProject {
  PMProject({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.aclObject,
    this.acl,
    this.id,
    required this.code,
    required this.name,
    this.description,
    this.parentId,
    this.parentType,
    this.priorityObj,
    this.priority,
    this.weight,
    this.rank,
    this.labelsObjs,
    this.labels,
    this.managementObj,
    this.management,
    this.ownerObj,
    this.owner,
    this.supervisorObj,
    this.supervisor,
    this.coordinatorObj,
    this.coordinator,
    this.assigneeObj,
    this.assignee,
    this.viewerObj,
    this.viewer,
    this.statusObj,
    this.status,
    this.objectId,
    this.objectType,
    this.objectAction,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.projectTemplateId,
    this.workflowStatus,
    this.ref,
    this.isDeleted,
  });

  factory PMProject.fromJson(Map<String, dynamic> json) =>
      _$PMProjectFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'acl', includeIfNull: false)
  final String? acl;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'code', includeIfNull: false)
  final String code;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentType', includeIfNull: false)
  final String? parentType;
  @JsonKey(
      name: 'priorityObj',
      includeIfNull: false,
      toJson: priorityEnumsToJson,
      fromJson: priorityEnumsFromJson)
  final enums.PriorityEnums? priorityObj;
  @JsonKey(name: 'priority', includeIfNull: false)
  final int? priority;
  @JsonKey(name: 'weight', includeIfNull: false)
  final int? weight;
  @JsonKey(name: 'rank', includeIfNull: false)
  final int? rank;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labels', includeIfNull: false)
  final String? labels;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'management', includeIfNull: false)
  final String? management;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(name: 'owner', includeIfNull: false)
  final String? owner;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(name: 'supervisor', includeIfNull: false)
  final String? supervisor;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'coordinator', includeIfNull: false)
  final String? coordinator;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'assignee', includeIfNull: false)
  final String? assignee;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'viewer', includeIfNull: false)
  final String? viewer;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: pMStatusEnumsToJson,
      fromJson: pMStatusEnumsFromJson)
  final enums.PMStatusEnums? statusObj;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectAction', includeIfNull: false)
  final String? objectAction;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'projectTemplateId', includeIfNull: false)
  final String? projectTemplateId;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final int? workflowStatus;
  @JsonKey(name: 'ref', includeIfNull: false)
  final String? ref;
  @JsonKey(name: 'isDeleted', includeIfNull: false)
  final bool? isDeleted;
  static const fromJsonFactory = _$PMProjectFromJson;
  static const toJsonFactory = _$PMProjectToJson;
  Map<String, dynamic> toJson() => _$PMProjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PMProject &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.aclObject, aclObject) ||
                const DeepCollectionEquality()
                    .equals(other.aclObject, aclObject)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentType, parentType) ||
                const DeepCollectionEquality()
                    .equals(other.parentType, parentType)) &&
            (identical(other.priorityObj, priorityObj) ||
                const DeepCollectionEquality()
                    .equals(other.priorityObj, priorityObj)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.management, management) ||
                const DeepCollectionEquality()
                    .equals(other.management, management)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.supervisor, supervisor) ||
                const DeepCollectionEquality()
                    .equals(other.supervisor, supervisor)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality().equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.coordinator, coordinator) || const DeepCollectionEquality().equals(other.coordinator, coordinator)) &&
            (identical(other.assigneeObj, assigneeObj) || const DeepCollectionEquality().equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.assignee, assignee) || const DeepCollectionEquality().equals(other.assignee, assignee)) &&
            (identical(other.viewerObj, viewerObj) || const DeepCollectionEquality().equals(other.viewerObj, viewerObj)) &&
            (identical(other.viewer, viewer) || const DeepCollectionEquality().equals(other.viewer, viewer)) &&
            (identical(other.statusObj, statusObj) || const DeepCollectionEquality().equals(other.statusObj, statusObj)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.objectId, objectId) || const DeepCollectionEquality().equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) || const DeepCollectionEquality().equals(other.objectType, objectType)) &&
            (identical(other.objectAction, objectAction) || const DeepCollectionEquality().equals(other.objectAction, objectAction)) &&
            (identical(other.fromDate, fromDate) || const DeepCollectionEquality().equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) || const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) || const DeepCollectionEquality().equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) || const DeepCollectionEquality().equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) || const DeepCollectionEquality().equals(other.actualTime, actualTime)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) || const DeepCollectionEquality().equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) || const DeepCollectionEquality().equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) || const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) || const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) || const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.projectTemplateId, projectTemplateId) || const DeepCollectionEquality().equals(other.projectTemplateId, projectTemplateId)) &&
            (identical(other.workflowStatus, workflowStatus) || const DeepCollectionEquality().equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.ref, ref) || const DeepCollectionEquality().equals(other.ref, ref)) &&
            (identical(other.isDeleted, isDeleted) || const DeepCollectionEquality().equals(other.isDeleted, isDeleted)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentType) ^
      const DeepCollectionEquality().hash(priorityObj) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(management) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(supervisor) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(coordinator) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(viewer) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectAction) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(projectTemplateId) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(ref) ^
      const DeepCollectionEquality().hash(isDeleted) ^
      runtimeType.hashCode;
}

extension $PMProjectExtension on PMProject {
  PMProject copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      ACLObject? aclObject,
      String? acl,
      String? id,
      String? code,
      String? name,
      String? description,
      String? parentId,
      String? parentType,
      enums.PriorityEnums? priorityObj,
      int? priority,
      int? weight,
      int? rank,
      List<LabelsObj>? labelsObjs,
      String? labels,
      List<String>? managementObj,
      String? management,
      List<String>? ownerObj,
      String? owner,
      List<String>? supervisorObj,
      String? supervisor,
      List<String>? coordinatorObj,
      String? coordinator,
      List<String>? assigneeObj,
      String? assignee,
      List<String>? viewerObj,
      String? viewer,
      enums.PMStatusEnums? statusObj,
      int? status,
      String? objectId,
      String? objectType,
      String? objectAction,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel,
      String? projectTemplateId,
      int? workflowStatus,
      String? ref,
      bool? isDeleted}) {
    return PMProject(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        aclObject: aclObject ?? this.aclObject,
        acl: acl ?? this.acl,
        id: id ?? this.id,
        code: code ?? this.code,
        name: name ?? this.name,
        description: description ?? this.description,
        parentId: parentId ?? this.parentId,
        parentType: parentType ?? this.parentType,
        priorityObj: priorityObj ?? this.priorityObj,
        priority: priority ?? this.priority,
        weight: weight ?? this.weight,
        rank: rank ?? this.rank,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labels: labels ?? this.labels,
        managementObj: managementObj ?? this.managementObj,
        management: management ?? this.management,
        ownerObj: ownerObj ?? this.ownerObj,
        owner: owner ?? this.owner,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        supervisor: supervisor ?? this.supervisor,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        coordinator: coordinator ?? this.coordinator,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        assignee: assignee ?? this.assignee,
        viewerObj: viewerObj ?? this.viewerObj,
        viewer: viewer ?? this.viewer,
        statusObj: statusObj ?? this.statusObj,
        status: status ?? this.status,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        objectAction: objectAction ?? this.objectAction,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        projectTemplateId: projectTemplateId ?? this.projectTemplateId,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        ref: ref ?? this.ref,
        isDeleted: isDeleted ?? this.isDeleted);
  }
}

@JsonSerializable(explicitToJson: true)
class PMProjectResponseObject {
  PMProjectResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory PMProjectResponseObject.fromJson(Map<String, dynamic> json) =>
      _$PMProjectResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final PMProject? data;
  static const fromJsonFactory = _$PMProjectResponseObjectFromJson;
  static const toJsonFactory = _$PMProjectResponseObjectToJson;
  Map<String, dynamic> toJson() => _$PMProjectResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PMProjectResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $PMProjectResponseObjectExtension on PMProjectResponseObject {
  PMProjectResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, PMProject? data}) {
    return PMProjectResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class PatchUpdateFileRequestModel {
  PatchUpdateFileRequestModel({
    this.objectId,
    this.objectType,
    this.relatedRoleCodeObjects,
    this.relatedRoleCode,
    this.relatedObjectIdList,
    this.relatedBaseCategory,
    this.relatedFondId,
    this.relatedArchiveTypeId,
    this.relatedRecordCollectionId,
    this.relatedRecordId,
    this.relatedProjectId,
    this.relatedTaskId,
    this.relatedRespartnerId,
    this.relatedObject1,
    this.relatedObject1Type,
    this.relatedObject2,
    this.relatedObject2Type,
    this.name,
    this.labelsObjs,
    this.imageUrl,
    this.type,
    this.description,
    this.aclObject,
    this.metadataContentObj,
    this.parentId,
    this.parentIds,
    this.metadataObj,
    this.ownerId,
    this.isPublish,
    this.isSearchable,
    this.id,
  });

  factory PatchUpdateFileRequestModel.fromJson(Map<String, dynamic> json) =>
      _$PatchUpdateFileRequestModelFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(
      name: 'relatedRoleCodeObjects',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? relatedRoleCodeObjects;
  @JsonKey(name: 'relatedRoleCode', includeIfNull: false)
  final String? relatedRoleCode;
  @JsonKey(
      name: 'relatedObjectIdList',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? relatedObjectIdList;
  @JsonKey(name: 'relatedBaseCategory', includeIfNull: false)
  final String? relatedBaseCategory;
  @JsonKey(name: 'relatedFondId', includeIfNull: false)
  final String? relatedFondId;
  @JsonKey(name: 'relatedArchiveTypeId', includeIfNull: false)
  final String? relatedArchiveTypeId;
  @JsonKey(name: 'relatedRecordCollectionId', includeIfNull: false)
  final String? relatedRecordCollectionId;
  @JsonKey(name: 'relatedRecordId', includeIfNull: false)
  final String? relatedRecordId;
  @JsonKey(name: 'relatedProjectId', includeIfNull: false)
  final String? relatedProjectId;
  @JsonKey(name: 'relatedTaskId', includeIfNull: false)
  final String? relatedTaskId;
  @JsonKey(name: 'relatedRespartnerId', includeIfNull: false)
  final String? relatedRespartnerId;
  @JsonKey(name: 'relatedObject1', includeIfNull: false)
  final String? relatedObject1;
  @JsonKey(name: 'relatedObject1Type', includeIfNull: false)
  final String? relatedObject1Type;
  @JsonKey(name: 'relatedObject2', includeIfNull: false)
  final String? relatedObject2;
  @JsonKey(name: 'relatedObject2Type', includeIfNull: false)
  final String? relatedObject2Type;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(
      name: 'metadataContentObj',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObj;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? parentIds;
  @JsonKey(
      name: 'metadataObj',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataObj;
  @JsonKey(name: 'ownerId', includeIfNull: false)
  final String? ownerId;
  @JsonKey(name: 'isPublish', includeIfNull: false)
  final bool? isPublish;
  @JsonKey(name: 'isSearchable', includeIfNull: false)
  final bool? isSearchable;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  static const fromJsonFactory = _$PatchUpdateFileRequestModelFromJson;
  static const toJsonFactory = _$PatchUpdateFileRequestModelToJson;
  Map<String, dynamic> toJson() => _$PatchUpdateFileRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PatchUpdateFileRequestModel &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.relatedRoleCodeObjects, relatedRoleCodeObjects) ||
                const DeepCollectionEquality().equals(
                    other.relatedRoleCodeObjects, relatedRoleCodeObjects)) &&
            (identical(other.relatedRoleCode, relatedRoleCode) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRoleCode, relatedRoleCode)) &&
            (identical(other.relatedObjectIdList, relatedObjectIdList) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObjectIdList, relatedObjectIdList)) &&
            (identical(other.relatedBaseCategory, relatedBaseCategory) ||
                const DeepCollectionEquality()
                    .equals(other.relatedBaseCategory, relatedBaseCategory)) &&
            (identical(other.relatedFondId, relatedFondId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedFondId, relatedFondId)) &&
            (identical(other.relatedArchiveTypeId, relatedArchiveTypeId) ||
                const DeepCollectionEquality().equals(
                    other.relatedArchiveTypeId, relatedArchiveTypeId)) &&
            (identical(other.relatedRecordCollectionId, relatedRecordCollectionId) ||
                const DeepCollectionEquality().equals(
                    other.relatedRecordCollectionId,
                    relatedRecordCollectionId)) &&
            (identical(other.relatedRecordId, relatedRecordId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRecordId, relatedRecordId)) &&
            (identical(other.relatedProjectId, relatedProjectId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedProjectId, relatedProjectId)) &&
            (identical(other.relatedTaskId, relatedTaskId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedTaskId, relatedTaskId)) &&
            (identical(other.relatedRespartnerId, relatedRespartnerId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRespartnerId, relatedRespartnerId)) &&
            (identical(other.relatedObject1, relatedObject1) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject1, relatedObject1)) &&
            (identical(other.relatedObject1Type, relatedObject1Type) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject1Type, relatedObject1Type)) &&
            (identical(other.relatedObject2, relatedObject2) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject2, relatedObject2)) &&
            (identical(other.relatedObject2Type, relatedObject2Type) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject2Type, relatedObject2Type)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.imageUrl, imageUrl) || const DeepCollectionEquality().equals(other.imageUrl, imageUrl)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.metadataContentObj, metadataContentObj) || const DeepCollectionEquality().equals(other.metadataContentObj, metadataContentObj)) &&
            (identical(other.parentId, parentId) || const DeepCollectionEquality().equals(other.parentId, parentId)) &&
            (identical(other.parentIds, parentIds) || const DeepCollectionEquality().equals(other.parentIds, parentIds)) &&
            (identical(other.metadataObj, metadataObj) || const DeepCollectionEquality().equals(other.metadataObj, metadataObj)) &&
            (identical(other.ownerId, ownerId) || const DeepCollectionEquality().equals(other.ownerId, ownerId)) &&
            (identical(other.isPublish, isPublish) || const DeepCollectionEquality().equals(other.isPublish, isPublish)) &&
            (identical(other.isSearchable, isSearchable) || const DeepCollectionEquality().equals(other.isSearchable, isSearchable)) &&
            (identical(other.id, id) || const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(relatedRoleCodeObjects) ^
      const DeepCollectionEquality().hash(relatedRoleCode) ^
      const DeepCollectionEquality().hash(relatedObjectIdList) ^
      const DeepCollectionEquality().hash(relatedBaseCategory) ^
      const DeepCollectionEquality().hash(relatedFondId) ^
      const DeepCollectionEquality().hash(relatedArchiveTypeId) ^
      const DeepCollectionEquality().hash(relatedRecordCollectionId) ^
      const DeepCollectionEquality().hash(relatedRecordId) ^
      const DeepCollectionEquality().hash(relatedProjectId) ^
      const DeepCollectionEquality().hash(relatedTaskId) ^
      const DeepCollectionEquality().hash(relatedRespartnerId) ^
      const DeepCollectionEquality().hash(relatedObject1) ^
      const DeepCollectionEquality().hash(relatedObject1Type) ^
      const DeepCollectionEquality().hash(relatedObject2) ^
      const DeepCollectionEquality().hash(relatedObject2Type) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(metadataContentObj) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentIds) ^
      const DeepCollectionEquality().hash(metadataObj) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(isPublish) ^
      const DeepCollectionEquality().hash(isSearchable) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $PatchUpdateFileRequestModelExtension on PatchUpdateFileRequestModel {
  PatchUpdateFileRequestModel copyWith(
      {String? objectId,
      String? objectType,
      List<String>? relatedRoleCodeObjects,
      String? relatedRoleCode,
      List<String>? relatedObjectIdList,
      String? relatedBaseCategory,
      String? relatedFondId,
      String? relatedArchiveTypeId,
      String? relatedRecordCollectionId,
      String? relatedRecordId,
      String? relatedProjectId,
      String? relatedTaskId,
      String? relatedRespartnerId,
      String? relatedObject1,
      String? relatedObject1Type,
      String? relatedObject2,
      String? relatedObject2Type,
      String? name,
      List<LabelsObj>? labelsObjs,
      String? imageUrl,
      String? type,
      String? description,
      ACLObject? aclObject,
      List<MetadataValue>? metadataContentObj,
      String? parentId,
      List<String>? parentIds,
      List<MetadataValue>? metadataObj,
      String? ownerId,
      bool? isPublish,
      bool? isSearchable,
      String? id}) {
    return PatchUpdateFileRequestModel(
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        relatedRoleCodeObjects:
            relatedRoleCodeObjects ?? this.relatedRoleCodeObjects,
        relatedRoleCode: relatedRoleCode ?? this.relatedRoleCode,
        relatedObjectIdList: relatedObjectIdList ?? this.relatedObjectIdList,
        relatedBaseCategory: relatedBaseCategory ?? this.relatedBaseCategory,
        relatedFondId: relatedFondId ?? this.relatedFondId,
        relatedArchiveTypeId: relatedArchiveTypeId ?? this.relatedArchiveTypeId,
        relatedRecordCollectionId:
            relatedRecordCollectionId ?? this.relatedRecordCollectionId,
        relatedRecordId: relatedRecordId ?? this.relatedRecordId,
        relatedProjectId: relatedProjectId ?? this.relatedProjectId,
        relatedTaskId: relatedTaskId ?? this.relatedTaskId,
        relatedRespartnerId: relatedRespartnerId ?? this.relatedRespartnerId,
        relatedObject1: relatedObject1 ?? this.relatedObject1,
        relatedObject1Type: relatedObject1Type ?? this.relatedObject1Type,
        relatedObject2: relatedObject2 ?? this.relatedObject2,
        relatedObject2Type: relatedObject2Type ?? this.relatedObject2Type,
        name: name ?? this.name,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        imageUrl: imageUrl ?? this.imageUrl,
        type: type ?? this.type,
        description: description ?? this.description,
        aclObject: aclObject ?? this.aclObject,
        metadataContentObj: metadataContentObj ?? this.metadataContentObj,
        parentId: parentId ?? this.parentId,
        parentIds: parentIds ?? this.parentIds,
        metadataObj: metadataObj ?? this.metadataObj,
        ownerId: ownerId ?? this.ownerId,
        isPublish: isPublish ?? this.isPublish,
        isSearchable: isSearchable ?? this.isSearchable,
        id: id ?? this.id);
  }
}

@JsonSerializable(explicitToJson: true)
class PatchUpdateFilesMetadataRequestModel {
  PatchUpdateFilesMetadataRequestModel({
    this.id,
    this.metadataContentObjs,
  });

  factory PatchUpdateFilesMetadataRequestModel.fromJson(
          Map<String, dynamic> json) =>
      _$PatchUpdateFilesMetadataRequestModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  static const fromJsonFactory = _$PatchUpdateFilesMetadataRequestModelFromJson;
  static const toJsonFactory = _$PatchUpdateFilesMetadataRequestModelToJson;
  Map<String, dynamic> toJson() =>
      _$PatchUpdateFilesMetadataRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PatchUpdateFilesMetadataRequestModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      runtimeType.hashCode;
}

extension $PatchUpdateFilesMetadataRequestModelExtension
    on PatchUpdateFilesMetadataRequestModel {
  PatchUpdateFilesMetadataRequestModel copyWith(
      {String? id, List<MetadataValue>? metadataContentObjs}) {
    return PatchUpdateFilesMetadataRequestModel(
        id: id ?? this.id,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs);
  }
}

@JsonSerializable(explicitToJson: true)
class PatchUpdateFilesParentRequestModel {
  PatchUpdateFilesParentRequestModel({
    this.id,
    this.parentId,
  });

  factory PatchUpdateFilesParentRequestModel.fromJson(
          Map<String, dynamic> json) =>
      _$PatchUpdateFilesParentRequestModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  static const fromJsonFactory = _$PatchUpdateFilesParentRequestModelFromJson;
  static const toJsonFactory = _$PatchUpdateFilesParentRequestModelToJson;
  Map<String, dynamic> toJson() =>
      _$PatchUpdateFilesParentRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PatchUpdateFilesParentRequestModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(parentId) ^
      runtimeType.hashCode;
}

extension $PatchUpdateFilesParentRequestModelExtension
    on PatchUpdateFilesParentRequestModel {
  PatchUpdateFilesParentRequestModel copyWith({String? id, String? parentId}) {
    return PatchUpdateFilesParentRequestModel(
        id: id ?? this.id, parentId: parentId ?? this.parentId);
  }
}

@JsonSerializable(explicitToJson: true)
class Phone {
  Phone({
    this.type,
    this.uri,
  });

  factory Phone.fromJson(Map<String, dynamic> json) => _$PhoneFromJson(json);

  @JsonKey(name: 'type', includeIfNull: false, defaultValue: <String>[])
  final List<String>? type;
  @JsonKey(name: 'uri', includeIfNull: false)
  final String? uri;
  static const fromJsonFactory = _$PhoneFromJson;
  static const toJsonFactory = _$PhoneToJson;
  Map<String, dynamic> toJson() => _$PhoneToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Phone &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.uri, uri) ||
                const DeepCollectionEquality().equals(other.uri, uri)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(uri) ^
      runtimeType.hashCode;
}

extension $PhoneExtension on Phone {
  Phone copyWith({List<String>? type, String? uri}) {
    return Phone(type: type ?? this.type, uri: uri ?? this.uri);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanLaborModel {
  PlanLaborModel({
    this.laborProtectionAllocation,
    this.listLaborProtectionAllocationDetailModel,
  });

  factory PlanLaborModel.fromJson(Map<String, dynamic> json) =>
      _$PlanLaborModelFromJson(json);

  @JsonKey(name: 'laborProtectionAllocation', includeIfNull: false)
  final LaborProtectionAllocation? laborProtectionAllocation;
  @JsonKey(
      name: 'listLaborProtectionAllocationDetailModel',
      includeIfNull: false,
      defaultValue: <LaborProtectionAllocationDetailModel>[])
  final List<LaborProtectionAllocationDetailModel>?
      listLaborProtectionAllocationDetailModel;
  static const fromJsonFactory = _$PlanLaborModelFromJson;
  static const toJsonFactory = _$PlanLaborModelToJson;
  Map<String, dynamic> toJson() => _$PlanLaborModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanLaborModel &&
            (identical(other.laborProtectionAllocation,
                    laborProtectionAllocation) ||
                const DeepCollectionEquality().equals(
                    other.laborProtectionAllocation,
                    laborProtectionAllocation)) &&
            (identical(other.listLaborProtectionAllocationDetailModel,
                    listLaborProtectionAllocationDetailModel) ||
                const DeepCollectionEquality().equals(
                    other.listLaborProtectionAllocationDetailModel,
                    listLaborProtectionAllocationDetailModel)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(laborProtectionAllocation) ^
      const DeepCollectionEquality()
          .hash(listLaborProtectionAllocationDetailModel) ^
      runtimeType.hashCode;
}

extension $PlanLaborModelExtension on PlanLaborModel {
  PlanLaborModel copyWith(
      {LaborProtectionAllocation? laborProtectionAllocation,
      List<LaborProtectionAllocationDetailModel>?
          listLaborProtectionAllocationDetailModel}) {
    return PlanLaborModel(
        laborProtectionAllocation:
            laborProtectionAllocation ?? this.laborProtectionAllocation,
        listLaborProtectionAllocationDetailModel:
            listLaborProtectionAllocationDetailModel ??
                this.listLaborProtectionAllocationDetailModel);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanLaborModelResponseObject {
  PlanLaborModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory PlanLaborModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$PlanLaborModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final PlanLaborModel? data;
  static const fromJsonFactory = _$PlanLaborModelResponseObjectFromJson;
  static const toJsonFactory = _$PlanLaborModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$PlanLaborModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanLaborModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $PlanLaborModelResponseObjectExtension
    on PlanLaborModelResponseObject {
  PlanLaborModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      PlanLaborModel? data}) {
    return PlanLaborModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanningCloneRequestModel {
  PlanningCloneRequestModel({
    this.srcYear,
    this.destYear,
  });

  factory PlanningCloneRequestModel.fromJson(Map<String, dynamic> json) =>
      _$PlanningCloneRequestModelFromJson(json);

  @JsonKey(name: 'srcYear', includeIfNull: false)
  final int? srcYear;
  @JsonKey(name: 'destYear', includeIfNull: false)
  final int? destYear;
  static const fromJsonFactory = _$PlanningCloneRequestModelFromJson;
  static const toJsonFactory = _$PlanningCloneRequestModelToJson;
  Map<String, dynamic> toJson() => _$PlanningCloneRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanningCloneRequestModel &&
            (identical(other.srcYear, srcYear) ||
                const DeepCollectionEquality()
                    .equals(other.srcYear, srcYear)) &&
            (identical(other.destYear, destYear) ||
                const DeepCollectionEquality()
                    .equals(other.destYear, destYear)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(srcYear) ^
      const DeepCollectionEquality().hash(destYear) ^
      runtimeType.hashCode;
}

extension $PlanningCloneRequestModelExtension on PlanningCloneRequestModel {
  PlanningCloneRequestModel copyWith({int? srcYear, int? destYear}) {
    return PlanningCloneRequestModel(
        srcYear: srcYear ?? this.srcYear, destYear: destYear ?? this.destYear);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanningModel {
  PlanningModel({
    this.id,
    this.name,
    this.state,
    this.datePlannedStart,
    this.objectId,
    this.unitId,
    this.objectName,
    this.objectType,
    this.quantity,
    this.locationSrcId,
    this.locationSrcName,
    this.description,
    this.notebookId,
    this.productionMasterId,
    this.metadataContentObjs,
    this.details,
  });

  factory PlanningModel.fromJson(Map<String, dynamic> json) =>
      _$PlanningModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(name: 'datePlannedStart', includeIfNull: false)
  final DateTime? datePlannedStart;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'locationSrcId', includeIfNull: false)
  final String? locationSrcId;
  @JsonKey(name: 'locationSrcName', includeIfNull: false)
  final String? locationSrcName;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'notebookId', includeIfNull: false)
  final String? notebookId;
  @JsonKey(name: 'productionMasterId', includeIfNull: false)
  final String? productionMasterId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(
      name: 'details',
      includeIfNull: false,
      defaultValue: <ProductionWorkOrderPlanningModel>[])
  final List<ProductionWorkOrderPlanningModel>? details;
  static const fromJsonFactory = _$PlanningModelFromJson;
  static const toJsonFactory = _$PlanningModelToJson;
  Map<String, dynamic> toJson() => _$PlanningModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanningModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.datePlannedStart, datePlannedStart) ||
                const DeepCollectionEquality()
                    .equals(other.datePlannedStart, datePlannedStart)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.locationSrcId, locationSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcId, locationSrcId)) &&
            (identical(other.locationSrcName, locationSrcName) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcName, locationSrcName)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.notebookId, notebookId) ||
                const DeepCollectionEquality()
                    .equals(other.notebookId, notebookId)) &&
            (identical(other.productionMasterId, productionMasterId) ||
                const DeepCollectionEquality()
                    .equals(other.productionMasterId, productionMasterId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.details, details) ||
                const DeepCollectionEquality().equals(other.details, details)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(datePlannedStart) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(locationSrcId) ^
      const DeepCollectionEquality().hash(locationSrcName) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(notebookId) ^
      const DeepCollectionEquality().hash(productionMasterId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(details) ^
      runtimeType.hashCode;
}

extension $PlanningModelExtension on PlanningModel {
  PlanningModel copyWith(
      {String? id,
      String? name,
      String? state,
      DateTime? datePlannedStart,
      String? objectId,
      String? unitId,
      String? objectName,
      String? objectType,
      double? quantity,
      String? locationSrcId,
      String? locationSrcName,
      String? description,
      String? notebookId,
      String? productionMasterId,
      List<MetadataValue>? metadataContentObjs,
      List<ProductionWorkOrderPlanningModel>? details}) {
    return PlanningModel(
        id: id ?? this.id,
        name: name ?? this.name,
        state: state ?? this.state,
        datePlannedStart: datePlannedStart ?? this.datePlannedStart,
        objectId: objectId ?? this.objectId,
        unitId: unitId ?? this.unitId,
        objectName: objectName ?? this.objectName,
        objectType: objectType ?? this.objectType,
        quantity: quantity ?? this.quantity,
        locationSrcId: locationSrcId ?? this.locationSrcId,
        locationSrcName: locationSrcName ?? this.locationSrcName,
        description: description ?? this.description,
        notebookId: notebookId ?? this.notebookId,
        productionMasterId: productionMasterId ?? this.productionMasterId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        details: details ?? this.details);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanningModelOldResponseList {
  PlanningModelOldResponseList({
    this.data,
    this.totalCount,
    this.dataCount,
    this.status,
    this.salaryCount,
    this.message,
  });

  factory PlanningModelOldResponseList.fromJson(Map<String, dynamic> json) =>
      _$PlanningModelOldResponseListFromJson(json);

  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <PlanningModel>[])
  final List<PlanningModel>? data;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'dataCount', includeIfNull: false)
  final int? dataCount;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'salaryCount', includeIfNull: false)
  final double? salaryCount;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  static const fromJsonFactory = _$PlanningModelOldResponseListFromJson;
  static const toJsonFactory = _$PlanningModelOldResponseListToJson;
  Map<String, dynamic> toJson() => _$PlanningModelOldResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanningModelOldResponseList &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.dataCount, dataCount) ||
                const DeepCollectionEquality()
                    .equals(other.dataCount, dataCount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.salaryCount, salaryCount) ||
                const DeepCollectionEquality()
                    .equals(other.salaryCount, salaryCount)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(dataCount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(salaryCount) ^
      const DeepCollectionEquality().hash(message) ^
      runtimeType.hashCode;
}

extension $PlanningModelOldResponseListExtension
    on PlanningModelOldResponseList {
  PlanningModelOldResponseList copyWith(
      {List<PlanningModel>? data,
      int? totalCount,
      int? dataCount,
      int? status,
      double? salaryCount,
      String? message}) {
    return PlanningModelOldResponseList(
        data: data ?? this.data,
        totalCount: totalCount ?? this.totalCount,
        dataCount: dataCount ?? this.dataCount,
        status: status ?? this.status,
        salaryCount: salaryCount ?? this.salaryCount,
        message: message ?? this.message);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanningModelOldResponseListResponseObject {
  PlanningModelOldResponseListResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory PlanningModelOldResponseListResponseObject.fromJson(
          Map<String, dynamic> json) =>
      _$PlanningModelOldResponseListResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final PlanningModelOldResponseList? data;
  static const fromJsonFactory =
      _$PlanningModelOldResponseListResponseObjectFromJson;
  static const toJsonFactory =
      _$PlanningModelOldResponseListResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$PlanningModelOldResponseListResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanningModelOldResponseListResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $PlanningModelOldResponseListResponseObjectExtension
    on PlanningModelOldResponseListResponseObject {
  PlanningModelOldResponseListResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      PlanningModelOldResponseList? data}) {
    return PlanningModelOldResponseListResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanningModelResponseObject {
  PlanningModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory PlanningModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$PlanningModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final PlanningModel? data;
  static const fromJsonFactory = _$PlanningModelResponseObjectFromJson;
  static const toJsonFactory = _$PlanningModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$PlanningModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanningModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $PlanningModelResponseObjectExtension on PlanningModelResponseObject {
  PlanningModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      PlanningModel? data}) {
    return PlanningModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanningResponseListModel {
  PlanningResponseListModel({
    this.productionMasterModel,
    this.laborProtectionAllocation,
  });

  factory PlanningResponseListModel.fromJson(Map<String, dynamic> json) =>
      _$PlanningResponseListModelFromJson(json);

  @JsonKey(name: 'productionMasterModel', includeIfNull: false)
  final ProductionMasterModel? productionMasterModel;
  @JsonKey(
      name: 'laborProtectionAllocation',
      includeIfNull: false,
      defaultValue: <LaborProtectionAllocation>[])
  final List<LaborProtectionAllocation>? laborProtectionAllocation;
  static const fromJsonFactory = _$PlanningResponseListModelFromJson;
  static const toJsonFactory = _$PlanningResponseListModelToJson;
  Map<String, dynamic> toJson() => _$PlanningResponseListModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanningResponseListModel &&
            (identical(other.productionMasterModel, productionMasterModel) ||
                const DeepCollectionEquality().equals(
                    other.productionMasterModel, productionMasterModel)) &&
            (identical(other.laborProtectionAllocation,
                    laborProtectionAllocation) ||
                const DeepCollectionEquality().equals(
                    other.laborProtectionAllocation,
                    laborProtectionAllocation)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(productionMasterModel) ^
      const DeepCollectionEquality().hash(laborProtectionAllocation) ^
      runtimeType.hashCode;
}

extension $PlanningResponseListModelExtension on PlanningResponseListModel {
  PlanningResponseListModel copyWith(
      {ProductionMasterModel? productionMasterModel,
      List<LaborProtectionAllocation>? laborProtectionAllocation}) {
    return PlanningResponseListModel(
        productionMasterModel:
            productionMasterModel ?? this.productionMasterModel,
        laborProtectionAllocation:
            laborProtectionAllocation ?? this.laborProtectionAllocation);
  }
}

@JsonSerializable(explicitToJson: true)
class PlanningResponseListModelResponseObject {
  PlanningResponseListModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory PlanningResponseListModelResponseObject.fromJson(
          Map<String, dynamic> json) =>
      _$PlanningResponseListModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final PlanningResponseListModel? data;
  static const fromJsonFactory =
      _$PlanningResponseListModelResponseObjectFromJson;
  static const toJsonFactory = _$PlanningResponseListModelResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$PlanningResponseListModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlanningResponseListModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $PlanningResponseListModelResponseObjectExtension
    on PlanningResponseListModelResponseObject {
  PlanningResponseListModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      PlanningResponseListModel? data}) {
    return PlanningResponseListModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class Production {
  Production({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.name,
    this.origin,
    this.originDetailId,
    this.objectId,
    this.objectName,
    this.objectType,
    this.quantity,
    this.unitId,
    this.unitName,
    this.pickingTypeId,
    this.locationSrcId,
    this.locationSrcName,
    this.locationDestId,
    this.locationDestName,
    this.datePlannedStart,
    this.datePlannedFinished,
    this.dateStart,
    this.dateFinished,
    this.bomId,
    this.bomTempId,
    this.deXe,
    this.routingId,
    this.routingName,
    this.state,
    this.availability,
    this.userId,
    this.companyId,
    this.companyName,
    this.procurementGroupId,
    this.propagate,
    this.order,
    this.isLocked,
    this.productIndustry,
    this.description,
    this.productionMasterId,
  });

  factory Production.fromJson(Map<String, dynamic> json) =>
      _$ProductionFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'origin', includeIfNull: false)
  final String? origin;
  @JsonKey(name: 'originDetailId', includeIfNull: false)
  final String? originDetailId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'unitName', includeIfNull: false)
  final String? unitName;
  @JsonKey(name: 'pickingTypeId', includeIfNull: false)
  final String? pickingTypeId;
  @JsonKey(name: 'locationSrcId', includeIfNull: false)
  final String? locationSrcId;
  @JsonKey(name: 'locationSrcName', includeIfNull: false)
  final String? locationSrcName;
  @JsonKey(name: 'locationDestId', includeIfNull: false)
  final String? locationDestId;
  @JsonKey(name: 'locationDestName', includeIfNull: false)
  final String? locationDestName;
  @JsonKey(name: 'datePlannedStart', includeIfNull: false)
  final DateTime? datePlannedStart;
  @JsonKey(name: 'datePlannedFinished', includeIfNull: false)
  final DateTime? datePlannedFinished;
  @JsonKey(name: 'dateStart', includeIfNull: false)
  final DateTime? dateStart;
  @JsonKey(name: 'dateFinished', includeIfNull: false)
  final DateTime? dateFinished;
  @JsonKey(name: 'bomId', includeIfNull: false)
  final String? bomId;
  @JsonKey(name: 'bomTempId', includeIfNull: false)
  final String? bomTempId;
  @JsonKey(name: 'deXe', includeIfNull: false)
  final double? deXe;
  @JsonKey(name: 'routingId', includeIfNull: false)
  final String? routingId;
  @JsonKey(name: 'routingName', includeIfNull: false)
  final String? routingName;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(name: 'availability', includeIfNull: false)
  final String? availability;
  @JsonKey(name: 'userId', includeIfNull: false)
  final String? userId;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  @JsonKey(name: 'companyName', includeIfNull: false)
  final String? companyName;
  @JsonKey(name: 'procurementGroupId', includeIfNull: false)
  final String? procurementGroupId;
  @JsonKey(name: 'propagate', includeIfNull: false)
  final bool? propagate;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isLocked', includeIfNull: false)
  final bool? isLocked;
  @JsonKey(name: 'productIndustry', includeIfNull: false)
  final String? productIndustry;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'productionMasterId', includeIfNull: false)
  final String? productionMasterId;
  static const fromJsonFactory = _$ProductionFromJson;
  static const toJsonFactory = _$ProductionToJson;
  Map<String, dynamic> toJson() => _$ProductionToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Production &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.origin, origin) ||
                const DeepCollectionEquality().equals(other.origin, origin)) &&
            (identical(other.originDetailId, originDetailId) ||
                const DeepCollectionEquality()
                    .equals(other.originDetailId, originDetailId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unitName, unitName) ||
                const DeepCollectionEquality()
                    .equals(other.unitName, unitName)) &&
            (identical(other.pickingTypeId, pickingTypeId) ||
                const DeepCollectionEquality()
                    .equals(other.pickingTypeId, pickingTypeId)) &&
            (identical(other.locationSrcId, locationSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcId, locationSrcId)) &&
            (identical(other.locationSrcName, locationSrcName) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcName, locationSrcName)) &&
            (identical(other.locationDestId, locationDestId) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestId, locationDestId)) &&
            (identical(other.locationDestName, locationDestName) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestName, locationDestName)) &&
            (identical(other.datePlannedStart, datePlannedStart) ||
                const DeepCollectionEquality().equals(other.datePlannedStart, datePlannedStart)) &&
            (identical(other.datePlannedFinished, datePlannedFinished) || const DeepCollectionEquality().equals(other.datePlannedFinished, datePlannedFinished)) &&
            (identical(other.dateStart, dateStart) || const DeepCollectionEquality().equals(other.dateStart, dateStart)) &&
            (identical(other.dateFinished, dateFinished) || const DeepCollectionEquality().equals(other.dateFinished, dateFinished)) &&
            (identical(other.bomId, bomId) || const DeepCollectionEquality().equals(other.bomId, bomId)) &&
            (identical(other.bomTempId, bomTempId) || const DeepCollectionEquality().equals(other.bomTempId, bomTempId)) &&
            (identical(other.deXe, deXe) || const DeepCollectionEquality().equals(other.deXe, deXe)) &&
            (identical(other.routingId, routingId) || const DeepCollectionEquality().equals(other.routingId, routingId)) &&
            (identical(other.routingName, routingName) || const DeepCollectionEquality().equals(other.routingName, routingName)) &&
            (identical(other.state, state) || const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.availability, availability) || const DeepCollectionEquality().equals(other.availability, availability)) &&
            (identical(other.userId, userId) || const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.companyId, companyId) || const DeepCollectionEquality().equals(other.companyId, companyId)) &&
            (identical(other.companyName, companyName) || const DeepCollectionEquality().equals(other.companyName, companyName)) &&
            (identical(other.procurementGroupId, procurementGroupId) || const DeepCollectionEquality().equals(other.procurementGroupId, procurementGroupId)) &&
            (identical(other.propagate, propagate) || const DeepCollectionEquality().equals(other.propagate, propagate)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isLocked, isLocked) || const DeepCollectionEquality().equals(other.isLocked, isLocked)) &&
            (identical(other.productIndustry, productIndustry) || const DeepCollectionEquality().equals(other.productIndustry, productIndustry)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.productionMasterId, productionMasterId) || const DeepCollectionEquality().equals(other.productionMasterId, productionMasterId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(origin) ^
      const DeepCollectionEquality().hash(originDetailId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unitName) ^
      const DeepCollectionEquality().hash(pickingTypeId) ^
      const DeepCollectionEquality().hash(locationSrcId) ^
      const DeepCollectionEquality().hash(locationSrcName) ^
      const DeepCollectionEquality().hash(locationDestId) ^
      const DeepCollectionEquality().hash(locationDestName) ^
      const DeepCollectionEquality().hash(datePlannedStart) ^
      const DeepCollectionEquality().hash(datePlannedFinished) ^
      const DeepCollectionEquality().hash(dateStart) ^
      const DeepCollectionEquality().hash(dateFinished) ^
      const DeepCollectionEquality().hash(bomId) ^
      const DeepCollectionEquality().hash(bomTempId) ^
      const DeepCollectionEquality().hash(deXe) ^
      const DeepCollectionEquality().hash(routingId) ^
      const DeepCollectionEquality().hash(routingName) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(availability) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(companyId) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(procurementGroupId) ^
      const DeepCollectionEquality().hash(propagate) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isLocked) ^
      const DeepCollectionEquality().hash(productIndustry) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(productionMasterId) ^
      runtimeType.hashCode;
}

extension $ProductionExtension on Production {
  Production copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? name,
      String? origin,
      String? originDetailId,
      String? objectId,
      String? objectName,
      String? objectType,
      double? quantity,
      String? unitId,
      String? unitName,
      String? pickingTypeId,
      String? locationSrcId,
      String? locationSrcName,
      String? locationDestId,
      String? locationDestName,
      DateTime? datePlannedStart,
      DateTime? datePlannedFinished,
      DateTime? dateStart,
      DateTime? dateFinished,
      String? bomId,
      String? bomTempId,
      double? deXe,
      String? routingId,
      String? routingName,
      String? state,
      String? availability,
      String? userId,
      String? companyId,
      String? companyName,
      String? procurementGroupId,
      bool? propagate,
      int? order,
      bool? isLocked,
      String? productIndustry,
      String? description,
      String? productionMasterId}) {
    return Production(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        name: name ?? this.name,
        origin: origin ?? this.origin,
        originDetailId: originDetailId ?? this.originDetailId,
        objectId: objectId ?? this.objectId,
        objectName: objectName ?? this.objectName,
        objectType: objectType ?? this.objectType,
        quantity: quantity ?? this.quantity,
        unitId: unitId ?? this.unitId,
        unitName: unitName ?? this.unitName,
        pickingTypeId: pickingTypeId ?? this.pickingTypeId,
        locationSrcId: locationSrcId ?? this.locationSrcId,
        locationSrcName: locationSrcName ?? this.locationSrcName,
        locationDestId: locationDestId ?? this.locationDestId,
        locationDestName: locationDestName ?? this.locationDestName,
        datePlannedStart: datePlannedStart ?? this.datePlannedStart,
        datePlannedFinished: datePlannedFinished ?? this.datePlannedFinished,
        dateStart: dateStart ?? this.dateStart,
        dateFinished: dateFinished ?? this.dateFinished,
        bomId: bomId ?? this.bomId,
        bomTempId: bomTempId ?? this.bomTempId,
        deXe: deXe ?? this.deXe,
        routingId: routingId ?? this.routingId,
        routingName: routingName ?? this.routingName,
        state: state ?? this.state,
        availability: availability ?? this.availability,
        userId: userId ?? this.userId,
        companyId: companyId ?? this.companyId,
        companyName: companyName ?? this.companyName,
        procurementGroupId: procurementGroupId ?? this.procurementGroupId,
        propagate: propagate ?? this.propagate,
        order: order ?? this.order,
        isLocked: isLocked ?? this.isLocked,
        productIndustry: productIndustry ?? this.productIndustry,
        description: description ?? this.description,
        productionMasterId: productionMasterId ?? this.productionMasterId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductionDetail {
  ProductionDetail({
    this.locationId,
    this.locationName,
    this.state,
    this.detailLocations,
  });

  factory ProductionDetail.fromJson(Map<String, dynamic> json) =>
      _$ProductionDetailFromJson(json);

  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(
      name: 'detailLocations',
      includeIfNull: false,
      defaultValue: <DetailLocation>[])
  final List<DetailLocation>? detailLocations;
  static const fromJsonFactory = _$ProductionDetailFromJson;
  static const toJsonFactory = _$ProductionDetailToJson;
  Map<String, dynamic> toJson() => _$ProductionDetailToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductionDetail &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.detailLocations, detailLocations) ||
                const DeepCollectionEquality()
                    .equals(other.detailLocations, detailLocations)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(detailLocations) ^
      runtimeType.hashCode;
}

extension $ProductionDetailExtension on ProductionDetail {
  ProductionDetail copyWith(
      {String? locationId,
      String? locationName,
      String? state,
      List<DetailLocation>? detailLocations}) {
    return ProductionDetail(
        locationId: locationId ?? this.locationId,
        locationName: locationName ?? this.locationName,
        state: state ?? this.state,
        detailLocations: detailLocations ?? this.detailLocations);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductionMaster {
  ProductionMaster({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.code,
    this.name,
    this.timeOfPlan,
    this.state,
    this.sumOfPlanning,
    this.sumOfPlanned,
    this.sumOfDraft,
    this.version,
    this.workflowState,
    this.workflowStatus,
    this.sumOfPlannedGroup,
    this.sumOfDraftGroup,
    this.sumOfPlanningGroup,
  });

  factory ProductionMaster.fromJson(Map<String, dynamic> json) =>
      _$ProductionMasterFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'timeOfPlan', includeIfNull: false)
  final DateTime? timeOfPlan;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(name: 'sumOfPlanning', includeIfNull: false)
  final double? sumOfPlanning;
  @JsonKey(name: 'sumOfPlanned', includeIfNull: false)
  final double? sumOfPlanned;
  @JsonKey(name: 'sumOfDraft', includeIfNull: false)
  final double? sumOfDraft;
  @JsonKey(name: 'version', includeIfNull: false)
  final int? version;
  @JsonKey(name: 'workflowState', includeIfNull: false)
  final String? workflowState;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final String? workflowStatus;
  @JsonKey(name: 'sumOfPlannedGroup', includeIfNull: false)
  final double? sumOfPlannedGroup;
  @JsonKey(name: 'sumOfDraftGroup', includeIfNull: false)
  final double? sumOfDraftGroup;
  @JsonKey(name: 'sumOfPlanningGroup', includeIfNull: false)
  final double? sumOfPlanningGroup;
  static const fromJsonFactory = _$ProductionMasterFromJson;
  static const toJsonFactory = _$ProductionMasterToJson;
  Map<String, dynamic> toJson() => _$ProductionMasterToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductionMaster &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.timeOfPlan, timeOfPlan) ||
                const DeepCollectionEquality()
                    .equals(other.timeOfPlan, timeOfPlan)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.sumOfPlanning, sumOfPlanning) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfPlanning, sumOfPlanning)) &&
            (identical(other.sumOfPlanned, sumOfPlanned) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfPlanned, sumOfPlanned)) &&
            (identical(other.sumOfDraft, sumOfDraft) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfDraft, sumOfDraft)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.workflowState, workflowState) ||
                const DeepCollectionEquality()
                    .equals(other.workflowState, workflowState)) &&
            (identical(other.workflowStatus, workflowStatus) ||
                const DeepCollectionEquality()
                    .equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.sumOfPlannedGroup, sumOfPlannedGroup) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfPlannedGroup, sumOfPlannedGroup)) &&
            (identical(other.sumOfDraftGroup, sumOfDraftGroup) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfDraftGroup, sumOfDraftGroup)) &&
            (identical(other.sumOfPlanningGroup, sumOfPlanningGroup) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfPlanningGroup, sumOfPlanningGroup)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(timeOfPlan) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(sumOfPlanning) ^
      const DeepCollectionEquality().hash(sumOfPlanned) ^
      const DeepCollectionEquality().hash(sumOfDraft) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(workflowState) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(sumOfPlannedGroup) ^
      const DeepCollectionEquality().hash(sumOfDraftGroup) ^
      const DeepCollectionEquality().hash(sumOfPlanningGroup) ^
      runtimeType.hashCode;
}

extension $ProductionMasterExtension on ProductionMaster {
  ProductionMaster copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? code,
      String? name,
      DateTime? timeOfPlan,
      String? state,
      double? sumOfPlanning,
      double? sumOfPlanned,
      double? sumOfDraft,
      int? version,
      String? workflowState,
      String? workflowStatus,
      double? sumOfPlannedGroup,
      double? sumOfDraftGroup,
      double? sumOfPlanningGroup}) {
    return ProductionMaster(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        code: code ?? this.code,
        name: name ?? this.name,
        timeOfPlan: timeOfPlan ?? this.timeOfPlan,
        state: state ?? this.state,
        sumOfPlanning: sumOfPlanning ?? this.sumOfPlanning,
        sumOfPlanned: sumOfPlanned ?? this.sumOfPlanned,
        sumOfDraft: sumOfDraft ?? this.sumOfDraft,
        version: version ?? this.version,
        workflowState: workflowState ?? this.workflowState,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        sumOfPlannedGroup: sumOfPlannedGroup ?? this.sumOfPlannedGroup,
        sumOfDraftGroup: sumOfDraftGroup ?? this.sumOfDraftGroup,
        sumOfPlanningGroup: sumOfPlanningGroup ?? this.sumOfPlanningGroup);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductionMasterModel {
  ProductionMasterModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.code,
    this.name,
    this.timeOfPlan,
    this.sumOfPlanning,
    this.sumOfPlanned,
    this.sumOfDraft,
    this.version,
    this.workflowState,
    this.workflowStatus,
    this.sumOfPlannedGroup,
    this.sumOfDraftGroup,
    this.sumOfPlanningGroup,
    this.productionDetails,
  });

  factory ProductionMasterModel.fromJson(Map<String, dynamic> json) =>
      _$ProductionMasterModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'timeOfPlan', includeIfNull: false)
  final DateTime? timeOfPlan;
  @JsonKey(name: 'sumOfPlanning', includeIfNull: false)
  final double? sumOfPlanning;
  @JsonKey(name: 'sumOfPlanned', includeIfNull: false)
  final double? sumOfPlanned;
  @JsonKey(name: 'sumOfDraft', includeIfNull: false)
  final double? sumOfDraft;
  @JsonKey(name: 'version', includeIfNull: false)
  final int? version;
  @JsonKey(name: 'workflowState', includeIfNull: false)
  final String? workflowState;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final String? workflowStatus;
  @JsonKey(name: 'sumOfPlannedGroup', includeIfNull: false)
  final double? sumOfPlannedGroup;
  @JsonKey(name: 'sumOfDraftGroup', includeIfNull: false)
  final double? sumOfDraftGroup;
  @JsonKey(name: 'sumOfPlanningGroup', includeIfNull: false)
  final double? sumOfPlanningGroup;
  @JsonKey(
      name: 'productionDetails',
      includeIfNull: false,
      defaultValue: <ProductionDetail>[])
  final List<ProductionDetail>? productionDetails;
  static const fromJsonFactory = _$ProductionMasterModelFromJson;
  static const toJsonFactory = _$ProductionMasterModelToJson;
  Map<String, dynamic> toJson() => _$ProductionMasterModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductionMasterModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.timeOfPlan, timeOfPlan) ||
                const DeepCollectionEquality()
                    .equals(other.timeOfPlan, timeOfPlan)) &&
            (identical(other.sumOfPlanning, sumOfPlanning) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfPlanning, sumOfPlanning)) &&
            (identical(other.sumOfPlanned, sumOfPlanned) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfPlanned, sumOfPlanned)) &&
            (identical(other.sumOfDraft, sumOfDraft) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfDraft, sumOfDraft)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.workflowState, workflowState) ||
                const DeepCollectionEquality()
                    .equals(other.workflowState, workflowState)) &&
            (identical(other.workflowStatus, workflowStatus) ||
                const DeepCollectionEquality()
                    .equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.sumOfPlannedGroup, sumOfPlannedGroup) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfPlannedGroup, sumOfPlannedGroup)) &&
            (identical(other.sumOfDraftGroup, sumOfDraftGroup) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfDraftGroup, sumOfDraftGroup)) &&
            (identical(other.sumOfPlanningGroup, sumOfPlanningGroup) ||
                const DeepCollectionEquality()
                    .equals(other.sumOfPlanningGroup, sumOfPlanningGroup)) &&
            (identical(other.productionDetails, productionDetails) ||
                const DeepCollectionEquality()
                    .equals(other.productionDetails, productionDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(timeOfPlan) ^
      const DeepCollectionEquality().hash(sumOfPlanning) ^
      const DeepCollectionEquality().hash(sumOfPlanned) ^
      const DeepCollectionEquality().hash(sumOfDraft) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(workflowState) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(sumOfPlannedGroup) ^
      const DeepCollectionEquality().hash(sumOfDraftGroup) ^
      const DeepCollectionEquality().hash(sumOfPlanningGroup) ^
      const DeepCollectionEquality().hash(productionDetails) ^
      runtimeType.hashCode;
}

extension $ProductionMasterModelExtension on ProductionMasterModel {
  ProductionMasterModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? code,
      String? name,
      DateTime? timeOfPlan,
      double? sumOfPlanning,
      double? sumOfPlanned,
      double? sumOfDraft,
      int? version,
      String? workflowState,
      String? workflowStatus,
      double? sumOfPlannedGroup,
      double? sumOfDraftGroup,
      double? sumOfPlanningGroup,
      List<ProductionDetail>? productionDetails}) {
    return ProductionMasterModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        code: code ?? this.code,
        name: name ?? this.name,
        timeOfPlan: timeOfPlan ?? this.timeOfPlan,
        sumOfPlanning: sumOfPlanning ?? this.sumOfPlanning,
        sumOfPlanned: sumOfPlanned ?? this.sumOfPlanned,
        sumOfDraft: sumOfDraft ?? this.sumOfDraft,
        version: version ?? this.version,
        workflowState: workflowState ?? this.workflowState,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        sumOfPlannedGroup: sumOfPlannedGroup ?? this.sumOfPlannedGroup,
        sumOfDraftGroup: sumOfDraftGroup ?? this.sumOfDraftGroup,
        sumOfPlanningGroup: sumOfPlanningGroup ?? this.sumOfPlanningGroup,
        productionDetails: productionDetails ?? this.productionDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductionMasterResponseObject {
  ProductionMasterResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ProductionMasterResponseObject.fromJson(Map<String, dynamic> json) =>
      _$ProductionMasterResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ProductionMaster? data;
  static const fromJsonFactory = _$ProductionMasterResponseObjectFromJson;
  static const toJsonFactory = _$ProductionMasterResponseObjectToJson;
  Map<String, dynamic> toJson() => _$ProductionMasterResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductionMasterResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ProductionMasterResponseObjectExtension
    on ProductionMasterResponseObject {
  ProductionMasterResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ProductionMaster? data}) {
    return ProductionMasterResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductionPagination {
  ProductionPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory ProductionPagination.fromJson(Map<String, dynamic> json) =>
      _$ProductionPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: <Production>[])
  final List<Production>? content;
  static const fromJsonFactory = _$ProductionPaginationFromJson;
  static const toJsonFactory = _$ProductionPaginationToJson;
  Map<String, dynamic> toJson() => _$ProductionPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductionPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $ProductionPaginationExtension on ProductionPagination {
  ProductionPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<Production>? content}) {
    return ProductionPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductionResponseObject {
  ProductionResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ProductionResponseObject.fromJson(Map<String, dynamic> json) =>
      _$ProductionResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final Production? data;
  static const fromJsonFactory = _$ProductionResponseObjectFromJson;
  static const toJsonFactory = _$ProductionResponseObjectToJson;
  Map<String, dynamic> toJson() => _$ProductionResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductionResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ProductionResponseObjectExtension on ProductionResponseObject {
  ProductionResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, Production? data}) {
    return ProductionResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductionResponsePagination {
  ProductionResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ProductionResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$ProductionResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ProductionPagination? data;
  static const fromJsonFactory = _$ProductionResponsePaginationFromJson;
  static const toJsonFactory = _$ProductionResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$ProductionResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductionResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ProductionResponsePaginationExtension
    on ProductionResponsePagination {
  ProductionResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ProductionPagination? data}) {
    return ProductionResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductionWorkOrderPlanningModel {
  ProductionWorkOrderPlanningModel({
    this.id,
    this.name,
    this.workCenterId,
    this.productionId,
    this.objectId,
    this.productionAvailability,
    this.qtyProduced,
    this.qtyProducing,
    this.state,
    this.datePlannedStart,
    this.datePlannedFinished,
    this.dateStart,
    this.dateFinished,
    this.durationExpected,
    this.duration,
    this.durationUnit,
    this.durationPercent,
    this.operationId,
    this.finalLotId,
    this.nextWorkOrderId,
    this.productionDate,
    this.capacity,
    this.machineId,
    this.operatorId,
    this.semiFinishedProductId,
    this.semiFinishedProductUnitId,
    this.qtySemiFinishedProduct,
    this.description,
    this.totalQtyPlanned,
    this.convertToKgResult,
    this.planningDetails,
    this.metadataContentObjs,
  });

  factory ProductionWorkOrderPlanningModel.fromJson(
          Map<String, dynamic> json) =>
      _$ProductionWorkOrderPlanningModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'workCenterId', includeIfNull: false)
  final String? workCenterId;
  @JsonKey(name: 'productionId', includeIfNull: false)
  final String? productionId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'productionAvailability', includeIfNull: false)
  final String? productionAvailability;
  @JsonKey(name: 'qtyProduced', includeIfNull: false)
  final double? qtyProduced;
  @JsonKey(name: 'qtyProducing', includeIfNull: false)
  final double? qtyProducing;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(name: 'datePlannedStart', includeIfNull: false)
  final DateTime? datePlannedStart;
  @JsonKey(name: 'datePlannedFinished', includeIfNull: false)
  final DateTime? datePlannedFinished;
  @JsonKey(name: 'dateStart', includeIfNull: false)
  final DateTime? dateStart;
  @JsonKey(name: 'dateFinished', includeIfNull: false)
  final DateTime? dateFinished;
  @JsonKey(name: 'durationExpected', includeIfNull: false)
  final double? durationExpected;
  @JsonKey(name: 'duration', includeIfNull: false)
  final double? duration;
  @JsonKey(name: 'durationUnit', includeIfNull: false)
  final double? durationUnit;
  @JsonKey(name: 'durationPercent', includeIfNull: false)
  final int? durationPercent;
  @JsonKey(name: 'operationId', includeIfNull: false)
  final String? operationId;
  @JsonKey(name: 'finalLotId', includeIfNull: false)
  final String? finalLotId;
  @JsonKey(name: 'nextWorkOrderId', includeIfNull: false)
  final String? nextWorkOrderId;
  @JsonKey(name: 'productionDate', includeIfNull: false)
  final DateTime? productionDate;
  @JsonKey(name: 'capacity', includeIfNull: false)
  final double? capacity;
  @JsonKey(name: 'machineId', includeIfNull: false)
  final String? machineId;
  @JsonKey(name: 'operatorId', includeIfNull: false)
  final String? operatorId;
  @JsonKey(name: 'semiFinishedProductId', includeIfNull: false)
  final String? semiFinishedProductId;
  @JsonKey(name: 'semiFinishedProductUnitId', includeIfNull: false)
  final String? semiFinishedProductUnitId;
  @JsonKey(name: 'qtySemiFinishedProduct', includeIfNull: false)
  final double? qtySemiFinishedProduct;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'totalQtyPlanned', includeIfNull: false)
  final double? totalQtyPlanned;
  @JsonKey(name: 'convertToKgResult', includeIfNull: false)
  final double? convertToKgResult;
  @JsonKey(
      name: 'planningDetails',
      includeIfNull: false,
      defaultValue: <WorkOrderPlanning>[])
  final List<WorkOrderPlanning>? planningDetails;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  static const fromJsonFactory = _$ProductionWorkOrderPlanningModelFromJson;
  static const toJsonFactory = _$ProductionWorkOrderPlanningModelToJson;
  Map<String, dynamic> toJson() =>
      _$ProductionWorkOrderPlanningModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductionWorkOrderPlanningModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.workCenterId, workCenterId) ||
                const DeepCollectionEquality()
                    .equals(other.workCenterId, workCenterId)) &&
            (identical(other.productionId, productionId) ||
                const DeepCollectionEquality()
                    .equals(other.productionId, productionId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.productionAvailability, productionAvailability) ||
                const DeepCollectionEquality().equals(
                    other.productionAvailability, productionAvailability)) &&
            (identical(other.qtyProduced, qtyProduced) ||
                const DeepCollectionEquality()
                    .equals(other.qtyProduced, qtyProduced)) &&
            (identical(other.qtyProducing, qtyProducing) ||
                const DeepCollectionEquality()
                    .equals(other.qtyProducing, qtyProducing)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.datePlannedStart, datePlannedStart) ||
                const DeepCollectionEquality()
                    .equals(other.datePlannedStart, datePlannedStart)) &&
            (identical(other.datePlannedFinished, datePlannedFinished) ||
                const DeepCollectionEquality()
                    .equals(other.datePlannedFinished, datePlannedFinished)) &&
            (identical(other.dateStart, dateStart) ||
                const DeepCollectionEquality()
                    .equals(other.dateStart, dateStart)) &&
            (identical(other.dateFinished, dateFinished) ||
                const DeepCollectionEquality()
                    .equals(other.dateFinished, dateFinished)) &&
            (identical(other.durationExpected, durationExpected) ||
                const DeepCollectionEquality()
                    .equals(other.durationExpected, durationExpected)) &&
            (identical(other.duration, duration) ||
                const DeepCollectionEquality()
                    .equals(other.duration, duration)) &&
            (identical(other.durationUnit, durationUnit) ||
                const DeepCollectionEquality()
                    .equals(other.durationUnit, durationUnit)) &&
            (identical(other.durationPercent, durationPercent) ||
                const DeepCollectionEquality()
                    .equals(other.durationPercent, durationPercent)) &&
            (identical(other.operationId, operationId) ||
                const DeepCollectionEquality()
                    .equals(other.operationId, operationId)) &&
            (identical(other.finalLotId, finalLotId) ||
                const DeepCollectionEquality()
                    .equals(other.finalLotId, finalLotId)) &&
            (identical(other.nextWorkOrderId, nextWorkOrderId) ||
                const DeepCollectionEquality()
                    .equals(other.nextWorkOrderId, nextWorkOrderId)) &&
            (identical(other.productionDate, productionDate) ||
                const DeepCollectionEquality()
                    .equals(other.productionDate, productionDate)) &&
            (identical(other.capacity, capacity) ||
                const DeepCollectionEquality()
                    .equals(other.capacity, capacity)) &&
            (identical(other.machineId, machineId) ||
                const DeepCollectionEquality()
                    .equals(other.machineId, machineId)) &&
            (identical(other.operatorId, operatorId) || const DeepCollectionEquality().equals(other.operatorId, operatorId)) &&
            (identical(other.semiFinishedProductId, semiFinishedProductId) || const DeepCollectionEquality().equals(other.semiFinishedProductId, semiFinishedProductId)) &&
            (identical(other.semiFinishedProductUnitId, semiFinishedProductUnitId) || const DeepCollectionEquality().equals(other.semiFinishedProductUnitId, semiFinishedProductUnitId)) &&
            (identical(other.qtySemiFinishedProduct, qtySemiFinishedProduct) || const DeepCollectionEquality().equals(other.qtySemiFinishedProduct, qtySemiFinishedProduct)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.totalQtyPlanned, totalQtyPlanned) || const DeepCollectionEquality().equals(other.totalQtyPlanned, totalQtyPlanned)) &&
            (identical(other.convertToKgResult, convertToKgResult) || const DeepCollectionEquality().equals(other.convertToKgResult, convertToKgResult)) &&
            (identical(other.planningDetails, planningDetails) || const DeepCollectionEquality().equals(other.planningDetails, planningDetails)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) || const DeepCollectionEquality().equals(other.metadataContentObjs, metadataContentObjs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(workCenterId) ^
      const DeepCollectionEquality().hash(productionId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(productionAvailability) ^
      const DeepCollectionEquality().hash(qtyProduced) ^
      const DeepCollectionEquality().hash(qtyProducing) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(datePlannedStart) ^
      const DeepCollectionEquality().hash(datePlannedFinished) ^
      const DeepCollectionEquality().hash(dateStart) ^
      const DeepCollectionEquality().hash(dateFinished) ^
      const DeepCollectionEquality().hash(durationExpected) ^
      const DeepCollectionEquality().hash(duration) ^
      const DeepCollectionEquality().hash(durationUnit) ^
      const DeepCollectionEquality().hash(durationPercent) ^
      const DeepCollectionEquality().hash(operationId) ^
      const DeepCollectionEquality().hash(finalLotId) ^
      const DeepCollectionEquality().hash(nextWorkOrderId) ^
      const DeepCollectionEquality().hash(productionDate) ^
      const DeepCollectionEquality().hash(capacity) ^
      const DeepCollectionEquality().hash(machineId) ^
      const DeepCollectionEquality().hash(operatorId) ^
      const DeepCollectionEquality().hash(semiFinishedProductId) ^
      const DeepCollectionEquality().hash(semiFinishedProductUnitId) ^
      const DeepCollectionEquality().hash(qtySemiFinishedProduct) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(totalQtyPlanned) ^
      const DeepCollectionEquality().hash(convertToKgResult) ^
      const DeepCollectionEquality().hash(planningDetails) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      runtimeType.hashCode;
}

extension $ProductionWorkOrderPlanningModelExtension
    on ProductionWorkOrderPlanningModel {
  ProductionWorkOrderPlanningModel copyWith(
      {String? id,
      String? name,
      String? workCenterId,
      String? productionId,
      String? objectId,
      String? productionAvailability,
      double? qtyProduced,
      double? qtyProducing,
      String? state,
      DateTime? datePlannedStart,
      DateTime? datePlannedFinished,
      DateTime? dateStart,
      DateTime? dateFinished,
      double? durationExpected,
      double? duration,
      double? durationUnit,
      int? durationPercent,
      String? operationId,
      String? finalLotId,
      String? nextWorkOrderId,
      DateTime? productionDate,
      double? capacity,
      String? machineId,
      String? operatorId,
      String? semiFinishedProductId,
      String? semiFinishedProductUnitId,
      double? qtySemiFinishedProduct,
      String? description,
      double? totalQtyPlanned,
      double? convertToKgResult,
      List<WorkOrderPlanning>? planningDetails,
      List<MetadataValue>? metadataContentObjs}) {
    return ProductionWorkOrderPlanningModel(
        id: id ?? this.id,
        name: name ?? this.name,
        workCenterId: workCenterId ?? this.workCenterId,
        productionId: productionId ?? this.productionId,
        objectId: objectId ?? this.objectId,
        productionAvailability:
            productionAvailability ?? this.productionAvailability,
        qtyProduced: qtyProduced ?? this.qtyProduced,
        qtyProducing: qtyProducing ?? this.qtyProducing,
        state: state ?? this.state,
        datePlannedStart: datePlannedStart ?? this.datePlannedStart,
        datePlannedFinished: datePlannedFinished ?? this.datePlannedFinished,
        dateStart: dateStart ?? this.dateStart,
        dateFinished: dateFinished ?? this.dateFinished,
        durationExpected: durationExpected ?? this.durationExpected,
        duration: duration ?? this.duration,
        durationUnit: durationUnit ?? this.durationUnit,
        durationPercent: durationPercent ?? this.durationPercent,
        operationId: operationId ?? this.operationId,
        finalLotId: finalLotId ?? this.finalLotId,
        nextWorkOrderId: nextWorkOrderId ?? this.nextWorkOrderId,
        productionDate: productionDate ?? this.productionDate,
        capacity: capacity ?? this.capacity,
        machineId: machineId ?? this.machineId,
        operatorId: operatorId ?? this.operatorId,
        semiFinishedProductId:
            semiFinishedProductId ?? this.semiFinishedProductId,
        semiFinishedProductUnitId:
            semiFinishedProductUnitId ?? this.semiFinishedProductUnitId,
        qtySemiFinishedProduct:
            qtySemiFinishedProduct ?? this.qtySemiFinishedProduct,
        description: description ?? this.description,
        totalQtyPlanned: totalQtyPlanned ?? this.totalQtyPlanned,
        convertToKgResult: convertToKgResult ?? this.convertToKgResult,
        planningDetails: planningDetails ?? this.planningDetails,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectCloneRequestModel {
  ProjectCloneRequestModel({
    this.code,
  });

  factory ProjectCloneRequestModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectCloneRequestModelFromJson(json);

  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  static const fromJsonFactory = _$ProjectCloneRequestModelFromJson;
  static const toJsonFactory = _$ProjectCloneRequestModelToJson;
  Map<String, dynamic> toJson() => _$ProjectCloneRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectCloneRequestModel &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^ runtimeType.hashCode;
}

extension $ProjectCloneRequestModelExtension on ProjectCloneRequestModel {
  ProjectCloneRequestModel copyWith({String? code}) {
    return ProjectCloneRequestModel(code: code ?? this.code);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectPatchResquestModel {
  ProjectPatchResquestModel({
    this.id,
    this.parentId,
    this.code,
    this.name,
    this.description,
    this.order,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.labelsObjs,
    this.priorityObj,
    this.weight,
    this.rank,
    this.statusObj,
    this.managementObj,
    this.ownerObj,
    this.supervisorObj,
    this.coordinatorObj,
    this.assigneeObj,
    this.viewerObj,
    this.metadataContentObjs,
    this.aclObject,
    this.metaContentType,
    this.projectTemplateId,
  });

  factory ProjectPatchResquestModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectPatchResquestModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'priorityObj',
      includeIfNull: false,
      toJson: priorityEnumsToJson,
      fromJson: priorityEnumsFromJson)
  final enums.PriorityEnums? priorityObj;
  @JsonKey(name: 'weight', includeIfNull: false)
  final int? weight;
  @JsonKey(name: 'rank', includeIfNull: false)
  final int? rank;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: pMStatusEnumsToJson,
      fromJson: pMStatusEnumsFromJson)
  final enums.PMStatusEnums? statusObj;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'projectTemplateId', includeIfNull: false)
  final String? projectTemplateId;
  static const fromJsonFactory = _$ProjectPatchResquestModelFromJson;
  static const toJsonFactory = _$ProjectPatchResquestModelToJson;
  Map<String, dynamic> toJson() => _$ProjectPatchResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectPatchResquestModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.fromDate, fromDate) ||
                const DeepCollectionEquality()
                    .equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) ||
                const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) ||
                const DeepCollectionEquality()
                    .equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) ||
                const DeepCollectionEquality()
                    .equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) ||
                const DeepCollectionEquality()
                    .equals(other.actualTime, actualTime)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.priorityObj, priorityObj) ||
                const DeepCollectionEquality()
                    .equals(other.priorityObj, priorityObj)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.statusObj, statusObj) ||
                const DeepCollectionEquality()
                    .equals(other.statusObj, statusObj)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.assigneeObj, assigneeObj) ||
                const DeepCollectionEquality()
                    .equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.viewerObj, viewerObj) ||
                const DeepCollectionEquality()
                    .equals(other.viewerObj, viewerObj)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.aclObject, aclObject) ||
                const DeepCollectionEquality()
                    .equals(other.aclObject, aclObject)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.projectTemplateId, projectTemplateId) || const DeepCollectionEquality().equals(other.projectTemplateId, projectTemplateId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(priorityObj) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(projectTemplateId) ^
      runtimeType.hashCode;
}

extension $ProjectPatchResquestModelExtension on ProjectPatchResquestModel {
  ProjectPatchResquestModel copyWith(
      {String? id,
      String? parentId,
      String? code,
      String? name,
      String? description,
      int? order,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<LabelsObj>? labelsObjs,
      enums.PriorityEnums? priorityObj,
      int? weight,
      int? rank,
      enums.PMStatusEnums? statusObj,
      List<String>? managementObj,
      List<String>? ownerObj,
      List<String>? supervisorObj,
      List<String>? coordinatorObj,
      List<String>? assigneeObj,
      List<String>? viewerObj,
      List<MetadataValue>? metadataContentObjs,
      ACLObject? aclObject,
      String? metaContentType,
      String? projectTemplateId}) {
    return ProjectPatchResquestModel(
        id: id ?? this.id,
        parentId: parentId ?? this.parentId,
        code: code ?? this.code,
        name: name ?? this.name,
        description: description ?? this.description,
        order: order ?? this.order,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        priorityObj: priorityObj ?? this.priorityObj,
        weight: weight ?? this.weight,
        rank: rank ?? this.rank,
        statusObj: statusObj ?? this.statusObj,
        managementObj: managementObj ?? this.managementObj,
        ownerObj: ownerObj ?? this.ownerObj,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        viewerObj: viewerObj ?? this.viewerObj,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        aclObject: aclObject ?? this.aclObject,
        metaContentType: metaContentType ?? this.metaContentType,
        projectTemplateId: projectTemplateId ?? this.projectTemplateId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectResquestModel {
  ProjectResquestModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.acl,
    this.id,
    required this.code,
    required this.name,
    this.description,
    this.parentId,
    this.parentType,
    this.priorityObj,
    this.priority,
    this.weight,
    this.rank,
    this.labelsObjs,
    this.labels,
    this.managementObj,
    this.management,
    this.ownerObj,
    this.owner,
    this.supervisorObj,
    this.supervisor,
    this.coordinatorObj,
    this.coordinator,
    this.assigneeObj,
    this.assignee,
    this.viewerObj,
    this.viewer,
    this.statusObj,
    this.status,
    this.objectId,
    this.objectType,
    this.objectAction,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.allowToModify,
    this.allowToView,
    this.allowToChangeStatus,
    this.allowToModifyCoordinator,
    this.allowToModifyFromDate,
    this.allowToModifyToDate,
    this.allowToModifyFinishDate,
    this.relatedFolderId,
    this.allowToCreateSubTasks,
    this.aclObject,
    this.projectTemplateId,
    this.workflowStatus,
  });

  factory ProjectResquestModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectResquestModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'acl', includeIfNull: false)
  final String? acl;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'code', includeIfNull: false)
  final String code;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentType', includeIfNull: false)
  final String? parentType;
  @JsonKey(
      name: 'priorityObj',
      includeIfNull: false,
      toJson: priorityEnumsToJson,
      fromJson: priorityEnumsFromJson)
  final enums.PriorityEnums? priorityObj;
  @JsonKey(name: 'priority', includeIfNull: false)
  final int? priority;
  @JsonKey(name: 'weight', includeIfNull: false)
  final int? weight;
  @JsonKey(name: 'rank', includeIfNull: false)
  final int? rank;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labels', includeIfNull: false)
  final String? labels;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'management', includeIfNull: false)
  final String? management;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(name: 'owner', includeIfNull: false)
  final String? owner;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(name: 'supervisor', includeIfNull: false)
  final String? supervisor;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'coordinator', includeIfNull: false)
  final String? coordinator;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'assignee', includeIfNull: false)
  final String? assignee;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'viewer', includeIfNull: false)
  final String? viewer;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: pMStatusEnumsToJson,
      fromJson: pMStatusEnumsFromJson)
  final enums.PMStatusEnums? statusObj;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectAction', includeIfNull: false)
  final String? objectAction;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'allowToModify', includeIfNull: false)
  final bool? allowToModify;
  @JsonKey(name: 'allowToView', includeIfNull: false)
  final bool? allowToView;
  @JsonKey(name: 'allowToChangeStatus', includeIfNull: false)
  final bool? allowToChangeStatus;
  @JsonKey(name: 'allowToModifyCoordinator', includeIfNull: false)
  final bool? allowToModifyCoordinator;
  @JsonKey(name: 'allowToModifyFromDate', includeIfNull: false)
  final bool? allowToModifyFromDate;
  @JsonKey(name: 'allowToModifyToDate', includeIfNull: false)
  final bool? allowToModifyToDate;
  @JsonKey(name: 'allowToModifyFinishDate', includeIfNull: false)
  final bool? allowToModifyFinishDate;
  @JsonKey(name: 'relatedFolderId', includeIfNull: false)
  final String? relatedFolderId;
  @JsonKey(name: 'allowToCreateSubTasks', includeIfNull: false)
  final bool? allowToCreateSubTasks;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'projectTemplateId', includeIfNull: false)
  final String? projectTemplateId;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final int? workflowStatus;
  static const fromJsonFactory = _$ProjectResquestModelFromJson;
  static const toJsonFactory = _$ProjectResquestModelToJson;
  Map<String, dynamic> toJson() => _$ProjectResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectResquestModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentType, parentType) ||
                const DeepCollectionEquality()
                    .equals(other.parentType, parentType)) &&
            (identical(other.priorityObj, priorityObj) ||
                const DeepCollectionEquality()
                    .equals(other.priorityObj, priorityObj)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.management, management) ||
                const DeepCollectionEquality()
                    .equals(other.management, management)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.supervisor, supervisor) ||
                const DeepCollectionEquality()
                    .equals(other.supervisor, supervisor)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.coordinator, coordinator) ||
                const DeepCollectionEquality().equals(other.coordinator, coordinator)) &&
            (identical(other.assigneeObj, assigneeObj) || const DeepCollectionEquality().equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.assignee, assignee) || const DeepCollectionEquality().equals(other.assignee, assignee)) &&
            (identical(other.viewerObj, viewerObj) || const DeepCollectionEquality().equals(other.viewerObj, viewerObj)) &&
            (identical(other.viewer, viewer) || const DeepCollectionEquality().equals(other.viewer, viewer)) &&
            (identical(other.statusObj, statusObj) || const DeepCollectionEquality().equals(other.statusObj, statusObj)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.objectId, objectId) || const DeepCollectionEquality().equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) || const DeepCollectionEquality().equals(other.objectType, objectType)) &&
            (identical(other.objectAction, objectAction) || const DeepCollectionEquality().equals(other.objectAction, objectAction)) &&
            (identical(other.fromDate, fromDate) || const DeepCollectionEquality().equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) || const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) || const DeepCollectionEquality().equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) || const DeepCollectionEquality().equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) || const DeepCollectionEquality().equals(other.actualTime, actualTime)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) || const DeepCollectionEquality().equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) || const DeepCollectionEquality().equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) || const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) || const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) || const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.allowToModify, allowToModify) || const DeepCollectionEquality().equals(other.allowToModify, allowToModify)) &&
            (identical(other.allowToView, allowToView) || const DeepCollectionEquality().equals(other.allowToView, allowToView)) &&
            (identical(other.allowToChangeStatus, allowToChangeStatus) || const DeepCollectionEquality().equals(other.allowToChangeStatus, allowToChangeStatus)) &&
            (identical(other.allowToModifyCoordinator, allowToModifyCoordinator) || const DeepCollectionEquality().equals(other.allowToModifyCoordinator, allowToModifyCoordinator)) &&
            (identical(other.allowToModifyFromDate, allowToModifyFromDate) || const DeepCollectionEquality().equals(other.allowToModifyFromDate, allowToModifyFromDate)) &&
            (identical(other.allowToModifyToDate, allowToModifyToDate) || const DeepCollectionEquality().equals(other.allowToModifyToDate, allowToModifyToDate)) &&
            (identical(other.allowToModifyFinishDate, allowToModifyFinishDate) || const DeepCollectionEquality().equals(other.allowToModifyFinishDate, allowToModifyFinishDate)) &&
            (identical(other.relatedFolderId, relatedFolderId) || const DeepCollectionEquality().equals(other.relatedFolderId, relatedFolderId)) &&
            (identical(other.allowToCreateSubTasks, allowToCreateSubTasks) || const DeepCollectionEquality().equals(other.allowToCreateSubTasks, allowToCreateSubTasks)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.projectTemplateId, projectTemplateId) || const DeepCollectionEquality().equals(other.projectTemplateId, projectTemplateId)) &&
            (identical(other.workflowStatus, workflowStatus) || const DeepCollectionEquality().equals(other.workflowStatus, workflowStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentType) ^
      const DeepCollectionEquality().hash(priorityObj) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(management) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(supervisor) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(coordinator) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(viewer) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectAction) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(allowToModify) ^
      const DeepCollectionEquality().hash(allowToView) ^
      const DeepCollectionEquality().hash(allowToChangeStatus) ^
      const DeepCollectionEquality().hash(allowToModifyCoordinator) ^
      const DeepCollectionEquality().hash(allowToModifyFromDate) ^
      const DeepCollectionEquality().hash(allowToModifyToDate) ^
      const DeepCollectionEquality().hash(allowToModifyFinishDate) ^
      const DeepCollectionEquality().hash(relatedFolderId) ^
      const DeepCollectionEquality().hash(allowToCreateSubTasks) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(projectTemplateId) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      runtimeType.hashCode;
}

extension $ProjectResquestModelExtension on ProjectResquestModel {
  ProjectResquestModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? acl,
      String? id,
      String? code,
      String? name,
      String? description,
      String? parentId,
      String? parentType,
      enums.PriorityEnums? priorityObj,
      int? priority,
      int? weight,
      int? rank,
      List<LabelsObj>? labelsObjs,
      String? labels,
      List<String>? managementObj,
      String? management,
      List<String>? ownerObj,
      String? owner,
      List<String>? supervisorObj,
      String? supervisor,
      List<String>? coordinatorObj,
      String? coordinator,
      List<String>? assigneeObj,
      String? assignee,
      List<String>? viewerObj,
      String? viewer,
      enums.PMStatusEnums? statusObj,
      int? status,
      String? objectId,
      String? objectType,
      String? objectAction,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel,
      bool? allowToModify,
      bool? allowToView,
      bool? allowToChangeStatus,
      bool? allowToModifyCoordinator,
      bool? allowToModifyFromDate,
      bool? allowToModifyToDate,
      bool? allowToModifyFinishDate,
      String? relatedFolderId,
      bool? allowToCreateSubTasks,
      ACLObject? aclObject,
      String? projectTemplateId,
      int? workflowStatus}) {
    return ProjectResquestModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        acl: acl ?? this.acl,
        id: id ?? this.id,
        code: code ?? this.code,
        name: name ?? this.name,
        description: description ?? this.description,
        parentId: parentId ?? this.parentId,
        parentType: parentType ?? this.parentType,
        priorityObj: priorityObj ?? this.priorityObj,
        priority: priority ?? this.priority,
        weight: weight ?? this.weight,
        rank: rank ?? this.rank,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labels: labels ?? this.labels,
        managementObj: managementObj ?? this.managementObj,
        management: management ?? this.management,
        ownerObj: ownerObj ?? this.ownerObj,
        owner: owner ?? this.owner,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        supervisor: supervisor ?? this.supervisor,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        coordinator: coordinator ?? this.coordinator,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        assignee: assignee ?? this.assignee,
        viewerObj: viewerObj ?? this.viewerObj,
        viewer: viewer ?? this.viewer,
        statusObj: statusObj ?? this.statusObj,
        status: status ?? this.status,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        objectAction: objectAction ?? this.objectAction,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        allowToModify: allowToModify ?? this.allowToModify,
        allowToView: allowToView ?? this.allowToView,
        allowToChangeStatus: allowToChangeStatus ?? this.allowToChangeStatus,
        allowToModifyCoordinator:
            allowToModifyCoordinator ?? this.allowToModifyCoordinator,
        allowToModifyFromDate:
            allowToModifyFromDate ?? this.allowToModifyFromDate,
        allowToModifyToDate: allowToModifyToDate ?? this.allowToModifyToDate,
        allowToModifyFinishDate:
            allowToModifyFinishDate ?? this.allowToModifyFinishDate,
        relatedFolderId: relatedFolderId ?? this.relatedFolderId,
        allowToCreateSubTasks:
            allowToCreateSubTasks ?? this.allowToCreateSubTasks,
        aclObject: aclObject ?? this.aclObject,
        projectTemplateId: projectTemplateId ?? this.projectTemplateId,
        workflowStatus: workflowStatus ?? this.workflowStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectTaskPlanningCreateModel {
  ProjectTaskPlanningCreateModel({
    this.year,
    this.version,
  });

  factory ProjectTaskPlanningCreateModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectTaskPlanningCreateModelFromJson(json);

  @JsonKey(name: 'year', includeIfNull: false)
  final int? year;
  @JsonKey(name: 'version', includeIfNull: false)
  final int? version;
  static const fromJsonFactory = _$ProjectTaskPlanningCreateModelFromJson;
  static const toJsonFactory = _$ProjectTaskPlanningCreateModelToJson;
  Map<String, dynamic> toJson() => _$ProjectTaskPlanningCreateModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectTaskPlanningCreateModel &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $ProjectTaskPlanningCreateModelExtension
    on ProjectTaskPlanningCreateModel {
  ProjectTaskPlanningCreateModel copyWith({int? year, int? version}) {
    return ProjectTaskPlanningCreateModel(
        year: year ?? this.year, version: version ?? this.version);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectTaskPlanningResponseModel {
  ProjectTaskPlanningResponseModel({
    this.numberProjectsCreated,
    this.numberTasksCreated,
    this.numberTasksUpdated,
  });

  factory ProjectTaskPlanningResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ProjectTaskPlanningResponseModelFromJson(json);

  @JsonKey(name: 'numberProjectsCreated', includeIfNull: false)
  final int? numberProjectsCreated;
  @JsonKey(name: 'numberTasksCreated', includeIfNull: false)
  final int? numberTasksCreated;
  @JsonKey(name: 'numberTasksUpdated', includeIfNull: false)
  final int? numberTasksUpdated;
  static const fromJsonFactory = _$ProjectTaskPlanningResponseModelFromJson;
  static const toJsonFactory = _$ProjectTaskPlanningResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ProjectTaskPlanningResponseModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectTaskPlanningResponseModel &&
            (identical(other.numberProjectsCreated, numberProjectsCreated) ||
                const DeepCollectionEquality().equals(
                    other.numberProjectsCreated, numberProjectsCreated)) &&
            (identical(other.numberTasksCreated, numberTasksCreated) ||
                const DeepCollectionEquality()
                    .equals(other.numberTasksCreated, numberTasksCreated)) &&
            (identical(other.numberTasksUpdated, numberTasksUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.numberTasksUpdated, numberTasksUpdated)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(numberProjectsCreated) ^
      const DeepCollectionEquality().hash(numberTasksCreated) ^
      const DeepCollectionEquality().hash(numberTasksUpdated) ^
      runtimeType.hashCode;
}

extension $ProjectTaskPlanningResponseModelExtension
    on ProjectTaskPlanningResponseModel {
  ProjectTaskPlanningResponseModel copyWith(
      {int? numberProjectsCreated,
      int? numberTasksCreated,
      int? numberTasksUpdated}) {
    return ProjectTaskPlanningResponseModel(
        numberProjectsCreated:
            numberProjectsCreated ?? this.numberProjectsCreated,
        numberTasksCreated: numberTasksCreated ?? this.numberTasksCreated,
        numberTasksUpdated: numberTasksUpdated ?? this.numberTasksUpdated);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectUpdateParentModel {
  ProjectUpdateParentModel({
    this.parentId,
    this.parentType,
  });

  factory ProjectUpdateParentModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectUpdateParentModelFromJson(json);

  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentType', includeIfNull: false)
  final String? parentType;
  static const fromJsonFactory = _$ProjectUpdateParentModelFromJson;
  static const toJsonFactory = _$ProjectUpdateParentModelToJson;
  Map<String, dynamic> toJson() => _$ProjectUpdateParentModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectUpdateParentModel &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentType, parentType) ||
                const DeepCollectionEquality()
                    .equals(other.parentType, parentType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentType) ^
      runtimeType.hashCode;
}

extension $ProjectUpdateParentModelExtension on ProjectUpdateParentModel {
  ProjectUpdateParentModel copyWith({String? parentId, String? parentType}) {
    return ProjectUpdateParentModel(
        parentId: parentId ?? this.parentId,
        parentType: parentType ?? this.parentType);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectViewModel {
  ProjectViewModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.acl,
    this.id,
    required this.code,
    required this.name,
    this.description,
    this.parentId,
    this.parentType,
    this.priorityObj,
    this.priority,
    this.weight,
    this.rank,
    this.labelsObjs,
    this.labels,
    this.managementObj,
    this.management,
    this.ownerObj,
    this.owner,
    this.supervisorObj,
    this.supervisor,
    this.coordinatorObj,
    this.coordinator,
    this.assigneeObj,
    this.assignee,
    this.viewerObj,
    this.viewer,
    this.statusObj,
    this.status,
    this.objectId,
    this.objectType,
    this.objectAction,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.allowToModify,
    this.allowToView,
    this.allowToChangeStatus,
    this.allowToModifyCoordinator,
    this.allowToModifyFromDate,
    this.allowToModifyToDate,
    this.allowToModifyFinishDate,
    this.relatedFolderId,
    this.allowToCreateSubTasks,
    this.aclObject,
    this.projectTemplateId,
    this.workflowStatus,
  });

  factory ProjectViewModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectViewModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'acl', includeIfNull: false)
  final String? acl;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'code', includeIfNull: false)
  final String code;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentType', includeIfNull: false)
  final String? parentType;
  @JsonKey(
      name: 'priorityObj',
      includeIfNull: false,
      toJson: priorityEnumsToJson,
      fromJson: priorityEnumsFromJson)
  final enums.PriorityEnums? priorityObj;
  @JsonKey(name: 'priority', includeIfNull: false)
  final int? priority;
  @JsonKey(name: 'weight', includeIfNull: false)
  final int? weight;
  @JsonKey(name: 'rank', includeIfNull: false)
  final int? rank;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labels', includeIfNull: false)
  final String? labels;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'management', includeIfNull: false)
  final String? management;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(name: 'owner', includeIfNull: false)
  final String? owner;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(name: 'supervisor', includeIfNull: false)
  final String? supervisor;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'coordinator', includeIfNull: false)
  final String? coordinator;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'assignee', includeIfNull: false)
  final String? assignee;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'viewer', includeIfNull: false)
  final String? viewer;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: pMStatusEnumsToJson,
      fromJson: pMStatusEnumsFromJson)
  final enums.PMStatusEnums? statusObj;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectAction', includeIfNull: false)
  final String? objectAction;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'allowToModify', includeIfNull: false)
  final bool? allowToModify;
  @JsonKey(name: 'allowToView', includeIfNull: false)
  final bool? allowToView;
  @JsonKey(name: 'allowToChangeStatus', includeIfNull: false)
  final bool? allowToChangeStatus;
  @JsonKey(name: 'allowToModifyCoordinator', includeIfNull: false)
  final bool? allowToModifyCoordinator;
  @JsonKey(name: 'allowToModifyFromDate', includeIfNull: false)
  final bool? allowToModifyFromDate;
  @JsonKey(name: 'allowToModifyToDate', includeIfNull: false)
  final bool? allowToModifyToDate;
  @JsonKey(name: 'allowToModifyFinishDate', includeIfNull: false)
  final bool? allowToModifyFinishDate;
  @JsonKey(name: 'relatedFolderId', includeIfNull: false)
  final String? relatedFolderId;
  @JsonKey(name: 'allowToCreateSubTasks', includeIfNull: false)
  final bool? allowToCreateSubTasks;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'projectTemplateId', includeIfNull: false)
  final String? projectTemplateId;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final int? workflowStatus;
  static const fromJsonFactory = _$ProjectViewModelFromJson;
  static const toJsonFactory = _$ProjectViewModelToJson;
  Map<String, dynamic> toJson() => _$ProjectViewModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectViewModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentType, parentType) ||
                const DeepCollectionEquality()
                    .equals(other.parentType, parentType)) &&
            (identical(other.priorityObj, priorityObj) ||
                const DeepCollectionEquality()
                    .equals(other.priorityObj, priorityObj)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.management, management) ||
                const DeepCollectionEquality()
                    .equals(other.management, management)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.supervisor, supervisor) ||
                const DeepCollectionEquality()
                    .equals(other.supervisor, supervisor)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.coordinator, coordinator) ||
                const DeepCollectionEquality().equals(other.coordinator, coordinator)) &&
            (identical(other.assigneeObj, assigneeObj) || const DeepCollectionEquality().equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.assignee, assignee) || const DeepCollectionEquality().equals(other.assignee, assignee)) &&
            (identical(other.viewerObj, viewerObj) || const DeepCollectionEquality().equals(other.viewerObj, viewerObj)) &&
            (identical(other.viewer, viewer) || const DeepCollectionEquality().equals(other.viewer, viewer)) &&
            (identical(other.statusObj, statusObj) || const DeepCollectionEquality().equals(other.statusObj, statusObj)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.objectId, objectId) || const DeepCollectionEquality().equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) || const DeepCollectionEquality().equals(other.objectType, objectType)) &&
            (identical(other.objectAction, objectAction) || const DeepCollectionEquality().equals(other.objectAction, objectAction)) &&
            (identical(other.fromDate, fromDate) || const DeepCollectionEquality().equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) || const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) || const DeepCollectionEquality().equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) || const DeepCollectionEquality().equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) || const DeepCollectionEquality().equals(other.actualTime, actualTime)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) || const DeepCollectionEquality().equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) || const DeepCollectionEquality().equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) || const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) || const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) || const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.allowToModify, allowToModify) || const DeepCollectionEquality().equals(other.allowToModify, allowToModify)) &&
            (identical(other.allowToView, allowToView) || const DeepCollectionEquality().equals(other.allowToView, allowToView)) &&
            (identical(other.allowToChangeStatus, allowToChangeStatus) || const DeepCollectionEquality().equals(other.allowToChangeStatus, allowToChangeStatus)) &&
            (identical(other.allowToModifyCoordinator, allowToModifyCoordinator) || const DeepCollectionEquality().equals(other.allowToModifyCoordinator, allowToModifyCoordinator)) &&
            (identical(other.allowToModifyFromDate, allowToModifyFromDate) || const DeepCollectionEquality().equals(other.allowToModifyFromDate, allowToModifyFromDate)) &&
            (identical(other.allowToModifyToDate, allowToModifyToDate) || const DeepCollectionEquality().equals(other.allowToModifyToDate, allowToModifyToDate)) &&
            (identical(other.allowToModifyFinishDate, allowToModifyFinishDate) || const DeepCollectionEquality().equals(other.allowToModifyFinishDate, allowToModifyFinishDate)) &&
            (identical(other.relatedFolderId, relatedFolderId) || const DeepCollectionEquality().equals(other.relatedFolderId, relatedFolderId)) &&
            (identical(other.allowToCreateSubTasks, allowToCreateSubTasks) || const DeepCollectionEquality().equals(other.allowToCreateSubTasks, allowToCreateSubTasks)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.projectTemplateId, projectTemplateId) || const DeepCollectionEquality().equals(other.projectTemplateId, projectTemplateId)) &&
            (identical(other.workflowStatus, workflowStatus) || const DeepCollectionEquality().equals(other.workflowStatus, workflowStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentType) ^
      const DeepCollectionEquality().hash(priorityObj) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(management) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(supervisor) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(coordinator) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(viewer) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectAction) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(allowToModify) ^
      const DeepCollectionEquality().hash(allowToView) ^
      const DeepCollectionEquality().hash(allowToChangeStatus) ^
      const DeepCollectionEquality().hash(allowToModifyCoordinator) ^
      const DeepCollectionEquality().hash(allowToModifyFromDate) ^
      const DeepCollectionEquality().hash(allowToModifyToDate) ^
      const DeepCollectionEquality().hash(allowToModifyFinishDate) ^
      const DeepCollectionEquality().hash(relatedFolderId) ^
      const DeepCollectionEquality().hash(allowToCreateSubTasks) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(projectTemplateId) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      runtimeType.hashCode;
}

extension $ProjectViewModelExtension on ProjectViewModel {
  ProjectViewModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? acl,
      String? id,
      String? code,
      String? name,
      String? description,
      String? parentId,
      String? parentType,
      enums.PriorityEnums? priorityObj,
      int? priority,
      int? weight,
      int? rank,
      List<LabelsObj>? labelsObjs,
      String? labels,
      List<String>? managementObj,
      String? management,
      List<String>? ownerObj,
      String? owner,
      List<String>? supervisorObj,
      String? supervisor,
      List<String>? coordinatorObj,
      String? coordinator,
      List<String>? assigneeObj,
      String? assignee,
      List<String>? viewerObj,
      String? viewer,
      enums.PMStatusEnums? statusObj,
      int? status,
      String? objectId,
      String? objectType,
      String? objectAction,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel,
      bool? allowToModify,
      bool? allowToView,
      bool? allowToChangeStatus,
      bool? allowToModifyCoordinator,
      bool? allowToModifyFromDate,
      bool? allowToModifyToDate,
      bool? allowToModifyFinishDate,
      String? relatedFolderId,
      bool? allowToCreateSubTasks,
      ACLObject? aclObject,
      String? projectTemplateId,
      int? workflowStatus}) {
    return ProjectViewModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        acl: acl ?? this.acl,
        id: id ?? this.id,
        code: code ?? this.code,
        name: name ?? this.name,
        description: description ?? this.description,
        parentId: parentId ?? this.parentId,
        parentType: parentType ?? this.parentType,
        priorityObj: priorityObj ?? this.priorityObj,
        priority: priority ?? this.priority,
        weight: weight ?? this.weight,
        rank: rank ?? this.rank,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labels: labels ?? this.labels,
        managementObj: managementObj ?? this.managementObj,
        management: management ?? this.management,
        ownerObj: ownerObj ?? this.ownerObj,
        owner: owner ?? this.owner,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        supervisor: supervisor ?? this.supervisor,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        coordinator: coordinator ?? this.coordinator,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        assignee: assignee ?? this.assignee,
        viewerObj: viewerObj ?? this.viewerObj,
        viewer: viewer ?? this.viewer,
        statusObj: statusObj ?? this.statusObj,
        status: status ?? this.status,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        objectAction: objectAction ?? this.objectAction,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        allowToModify: allowToModify ?? this.allowToModify,
        allowToView: allowToView ?? this.allowToView,
        allowToChangeStatus: allowToChangeStatus ?? this.allowToChangeStatus,
        allowToModifyCoordinator:
            allowToModifyCoordinator ?? this.allowToModifyCoordinator,
        allowToModifyFromDate:
            allowToModifyFromDate ?? this.allowToModifyFromDate,
        allowToModifyToDate: allowToModifyToDate ?? this.allowToModifyToDate,
        allowToModifyFinishDate:
            allowToModifyFinishDate ?? this.allowToModifyFinishDate,
        relatedFolderId: relatedFolderId ?? this.relatedFolderId,
        allowToCreateSubTasks:
            allowToCreateSubTasks ?? this.allowToCreateSubTasks,
        aclObject: aclObject ?? this.aclObject,
        projectTemplateId: projectTemplateId ?? this.projectTemplateId,
        workflowStatus: workflowStatus ?? this.workflowStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectViewModelPagination {
  ProjectViewModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory ProjectViewModelPagination.fromJson(Map<String, dynamic> json) =>
      _$ProjectViewModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content', includeIfNull: false, defaultValue: <ProjectViewModel>[])
  final List<ProjectViewModel>? content;
  static const fromJsonFactory = _$ProjectViewModelPaginationFromJson;
  static const toJsonFactory = _$ProjectViewModelPaginationToJson;
  Map<String, dynamic> toJson() => _$ProjectViewModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectViewModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $ProjectViewModelPaginationExtension on ProjectViewModelPagination {
  ProjectViewModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<ProjectViewModel>? content}) {
    return ProjectViewModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectViewModelResponseList {
  ProjectViewModelResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ProjectViewModelResponseList.fromJson(Map<String, dynamic> json) =>
      _$ProjectViewModelResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(
      name: 'data', includeIfNull: false, defaultValue: <ProjectViewModel>[])
  final List<ProjectViewModel>? data;
  static const fromJsonFactory = _$ProjectViewModelResponseListFromJson;
  static const toJsonFactory = _$ProjectViewModelResponseListToJson;
  Map<String, dynamic> toJson() => _$ProjectViewModelResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectViewModelResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ProjectViewModelResponseListExtension
    on ProjectViewModelResponseList {
  ProjectViewModelResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<ProjectViewModel>? data}) {
    return ProjectViewModelResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectViewModelResponseObject {
  ProjectViewModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ProjectViewModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$ProjectViewModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ProjectViewModel? data;
  static const fromJsonFactory = _$ProjectViewModelResponseObjectFromJson;
  static const toJsonFactory = _$ProjectViewModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$ProjectViewModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectViewModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ProjectViewModelResponseObjectExtension
    on ProjectViewModelResponseObject {
  ProjectViewModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ProjectViewModel? data}) {
    return ProjectViewModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectViewModelResponsePagination {
  ProjectViewModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ProjectViewModelResponsePagination.fromJson(
          Map<String, dynamic> json) =>
      _$ProjectViewModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ProjectViewModelPagination? data;
  static const fromJsonFactory = _$ProjectViewModelResponsePaginationFromJson;
  static const toJsonFactory = _$ProjectViewModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$ProjectViewModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectViewModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ProjectViewModelResponsePaginationExtension
    on ProjectViewModelResponsePagination {
  ProjectViewModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ProjectViewModelPagination? data}) {
    return ProjectViewModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class QRCodeRequestModel {
  QRCodeRequestModel({
    this.id,
    this.applicationId,
    required this.type,
    this.name,
    this.description,
    this.content,
    this.order,
    this.imageUrl,
    this.metadataContentObjs,
    this.metaContentType,
    this.labelsObjs,
    this.relatedObjs,
    this.isActive,
  });

  factory QRCodeRequestModel.fromJson(Map<String, dynamic> json) =>
      _$QRCodeRequestModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'type', includeIfNull: false)
  final String type;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'content', includeIfNull: false)
  final String? content;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'relatedObjs', includeIfNull: false, defaultValue: <RelatedObj>[])
  final List<RelatedObj>? relatedObjs;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  static const fromJsonFactory = _$QRCodeRequestModelFromJson;
  static const toJsonFactory = _$QRCodeRequestModelToJson;
  Map<String, dynamic> toJson() => _$QRCodeRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is QRCodeRequestModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality()
                    .equals(other.content, content)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.relatedObjs, relatedObjs) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObjs, relatedObjs)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(content) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(relatedObjs) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $QRCodeRequestModelExtension on QRCodeRequestModel {
  QRCodeRequestModel copyWith(
      {String? id,
      String? applicationId,
      String? type,
      String? name,
      String? description,
      String? content,
      int? order,
      String? imageUrl,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      List<LabelsObj>? labelsObjs,
      List<RelatedObj>? relatedObjs,
      bool? isActive}) {
    return QRCodeRequestModel(
        id: id ?? this.id,
        applicationId: applicationId ?? this.applicationId,
        type: type ?? this.type,
        name: name ?? this.name,
        description: description ?? this.description,
        content: content ?? this.content,
        order: order ?? this.order,
        imageUrl: imageUrl ?? this.imageUrl,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        relatedObjs: relatedObjs ?? this.relatedObjs,
        isActive: isActive ?? this.isActive);
  }
}

@JsonSerializable(explicitToJson: true)
class QRResponseModel {
  QRResponseModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    required this.type,
    this.name,
    this.description,
    this.content,
    this.order,
    this.imageUrl,
    this.metadataContentObjs,
    this.metaContentType,
    this.labelsObjs,
    this.relatedObjs,
    this.isActive,
  });

  factory QRResponseModel.fromJson(Map<String, dynamic> json) =>
      _$QRResponseModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'type', includeIfNull: false)
  final String type;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'content', includeIfNull: false)
  final String? content;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'relatedObjs', includeIfNull: false, defaultValue: <RelatedObj>[])
  final List<RelatedObj>? relatedObjs;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  static const fromJsonFactory = _$QRResponseModelFromJson;
  static const toJsonFactory = _$QRResponseModelToJson;
  Map<String, dynamic> toJson() => _$QRResponseModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is QRResponseModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality()
                    .equals(other.content, content)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.relatedObjs, relatedObjs) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObjs, relatedObjs)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(content) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(relatedObjs) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $QRResponseModelExtension on QRResponseModel {
  QRResponseModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? type,
      String? name,
      String? description,
      String? content,
      int? order,
      String? imageUrl,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      List<LabelsObj>? labelsObjs,
      List<RelatedObj>? relatedObjs,
      bool? isActive}) {
    return QRResponseModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        type: type ?? this.type,
        name: name ?? this.name,
        description: description ?? this.description,
        content: content ?? this.content,
        order: order ?? this.order,
        imageUrl: imageUrl ?? this.imageUrl,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        relatedObjs: relatedObjs ?? this.relatedObjs,
        isActive: isActive ?? this.isActive);
  }
}

@JsonSerializable(explicitToJson: true)
class QRResponseModelPagination {
  QRResponseModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory QRResponseModelPagination.fromJson(Map<String, dynamic> json) =>
      _$QRResponseModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content', includeIfNull: false, defaultValue: <QRResponseModel>[])
  final List<QRResponseModel>? content;
  static const fromJsonFactory = _$QRResponseModelPaginationFromJson;
  static const toJsonFactory = _$QRResponseModelPaginationToJson;
  Map<String, dynamic> toJson() => _$QRResponseModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is QRResponseModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $QRResponseModelPaginationExtension on QRResponseModelPagination {
  QRResponseModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<QRResponseModel>? content}) {
    return QRResponseModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class QRResponseModelResponseList {
  QRResponseModelResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory QRResponseModelResponseList.fromJson(Map<String, dynamic> json) =>
      _$QRResponseModelResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(
      name: 'data', includeIfNull: false, defaultValue: <QRResponseModel>[])
  final List<QRResponseModel>? data;
  static const fromJsonFactory = _$QRResponseModelResponseListFromJson;
  static const toJsonFactory = _$QRResponseModelResponseListToJson;
  Map<String, dynamic> toJson() => _$QRResponseModelResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is QRResponseModelResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $QRResponseModelResponseListExtension on QRResponseModelResponseList {
  QRResponseModelResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<QRResponseModel>? data}) {
    return QRResponseModelResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class QRResponseModelResponseObject {
  QRResponseModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory QRResponseModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$QRResponseModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final QRResponseModel? data;
  static const fromJsonFactory = _$QRResponseModelResponseObjectFromJson;
  static const toJsonFactory = _$QRResponseModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$QRResponseModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is QRResponseModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $QRResponseModelResponseObjectExtension
    on QRResponseModelResponseObject {
  QRResponseModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      QRResponseModel? data}) {
    return QRResponseModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class QRResponseModelResponsePagination {
  QRResponseModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory QRResponseModelResponsePagination.fromJson(
          Map<String, dynamic> json) =>
      _$QRResponseModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final QRResponseModelPagination? data;
  static const fromJsonFactory = _$QRResponseModelResponsePaginationFromJson;
  static const toJsonFactory = _$QRResponseModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$QRResponseModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is QRResponseModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $QRResponseModelResponsePaginationExtension
    on QRResponseModelResponsePagination {
  QRResponseModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      QRResponseModelPagination? data}) {
    return QRResponseModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ReCreatePlanningRequestModel {
  ReCreatePlanningRequestModel({
    this.year,
    this.version,
  });

  factory ReCreatePlanningRequestModel.fromJson(Map<String, dynamic> json) =>
      _$ReCreatePlanningRequestModelFromJson(json);

  @JsonKey(name: 'year', includeIfNull: false)
  final int? year;
  @JsonKey(name: 'version', includeIfNull: false)
  final int? version;
  static const fromJsonFactory = _$ReCreatePlanningRequestModelFromJson;
  static const toJsonFactory = _$ReCreatePlanningRequestModelToJson;
  Map<String, dynamic> toJson() => _$ReCreatePlanningRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ReCreatePlanningRequestModel &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(year) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $ReCreatePlanningRequestModelExtension
    on ReCreatePlanningRequestModel {
  ReCreatePlanningRequestModel copyWith({int? year, int? version}) {
    return ReCreatePlanningRequestModel(
        year: year ?? this.year, version: version ?? this.version);
  }
}

@JsonSerializable(explicitToJson: true)
class Reaction {
  Reaction({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.objectId,
    this.objectType,
    this.ref,
    this.theReaction,
    this.icon,
  });

  factory Reaction.fromJson(Map<String, dynamic> json) =>
      _$ReactionFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'ref', includeIfNull: false)
  final String? ref;
  @JsonKey(name: 'theReaction', includeIfNull: false)
  final String? theReaction;
  @JsonKey(name: 'icon', includeIfNull: false)
  final String? icon;
  static const fromJsonFactory = _$ReactionFromJson;
  static const toJsonFactory = _$ReactionToJson;
  Map<String, dynamic> toJson() => _$ReactionToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Reaction &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.ref, ref) ||
                const DeepCollectionEquality().equals(other.ref, ref)) &&
            (identical(other.theReaction, theReaction) ||
                const DeepCollectionEquality()
                    .equals(other.theReaction, theReaction)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(ref) ^
      const DeepCollectionEquality().hash(theReaction) ^
      const DeepCollectionEquality().hash(icon) ^
      runtimeType.hashCode;
}

extension $ReactionExtension on Reaction {
  Reaction copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? objectId,
      String? objectType,
      String? ref,
      String? theReaction,
      String? icon}) {
    return Reaction(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        ref: ref ?? this.ref,
        theReaction: theReaction ?? this.theReaction,
        icon: icon ?? this.icon);
  }
}

@JsonSerializable(explicitToJson: true)
class ReactionPagination {
  ReactionPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory ReactionPagination.fromJson(Map<String, dynamic> json) =>
      _$ReactionPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: <Reaction>[])
  final List<Reaction>? content;
  static const fromJsonFactory = _$ReactionPaginationFromJson;
  static const toJsonFactory = _$ReactionPaginationToJson;
  Map<String, dynamic> toJson() => _$ReactionPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ReactionPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $ReactionPaginationExtension on ReactionPagination {
  ReactionPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<Reaction>? content}) {
    return ReactionPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class ReactionRequestModel {
  ReactionRequestModel({
    this.objectId,
    this.objectType,
    this.ref,
    this.theReaction,
    this.icon,
  });

  factory ReactionRequestModel.fromJson(Map<String, dynamic> json) =>
      _$ReactionRequestModelFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'ref', includeIfNull: false)
  final String? ref;
  @JsonKey(name: 'theReaction', includeIfNull: false)
  final String? theReaction;
  @JsonKey(name: 'icon', includeIfNull: false)
  final String? icon;
  static const fromJsonFactory = _$ReactionRequestModelFromJson;
  static const toJsonFactory = _$ReactionRequestModelToJson;
  Map<String, dynamic> toJson() => _$ReactionRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ReactionRequestModel &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.ref, ref) ||
                const DeepCollectionEquality().equals(other.ref, ref)) &&
            (identical(other.theReaction, theReaction) ||
                const DeepCollectionEquality()
                    .equals(other.theReaction, theReaction)) &&
            (identical(other.icon, icon) ||
                const DeepCollectionEquality().equals(other.icon, icon)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(ref) ^
      const DeepCollectionEquality().hash(theReaction) ^
      const DeepCollectionEquality().hash(icon) ^
      runtimeType.hashCode;
}

extension $ReactionRequestModelExtension on ReactionRequestModel {
  ReactionRequestModel copyWith(
      {String? objectId,
      String? objectType,
      String? ref,
      String? theReaction,
      String? icon}) {
    return ReactionRequestModel(
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        ref: ref ?? this.ref,
        theReaction: theReaction ?? this.theReaction,
        icon: icon ?? this.icon);
  }
}

@JsonSerializable(explicitToJson: true)
class ReactionResponseObject {
  ReactionResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ReactionResponseObject.fromJson(Map<String, dynamic> json) =>
      _$ReactionResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final Reaction? data;
  static const fromJsonFactory = _$ReactionResponseObjectFromJson;
  static const toJsonFactory = _$ReactionResponseObjectToJson;
  Map<String, dynamic> toJson() => _$ReactionResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ReactionResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ReactionResponseObjectExtension on ReactionResponseObject {
  ReactionResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, Reaction? data}) {
    return ReactionResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ReactionResponsePagination {
  ReactionResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ReactionResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$ReactionResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ReactionPagination? data;
  static const fromJsonFactory = _$ReactionResponsePaginationFromJson;
  static const toJsonFactory = _$ReactionResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$ReactionResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ReactionResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ReactionResponsePaginationExtension on ReactionResponsePagination {
  ReactionResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ReactionPagination? data}) {
    return ReactionResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class RelatedObj {
  RelatedObj({
    this.objectId,
    this.objectCode,
    this.objectName,
    this.objectType,
    this.objectKeyword,
    this.objectContent,
  });

  factory RelatedObj.fromJson(Map<String, dynamic> json) =>
      _$RelatedObjFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectCode', includeIfNull: false)
  final String? objectCode;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectKeyword', includeIfNull: false)
  final String? objectKeyword;
  @JsonKey(name: 'objectContent', includeIfNull: false)
  final String? objectContent;
  static const fromJsonFactory = _$RelatedObjFromJson;
  static const toJsonFactory = _$RelatedObjToJson;
  Map<String, dynamic> toJson() => _$RelatedObjToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RelatedObj &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectCode, objectCode) ||
                const DeepCollectionEquality()
                    .equals(other.objectCode, objectCode)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.objectKeyword, objectKeyword) ||
                const DeepCollectionEquality()
                    .equals(other.objectKeyword, objectKeyword)) &&
            (identical(other.objectContent, objectContent) ||
                const DeepCollectionEquality()
                    .equals(other.objectContent, objectContent)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectCode) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectKeyword) ^
      const DeepCollectionEquality().hash(objectContent) ^
      runtimeType.hashCode;
}

extension $RelatedObjExtension on RelatedObj {
  RelatedObj copyWith(
      {String? objectId,
      String? objectCode,
      String? objectName,
      String? objectType,
      String? objectKeyword,
      String? objectContent}) {
    return RelatedObj(
        objectId: objectId ?? this.objectId,
        objectCode: objectCode ?? this.objectCode,
        objectName: objectName ?? this.objectName,
        objectType: objectType ?? this.objectType,
        objectKeyword: objectKeyword ?? this.objectKeyword,
        objectContent: objectContent ?? this.objectContent);
  }
}

@JsonSerializable(explicitToJson: true)
class RelatedObjResponseList {
  RelatedObjResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory RelatedObjResponseList.fromJson(Map<String, dynamic> json) =>
      _$RelatedObjResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <RelatedObj>[])
  final List<RelatedObj>? data;
  static const fromJsonFactory = _$RelatedObjResponseListFromJson;
  static const toJsonFactory = _$RelatedObjResponseListToJson;
  Map<String, dynamic> toJson() => _$RelatedObjResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RelatedObjResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $RelatedObjResponseListExtension on RelatedObjResponseList {
  RelatedObjResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<RelatedObj>? data}) {
    return RelatedObjResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class RelatedTask {
  RelatedTask({
    this.relationType,
    this.task,
    this.note,
  });

  factory RelatedTask.fromJson(Map<String, dynamic> json) =>
      _$RelatedTaskFromJson(json);

  @JsonKey(
      name: 'relationType',
      includeIfNull: false,
      toJson: relationTypeEnumsToJson,
      fromJson: relationTypeEnumsFromJson)
  final enums.RelationTypeEnums? relationType;
  @JsonKey(name: 'task', includeIfNull: false)
  final TaskViewModel? task;
  @JsonKey(name: 'note', includeIfNull: false)
  final String? note;
  static const fromJsonFactory = _$RelatedTaskFromJson;
  static const toJsonFactory = _$RelatedTaskToJson;
  Map<String, dynamic> toJson() => _$RelatedTaskToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RelatedTask &&
            (identical(other.relationType, relationType) ||
                const DeepCollectionEquality()
                    .equals(other.relationType, relationType)) &&
            (identical(other.task, task) ||
                const DeepCollectionEquality().equals(other.task, task)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(relationType) ^
      const DeepCollectionEquality().hash(task) ^
      const DeepCollectionEquality().hash(note) ^
      runtimeType.hashCode;
}

extension $RelatedTaskExtension on RelatedTask {
  RelatedTask copyWith(
      {enums.RelationTypeEnums? relationType,
      TaskViewModel? task,
      String? note}) {
    return RelatedTask(
        relationType: relationType ?? this.relationType,
        task: task ?? this.task,
        note: note ?? this.note);
  }
}

@JsonSerializable(explicitToJson: true)
class ReplaceTreeRequestModel {
  ReplaceTreeRequestModel({
    this.locationId,
    this.locationName,
    this.parentLocationId,
    this.parentLocationName,
    this.parentPath,
    this.referenceId,
    this.referenceName,
    this.objectNameOld,
    this.objectNameNew,
    this.quantityMark,
    this.lotIds,
    this.metadataContentObjs,
    this.productAttributeValueNew,
    this.productAttributeName,
    this.productTmpIdNew,
    this.attributeValueNew,
  });

  factory ReplaceTreeRequestModel.fromJson(Map<String, dynamic> json) =>
      _$ReplaceTreeRequestModelFromJson(json);

  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'parentLocationId', includeIfNull: false)
  final String? parentLocationId;
  @JsonKey(name: 'parentLocationName', includeIfNull: false)
  final String? parentLocationName;
  @JsonKey(name: 'parentPath', includeIfNull: false)
  final String? parentPath;
  @JsonKey(name: 'referenceId', includeIfNull: false)
  final String? referenceId;
  @JsonKey(name: 'referenceName', includeIfNull: false)
  final String? referenceName;
  @JsonKey(name: 'objectNameOld', includeIfNull: false)
  final String? objectNameOld;
  @JsonKey(name: 'objectNameNew', includeIfNull: false)
  final String? objectNameNew;
  @JsonKey(name: 'quantityMark', includeIfNull: false)
  final double? quantityMark;
  @JsonKey(name: 'lotIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? lotIds;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'productAttributeValueNew', includeIfNull: false)
  final String? productAttributeValueNew;
  @JsonKey(name: 'productAttributeName', includeIfNull: false)
  final String? productAttributeName;
  @JsonKey(name: 'productTmpIdNew', includeIfNull: false)
  final String? productTmpIdNew;
  @JsonKey(name: 'attributeValueNew', includeIfNull: false)
  final String? attributeValueNew;
  static const fromJsonFactory = _$ReplaceTreeRequestModelFromJson;
  static const toJsonFactory = _$ReplaceTreeRequestModelToJson;
  Map<String, dynamic> toJson() => _$ReplaceTreeRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ReplaceTreeRequestModel &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.parentLocationId, parentLocationId) ||
                const DeepCollectionEquality()
                    .equals(other.parentLocationId, parentLocationId)) &&
            (identical(other.parentLocationName, parentLocationName) ||
                const DeepCollectionEquality()
                    .equals(other.parentLocationName, parentLocationName)) &&
            (identical(other.parentPath, parentPath) ||
                const DeepCollectionEquality()
                    .equals(other.parentPath, parentPath)) &&
            (identical(other.referenceId, referenceId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceId, referenceId)) &&
            (identical(other.referenceName, referenceName) ||
                const DeepCollectionEquality()
                    .equals(other.referenceName, referenceName)) &&
            (identical(other.objectNameOld, objectNameOld) ||
                const DeepCollectionEquality()
                    .equals(other.objectNameOld, objectNameOld)) &&
            (identical(other.objectNameNew, objectNameNew) ||
                const DeepCollectionEquality()
                    .equals(other.objectNameNew, objectNameNew)) &&
            (identical(other.quantityMark, quantityMark) ||
                const DeepCollectionEquality()
                    .equals(other.quantityMark, quantityMark)) &&
            (identical(other.lotIds, lotIds) ||
                const DeepCollectionEquality().equals(other.lotIds, lotIds)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(
                    other.productAttributeValueNew, productAttributeValueNew) ||
                const DeepCollectionEquality().equals(
                    other.productAttributeValueNew,
                    productAttributeValueNew)) &&
            (identical(other.productAttributeName, productAttributeName) ||
                const DeepCollectionEquality().equals(
                    other.productAttributeName, productAttributeName)) &&
            (identical(other.productTmpIdNew, productTmpIdNew) ||
                const DeepCollectionEquality()
                    .equals(other.productTmpIdNew, productTmpIdNew)) &&
            (identical(other.attributeValueNew, attributeValueNew) ||
                const DeepCollectionEquality()
                    .equals(other.attributeValueNew, attributeValueNew)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(parentLocationId) ^
      const DeepCollectionEquality().hash(parentLocationName) ^
      const DeepCollectionEquality().hash(parentPath) ^
      const DeepCollectionEquality().hash(referenceId) ^
      const DeepCollectionEquality().hash(referenceName) ^
      const DeepCollectionEquality().hash(objectNameOld) ^
      const DeepCollectionEquality().hash(objectNameNew) ^
      const DeepCollectionEquality().hash(quantityMark) ^
      const DeepCollectionEquality().hash(lotIds) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(productAttributeValueNew) ^
      const DeepCollectionEquality().hash(productAttributeName) ^
      const DeepCollectionEquality().hash(productTmpIdNew) ^
      const DeepCollectionEquality().hash(attributeValueNew) ^
      runtimeType.hashCode;
}

extension $ReplaceTreeRequestModelExtension on ReplaceTreeRequestModel {
  ReplaceTreeRequestModel copyWith(
      {String? locationId,
      String? locationName,
      String? parentLocationId,
      String? parentLocationName,
      String? parentPath,
      String? referenceId,
      String? referenceName,
      String? objectNameOld,
      String? objectNameNew,
      double? quantityMark,
      List<String>? lotIds,
      List<MetadataValue>? metadataContentObjs,
      String? productAttributeValueNew,
      String? productAttributeName,
      String? productTmpIdNew,
      String? attributeValueNew}) {
    return ReplaceTreeRequestModel(
        locationId: locationId ?? this.locationId,
        locationName: locationName ?? this.locationName,
        parentLocationId: parentLocationId ?? this.parentLocationId,
        parentLocationName: parentLocationName ?? this.parentLocationName,
        parentPath: parentPath ?? this.parentPath,
        referenceId: referenceId ?? this.referenceId,
        referenceName: referenceName ?? this.referenceName,
        objectNameOld: objectNameOld ?? this.objectNameOld,
        objectNameNew: objectNameNew ?? this.objectNameNew,
        quantityMark: quantityMark ?? this.quantityMark,
        lotIds: lotIds ?? this.lotIds,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        productAttributeValueNew:
            productAttributeValueNew ?? this.productAttributeValueNew,
        productAttributeName: productAttributeName ?? this.productAttributeName,
        productTmpIdNew: productTmpIdNew ?? this.productTmpIdNew,
        attributeValueNew: attributeValueNew ?? this.attributeValueNew);
  }
}

@JsonSerializable(explicitToJson: true)
class ResContactPatchUpdateResquestModel {
  ResContactPatchUpdateResquestModel({
    this.name,
    this.title,
    this.fullname,
    this.birthday,
    this.eventsObject,
    this.organizationsObject,
    this.addressesObject,
    this.telephonesObject,
    this.emailObject,
    this.websiteObject,
    this.notes,
    this.imageUrl,
    this.qrCodeUrl,
    this.labelsObjs,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.isShared,
    this.order,
    this.isActive,
    this.refsObject,
    this.id,
  });

  factory ResContactPatchUpdateResquestModel.fromJson(
          Map<String, dynamic> json) =>
      _$ResContactPatchUpdateResquestModelFromJson(json);

  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'fullname', includeIfNull: false)
  final String? fullname;
  @JsonKey(name: 'birthday', includeIfNull: false)
  final DateTime? birthday;
  @JsonKey(name: 'eventsObject', includeIfNull: false, defaultValue: <Event>[])
  final List<Event>? eventsObject;
  @JsonKey(
      name: 'organizationsObject', includeIfNull: false, defaultValue: <Org>[])
  final List<Org>? organizationsObject;
  @JsonKey(
      name: 'addressesObject', includeIfNull: false, defaultValue: <Address>[])
  final List<Address>? addressesObject;
  @JsonKey(
      name: 'telephonesObject', includeIfNull: false, defaultValue: <Phone>[])
  final List<Phone>? telephonesObject;
  @JsonKey(name: 'emailObject', includeIfNull: false, defaultValue: <Email>[])
  final List<Email>? emailObject;
  @JsonKey(
      name: 'websiteObject', includeIfNull: false, defaultValue: <Website>[])
  final List<Website>? websiteObject;
  @JsonKey(name: 'notes', includeIfNull: false)
  final String? notes;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(name: 'qrCodeUrl', includeIfNull: false)
  final String? qrCodeUrl;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'isShared', includeIfNull: false)
  final bool? isShared;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'refsObject', includeIfNull: false, defaultValue: <String>[])
  final List<String>? refsObject;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  static const fromJsonFactory = _$ResContactPatchUpdateResquestModelFromJson;
  static const toJsonFactory = _$ResContactPatchUpdateResquestModelToJson;
  Map<String, dynamic> toJson() =>
      _$ResContactPatchUpdateResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResContactPatchUpdateResquestModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.fullname, fullname) ||
                const DeepCollectionEquality()
                    .equals(other.fullname, fullname)) &&
            (identical(other.birthday, birthday) ||
                const DeepCollectionEquality()
                    .equals(other.birthday, birthday)) &&
            (identical(other.eventsObject, eventsObject) ||
                const DeepCollectionEquality()
                    .equals(other.eventsObject, eventsObject)) &&
            (identical(other.organizationsObject, organizationsObject) ||
                const DeepCollectionEquality()
                    .equals(other.organizationsObject, organizationsObject)) &&
            (identical(other.addressesObject, addressesObject) ||
                const DeepCollectionEquality()
                    .equals(other.addressesObject, addressesObject)) &&
            (identical(other.telephonesObject, telephonesObject) ||
                const DeepCollectionEquality()
                    .equals(other.telephonesObject, telephonesObject)) &&
            (identical(other.emailObject, emailObject) ||
                const DeepCollectionEquality()
                    .equals(other.emailObject, emailObject)) &&
            (identical(other.websiteObject, websiteObject) ||
                const DeepCollectionEquality()
                    .equals(other.websiteObject, websiteObject)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.qrCodeUrl, qrCodeUrl) ||
                const DeepCollectionEquality()
                    .equals(other.qrCodeUrl, qrCodeUrl)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.isShared, isShared) ||
                const DeepCollectionEquality()
                    .equals(other.isShared, isShared)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.refsObject, refsObject) ||
                const DeepCollectionEquality()
                    .equals(other.refsObject, refsObject)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(fullname) ^
      const DeepCollectionEquality().hash(birthday) ^
      const DeepCollectionEquality().hash(eventsObject) ^
      const DeepCollectionEquality().hash(organizationsObject) ^
      const DeepCollectionEquality().hash(addressesObject) ^
      const DeepCollectionEquality().hash(telephonesObject) ^
      const DeepCollectionEquality().hash(emailObject) ^
      const DeepCollectionEquality().hash(websiteObject) ^
      const DeepCollectionEquality().hash(notes) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(qrCodeUrl) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(isShared) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(refsObject) ^
      const DeepCollectionEquality().hash(id) ^
      runtimeType.hashCode;
}

extension $ResContactPatchUpdateResquestModelExtension
    on ResContactPatchUpdateResquestModel {
  ResContactPatchUpdateResquestModel copyWith(
      {String? name,
      String? title,
      String? fullname,
      DateTime? birthday,
      List<Event>? eventsObject,
      List<Org>? organizationsObject,
      List<Address>? addressesObject,
      List<Phone>? telephonesObject,
      List<Email>? emailObject,
      List<Website>? websiteObject,
      String? notes,
      String? imageUrl,
      String? qrCodeUrl,
      List<LabelsObj>? labelsObjs,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      bool? isShared,
      int? order,
      bool? isActive,
      List<String>? refsObject,
      String? id}) {
    return ResContactPatchUpdateResquestModel(
        name: name ?? this.name,
        title: title ?? this.title,
        fullname: fullname ?? this.fullname,
        birthday: birthday ?? this.birthday,
        eventsObject: eventsObject ?? this.eventsObject,
        organizationsObject: organizationsObject ?? this.organizationsObject,
        addressesObject: addressesObject ?? this.addressesObject,
        telephonesObject: telephonesObject ?? this.telephonesObject,
        emailObject: emailObject ?? this.emailObject,
        websiteObject: websiteObject ?? this.websiteObject,
        notes: notes ?? this.notes,
        imageUrl: imageUrl ?? this.imageUrl,
        qrCodeUrl: qrCodeUrl ?? this.qrCodeUrl,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        isShared: isShared ?? this.isShared,
        order: order ?? this.order,
        isActive: isActive ?? this.isActive,
        refsObject: refsObject ?? this.refsObject,
        id: id ?? this.id);
  }
}

@JsonSerializable(explicitToJson: true)
class ResContactResponseModel {
  ResContactResponseModel({
    this.name,
    this.title,
    this.fullname,
    this.birthday,
    this.eventsObject,
    this.organizationsObject,
    this.addressesObject,
    this.telephonesObject,
    this.emailObject,
    this.websiteObject,
    this.notes,
    this.imageUrl,
    this.qrCodeUrl,
    this.labelsObjs,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.isShared,
    this.order,
    this.isActive,
    this.id,
    this.refsObject,
  });

  factory ResContactResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ResContactResponseModelFromJson(json);

  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'fullname', includeIfNull: false)
  final String? fullname;
  @JsonKey(name: 'birthday', includeIfNull: false)
  final DateTime? birthday;
  @JsonKey(name: 'eventsObject', includeIfNull: false, defaultValue: <Event>[])
  final List<Event>? eventsObject;
  @JsonKey(
      name: 'organizationsObject', includeIfNull: false, defaultValue: <Org>[])
  final List<Org>? organizationsObject;
  @JsonKey(
      name: 'addressesObject', includeIfNull: false, defaultValue: <Address>[])
  final List<Address>? addressesObject;
  @JsonKey(
      name: 'telephonesObject', includeIfNull: false, defaultValue: <Phone>[])
  final List<Phone>? telephonesObject;
  @JsonKey(name: 'emailObject', includeIfNull: false, defaultValue: <Email>[])
  final List<Email>? emailObject;
  @JsonKey(
      name: 'websiteObject', includeIfNull: false, defaultValue: <Website>[])
  final List<Website>? websiteObject;
  @JsonKey(name: 'notes', includeIfNull: false)
  final String? notes;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(name: 'qrCodeUrl', includeIfNull: false)
  final String? qrCodeUrl;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'isShared', includeIfNull: false)
  final bool? isShared;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'refsObject', includeIfNull: false, defaultValue: <String>[])
  final List<String>? refsObject;
  static const fromJsonFactory = _$ResContactResponseModelFromJson;
  static const toJsonFactory = _$ResContactResponseModelToJson;
  Map<String, dynamic> toJson() => _$ResContactResponseModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResContactResponseModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.fullname, fullname) ||
                const DeepCollectionEquality()
                    .equals(other.fullname, fullname)) &&
            (identical(other.birthday, birthday) ||
                const DeepCollectionEquality()
                    .equals(other.birthday, birthday)) &&
            (identical(other.eventsObject, eventsObject) ||
                const DeepCollectionEquality()
                    .equals(other.eventsObject, eventsObject)) &&
            (identical(other.organizationsObject, organizationsObject) ||
                const DeepCollectionEquality()
                    .equals(other.organizationsObject, organizationsObject)) &&
            (identical(other.addressesObject, addressesObject) ||
                const DeepCollectionEquality()
                    .equals(other.addressesObject, addressesObject)) &&
            (identical(other.telephonesObject, telephonesObject) ||
                const DeepCollectionEquality()
                    .equals(other.telephonesObject, telephonesObject)) &&
            (identical(other.emailObject, emailObject) ||
                const DeepCollectionEquality()
                    .equals(other.emailObject, emailObject)) &&
            (identical(other.websiteObject, websiteObject) ||
                const DeepCollectionEquality()
                    .equals(other.websiteObject, websiteObject)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.qrCodeUrl, qrCodeUrl) ||
                const DeepCollectionEquality()
                    .equals(other.qrCodeUrl, qrCodeUrl)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.isShared, isShared) ||
                const DeepCollectionEquality()
                    .equals(other.isShared, isShared)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.refsObject, refsObject) ||
                const DeepCollectionEquality()
                    .equals(other.refsObject, refsObject)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(fullname) ^
      const DeepCollectionEquality().hash(birthday) ^
      const DeepCollectionEquality().hash(eventsObject) ^
      const DeepCollectionEquality().hash(organizationsObject) ^
      const DeepCollectionEquality().hash(addressesObject) ^
      const DeepCollectionEquality().hash(telephonesObject) ^
      const DeepCollectionEquality().hash(emailObject) ^
      const DeepCollectionEquality().hash(websiteObject) ^
      const DeepCollectionEquality().hash(notes) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(qrCodeUrl) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(isShared) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(refsObject) ^
      runtimeType.hashCode;
}

extension $ResContactResponseModelExtension on ResContactResponseModel {
  ResContactResponseModel copyWith(
      {String? name,
      String? title,
      String? fullname,
      DateTime? birthday,
      List<Event>? eventsObject,
      List<Org>? organizationsObject,
      List<Address>? addressesObject,
      List<Phone>? telephonesObject,
      List<Email>? emailObject,
      List<Website>? websiteObject,
      String? notes,
      String? imageUrl,
      String? qrCodeUrl,
      List<LabelsObj>? labelsObjs,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      bool? isShared,
      int? order,
      bool? isActive,
      String? id,
      List<String>? refsObject}) {
    return ResContactResponseModel(
        name: name ?? this.name,
        title: title ?? this.title,
        fullname: fullname ?? this.fullname,
        birthday: birthday ?? this.birthday,
        eventsObject: eventsObject ?? this.eventsObject,
        organizationsObject: organizationsObject ?? this.organizationsObject,
        addressesObject: addressesObject ?? this.addressesObject,
        telephonesObject: telephonesObject ?? this.telephonesObject,
        emailObject: emailObject ?? this.emailObject,
        websiteObject: websiteObject ?? this.websiteObject,
        notes: notes ?? this.notes,
        imageUrl: imageUrl ?? this.imageUrl,
        qrCodeUrl: qrCodeUrl ?? this.qrCodeUrl,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        isShared: isShared ?? this.isShared,
        order: order ?? this.order,
        isActive: isActive ?? this.isActive,
        id: id ?? this.id,
        refsObject: refsObject ?? this.refsObject);
  }
}

@JsonSerializable(explicitToJson: true)
class ResContactResponseModelPagination {
  ResContactResponseModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory ResContactResponseModelPagination.fromJson(
          Map<String, dynamic> json) =>
      _$ResContactResponseModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content',
      includeIfNull: false,
      defaultValue: <ResContactResponseModel>[])
  final List<ResContactResponseModel>? content;
  static const fromJsonFactory = _$ResContactResponseModelPaginationFromJson;
  static const toJsonFactory = _$ResContactResponseModelPaginationToJson;
  Map<String, dynamic> toJson() =>
      _$ResContactResponseModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResContactResponseModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $ResContactResponseModelPaginationExtension
    on ResContactResponseModelPagination {
  ResContactResponseModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<ResContactResponseModel>? content}) {
    return ResContactResponseModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class ResContactResponseModelResponseList {
  ResContactResponseModelResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ResContactResponseModelResponseList.fromJson(
          Map<String, dynamic> json) =>
      _$ResContactResponseModelResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(
      name: 'data',
      includeIfNull: false,
      defaultValue: <ResContactResponseModel>[])
  final List<ResContactResponseModel>? data;
  static const fromJsonFactory = _$ResContactResponseModelResponseListFromJson;
  static const toJsonFactory = _$ResContactResponseModelResponseListToJson;
  Map<String, dynamic> toJson() =>
      _$ResContactResponseModelResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResContactResponseModelResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ResContactResponseModelResponseListExtension
    on ResContactResponseModelResponseList {
  ResContactResponseModelResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<ResContactResponseModel>? data}) {
    return ResContactResponseModelResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ResContactResponseModelResponseObject {
  ResContactResponseModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ResContactResponseModelResponseObject.fromJson(
          Map<String, dynamic> json) =>
      _$ResContactResponseModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ResContactResponseModel? data;
  static const fromJsonFactory =
      _$ResContactResponseModelResponseObjectFromJson;
  static const toJsonFactory = _$ResContactResponseModelResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$ResContactResponseModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResContactResponseModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ResContactResponseModelResponseObjectExtension
    on ResContactResponseModelResponseObject {
  ResContactResponseModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ResContactResponseModel? data}) {
    return ResContactResponseModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ResContactResponseModelResponsePagination {
  ResContactResponseModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ResContactResponseModelResponsePagination.fromJson(
          Map<String, dynamic> json) =>
      _$ResContactResponseModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ResContactResponseModelPagination? data;
  static const fromJsonFactory =
      _$ResContactResponseModelResponsePaginationFromJson;
  static const toJsonFactory =
      _$ResContactResponseModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$ResContactResponseModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResContactResponseModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ResContactResponseModelResponsePaginationExtension
    on ResContactResponseModelResponsePagination {
  ResContactResponseModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ResContactResponseModelPagination? data}) {
    return ResContactResponseModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ResContactUpdateResquestModel {
  ResContactUpdateResquestModel({
    this.name,
    this.title,
    this.fullname,
    this.birthday,
    this.eventsObject,
    this.organizationsObject,
    this.addressesObject,
    this.telephonesObject,
    this.emailObject,
    this.websiteObject,
    this.notes,
    this.imageUrl,
    this.qrCodeUrl,
    this.labelsObjs,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.isShared,
    this.order,
    this.isActive,
    this.refsObject,
  });

  factory ResContactUpdateResquestModel.fromJson(Map<String, dynamic> json) =>
      _$ResContactUpdateResquestModelFromJson(json);

  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'fullname', includeIfNull: false)
  final String? fullname;
  @JsonKey(name: 'birthday', includeIfNull: false)
  final DateTime? birthday;
  @JsonKey(name: 'eventsObject', includeIfNull: false, defaultValue: <Event>[])
  final List<Event>? eventsObject;
  @JsonKey(
      name: 'organizationsObject', includeIfNull: false, defaultValue: <Org>[])
  final List<Org>? organizationsObject;
  @JsonKey(
      name: 'addressesObject', includeIfNull: false, defaultValue: <Address>[])
  final List<Address>? addressesObject;
  @JsonKey(
      name: 'telephonesObject', includeIfNull: false, defaultValue: <Phone>[])
  final List<Phone>? telephonesObject;
  @JsonKey(name: 'emailObject', includeIfNull: false, defaultValue: <Email>[])
  final List<Email>? emailObject;
  @JsonKey(
      name: 'websiteObject', includeIfNull: false, defaultValue: <Website>[])
  final List<Website>? websiteObject;
  @JsonKey(name: 'notes', includeIfNull: false)
  final String? notes;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(name: 'qrCodeUrl', includeIfNull: false)
  final String? qrCodeUrl;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'isShared', includeIfNull: false)
  final bool? isShared;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'refsObject', includeIfNull: false, defaultValue: <String>[])
  final List<String>? refsObject;
  static const fromJsonFactory = _$ResContactUpdateResquestModelFromJson;
  static const toJsonFactory = _$ResContactUpdateResquestModelToJson;
  Map<String, dynamic> toJson() => _$ResContactUpdateResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResContactUpdateResquestModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.fullname, fullname) ||
                const DeepCollectionEquality()
                    .equals(other.fullname, fullname)) &&
            (identical(other.birthday, birthday) ||
                const DeepCollectionEquality()
                    .equals(other.birthday, birthday)) &&
            (identical(other.eventsObject, eventsObject) ||
                const DeepCollectionEquality()
                    .equals(other.eventsObject, eventsObject)) &&
            (identical(other.organizationsObject, organizationsObject) ||
                const DeepCollectionEquality()
                    .equals(other.organizationsObject, organizationsObject)) &&
            (identical(other.addressesObject, addressesObject) ||
                const DeepCollectionEquality()
                    .equals(other.addressesObject, addressesObject)) &&
            (identical(other.telephonesObject, telephonesObject) ||
                const DeepCollectionEquality()
                    .equals(other.telephonesObject, telephonesObject)) &&
            (identical(other.emailObject, emailObject) ||
                const DeepCollectionEquality()
                    .equals(other.emailObject, emailObject)) &&
            (identical(other.websiteObject, websiteObject) ||
                const DeepCollectionEquality()
                    .equals(other.websiteObject, websiteObject)) &&
            (identical(other.notes, notes) ||
                const DeepCollectionEquality().equals(other.notes, notes)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.qrCodeUrl, qrCodeUrl) ||
                const DeepCollectionEquality()
                    .equals(other.qrCodeUrl, qrCodeUrl)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.isShared, isShared) ||
                const DeepCollectionEquality()
                    .equals(other.isShared, isShared)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.refsObject, refsObject) ||
                const DeepCollectionEquality()
                    .equals(other.refsObject, refsObject)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(fullname) ^
      const DeepCollectionEquality().hash(birthday) ^
      const DeepCollectionEquality().hash(eventsObject) ^
      const DeepCollectionEquality().hash(organizationsObject) ^
      const DeepCollectionEquality().hash(addressesObject) ^
      const DeepCollectionEquality().hash(telephonesObject) ^
      const DeepCollectionEquality().hash(emailObject) ^
      const DeepCollectionEquality().hash(websiteObject) ^
      const DeepCollectionEquality().hash(notes) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(qrCodeUrl) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(isShared) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(refsObject) ^
      runtimeType.hashCode;
}

extension $ResContactUpdateResquestModelExtension
    on ResContactUpdateResquestModel {
  ResContactUpdateResquestModel copyWith(
      {String? name,
      String? title,
      String? fullname,
      DateTime? birthday,
      List<Event>? eventsObject,
      List<Org>? organizationsObject,
      List<Address>? addressesObject,
      List<Phone>? telephonesObject,
      List<Email>? emailObject,
      List<Website>? websiteObject,
      String? notes,
      String? imageUrl,
      String? qrCodeUrl,
      List<LabelsObj>? labelsObjs,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      bool? isShared,
      int? order,
      bool? isActive,
      List<String>? refsObject}) {
    return ResContactUpdateResquestModel(
        name: name ?? this.name,
        title: title ?? this.title,
        fullname: fullname ?? this.fullname,
        birthday: birthday ?? this.birthday,
        eventsObject: eventsObject ?? this.eventsObject,
        organizationsObject: organizationsObject ?? this.organizationsObject,
        addressesObject: addressesObject ?? this.addressesObject,
        telephonesObject: telephonesObject ?? this.telephonesObject,
        emailObject: emailObject ?? this.emailObject,
        websiteObject: websiteObject ?? this.websiteObject,
        notes: notes ?? this.notes,
        imageUrl: imageUrl ?? this.imageUrl,
        qrCodeUrl: qrCodeUrl ?? this.qrCodeUrl,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        isShared: isShared ?? this.isShared,
        order: order ?? this.order,
        isActive: isActive ?? this.isActive,
        refsObject: refsObject ?? this.refsObject);
  }
}

@JsonSerializable(explicitToJson: true)
class ResponseDelete {
  ResponseDelete({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ResponseDelete.fromJson(Map<String, dynamic> json) =>
      _$ResponseDeleteFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final ResponseDeleteModel? data;
  static const fromJsonFactory = _$ResponseDeleteFromJson;
  static const toJsonFactory = _$ResponseDeleteToJson;
  Map<String, dynamic> toJson() => _$ResponseDeleteToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResponseDelete &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ResponseDeleteExtension on ResponseDelete {
  ResponseDelete copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      ResponseDeleteModel? data}) {
    return ResponseDelete(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ResponseDeleteModel {
  ResponseDeleteModel({
    this.id,
    this.name,
  });

  factory ResponseDeleteModel.fromJson(Map<String, dynamic> json) =>
      _$ResponseDeleteModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  static const fromJsonFactory = _$ResponseDeleteModelFromJson;
  static const toJsonFactory = _$ResponseDeleteModelToJson;
  Map<String, dynamic> toJson() => _$ResponseDeleteModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResponseDeleteModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $ResponseDeleteModelExtension on ResponseDeleteModel {
  ResponseDeleteModel copyWith({String? id, String? name}) {
    return ResponseDeleteModel(id: id ?? this.id, name: name ?? this.name);
  }
}

@JsonSerializable(explicitToJson: true)
class ResponseDeleteMulti {
  ResponseDeleteMulti({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ResponseDeleteMulti.fromJson(Map<String, dynamic> json) =>
      _$ResponseDeleteMultiFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(
      name: 'data', includeIfNull: false, defaultValue: <ResponseDeleteModel>[])
  final List<ResponseDeleteModel>? data;
  static const fromJsonFactory = _$ResponseDeleteMultiFromJson;
  static const toJsonFactory = _$ResponseDeleteMultiToJson;
  Map<String, dynamic> toJson() => _$ResponseDeleteMultiToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResponseDeleteMulti &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ResponseDeleteMultiExtension on ResponseDeleteMulti {
  ResponseDeleteMulti copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<ResponseDeleteModel>? data}) {
    return ResponseDeleteMulti(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class ResponseUpdateModel {
  ResponseUpdateModel({
    this.id,
    this.name,
  });

  factory ResponseUpdateModel.fromJson(Map<String, dynamic> json) =>
      _$ResponseUpdateModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  static const fromJsonFactory = _$ResponseUpdateModelFromJson;
  static const toJsonFactory = _$ResponseUpdateModelToJson;
  Map<String, dynamic> toJson() => _$ResponseUpdateModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResponseUpdateModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $ResponseUpdateModelExtension on ResponseUpdateModel {
  ResponseUpdateModel copyWith({String? id, String? name}) {
    return ResponseUpdateModel(id: id ?? this.id, name: name ?? this.name);
  }
}

@JsonSerializable(explicitToJson: true)
class ResponseUpdateMulti {
  ResponseUpdateMulti({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory ResponseUpdateMulti.fromJson(Map<String, dynamic> json) =>
      _$ResponseUpdateMultiFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(
      name: 'data', includeIfNull: false, defaultValue: <ResponseUpdateModel>[])
  final List<ResponseUpdateModel>? data;
  static const fromJsonFactory = _$ResponseUpdateMultiFromJson;
  static const toJsonFactory = _$ResponseUpdateMultiToJson;
  Map<String, dynamic> toJson() => _$ResponseUpdateMultiToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ResponseUpdateMulti &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ResponseUpdateMultiExtension on ResponseUpdateMulti {
  ResponseUpdateMulti copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<ResponseUpdateModel>? data}) {
    return ResponseUpdateMulti(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class Routing {
  Routing({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.name,
    this.type,
    this.isActive,
    this.code,
    this.description,
    this.locationId,
    this.locationName,
    this.companyId,
  });

  factory Routing.fromJson(Map<String, dynamic> json) =>
      _$RoutingFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  static const fromJsonFactory = _$RoutingFromJson;
  static const toJsonFactory = _$RoutingToJson;
  Map<String, dynamic> toJson() => _$RoutingToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Routing &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.companyId, companyId) ||
                const DeepCollectionEquality()
                    .equals(other.companyId, companyId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(companyId) ^
      runtimeType.hashCode;
}

extension $RoutingExtension on Routing {
  Routing copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? name,
      String? type,
      bool? isActive,
      String? code,
      String? description,
      String? locationId,
      String? locationName,
      String? companyId}) {
    return Routing(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        name: name ?? this.name,
        type: type ?? this.type,
        isActive: isActive ?? this.isActive,
        code: code ?? this.code,
        description: description ?? this.description,
        locationId: locationId ?? this.locationId,
        locationName: locationName ?? this.locationName,
        companyId: companyId ?? this.companyId);
  }
}

@JsonSerializable(explicitToJson: true)
class RoutingModel {
  RoutingModel({
    this.id,
    this.name,
    this.isActive,
    this.code,
    this.description,
    this.locationId,
    this.locationName,
    this.companyId,
    this.type,
    this.metadataContentObjs,
    this.routingDetails,
  });

  factory RoutingModel.fromJson(Map<String, dynamic> json) =>
      _$RoutingModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(
      name: 'routingDetails',
      includeIfNull: false,
      defaultValue: <RoutingWorkcenter>[])
  final List<RoutingWorkcenter>? routingDetails;
  static const fromJsonFactory = _$RoutingModelFromJson;
  static const toJsonFactory = _$RoutingModelToJson;
  Map<String, dynamic> toJson() => _$RoutingModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RoutingModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.companyId, companyId) ||
                const DeepCollectionEquality()
                    .equals(other.companyId, companyId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.routingDetails, routingDetails) ||
                const DeepCollectionEquality()
                    .equals(other.routingDetails, routingDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(companyId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(routingDetails) ^
      runtimeType.hashCode;
}

extension $RoutingModelExtension on RoutingModel {
  RoutingModel copyWith(
      {String? id,
      String? name,
      bool? isActive,
      String? code,
      String? description,
      String? locationId,
      String? locationName,
      String? companyId,
      String? type,
      List<MetadataValue>? metadataContentObjs,
      List<RoutingWorkcenter>? routingDetails}) {
    return RoutingModel(
        id: id ?? this.id,
        name: name ?? this.name,
        isActive: isActive ?? this.isActive,
        code: code ?? this.code,
        description: description ?? this.description,
        locationId: locationId ?? this.locationId,
        locationName: locationName ?? this.locationName,
        companyId: companyId ?? this.companyId,
        type: type ?? this.type,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        routingDetails: routingDetails ?? this.routingDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class RoutingModelPagination {
  RoutingModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory RoutingModelPagination.fromJson(Map<String, dynamic> json) =>
      _$RoutingModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content', includeIfNull: false, defaultValue: <RoutingModel>[])
  final List<RoutingModel>? content;
  static const fromJsonFactory = _$RoutingModelPaginationFromJson;
  static const toJsonFactory = _$RoutingModelPaginationToJson;
  Map<String, dynamic> toJson() => _$RoutingModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RoutingModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $RoutingModelPaginationExtension on RoutingModelPagination {
  RoutingModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<RoutingModel>? content}) {
    return RoutingModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class RoutingModelResponseObject {
  RoutingModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory RoutingModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$RoutingModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final RoutingModel? data;
  static const fromJsonFactory = _$RoutingModelResponseObjectFromJson;
  static const toJsonFactory = _$RoutingModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$RoutingModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RoutingModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $RoutingModelResponseObjectExtension on RoutingModelResponseObject {
  RoutingModelResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, RoutingModel? data}) {
    return RoutingModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class RoutingModelResponsePagination {
  RoutingModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory RoutingModelResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$RoutingModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final RoutingModelPagination? data;
  static const fromJsonFactory = _$RoutingModelResponsePaginationFromJson;
  static const toJsonFactory = _$RoutingModelResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$RoutingModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RoutingModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $RoutingModelResponsePaginationExtension
    on RoutingModelResponsePagination {
  RoutingModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      RoutingModelPagination? data}) {
    return RoutingModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class RoutingResponseObject {
  RoutingResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory RoutingResponseObject.fromJson(Map<String, dynamic> json) =>
      _$RoutingResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final Routing? data;
  static const fromJsonFactory = _$RoutingResponseObjectFromJson;
  static const toJsonFactory = _$RoutingResponseObjectToJson;
  Map<String, dynamic> toJson() => _$RoutingResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RoutingResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $RoutingResponseObjectExtension on RoutingResponseObject {
  RoutingResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, Routing? data}) {
    return RoutingResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class RoutingWorkcenter {
  RoutingWorkcenter({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.name,
    this.workCenterId,
    this.routingId,
    this.sequence,
    this.description,
    this.companyId,
    this.worksheet,
    this.timeMode,
    this.timeModeBatch,
    this.timeCycleManual,
    this.batch,
    this.batchSize,
    this.deXeDecimal,
    this.isLast,
  });

  factory RoutingWorkcenter.fromJson(Map<String, dynamic> json) =>
      _$RoutingWorkcenterFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'workCenterId', includeIfNull: false)
  final String? workCenterId;
  @JsonKey(name: 'routingId', includeIfNull: false)
  final String? routingId;
  @JsonKey(name: 'sequence', includeIfNull: false)
  final int? sequence;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  @JsonKey(name: 'worksheet', includeIfNull: false)
  final String? worksheet;
  @JsonKey(name: 'timeMode', includeIfNull: false)
  final String? timeMode;
  @JsonKey(name: 'timeModeBatch', includeIfNull: false)
  final int? timeModeBatch;
  @JsonKey(name: 'timeCycleManual', includeIfNull: false)
  final double? timeCycleManual;
  @JsonKey(name: 'batch', includeIfNull: false)
  final String? batch;
  @JsonKey(name: 'batchSize', includeIfNull: false)
  final double? batchSize;
  @JsonKey(name: 'deXeDecimal', includeIfNull: false)
  final double? deXeDecimal;
  @JsonKey(name: 'isLast', includeIfNull: false)
  final bool? isLast;
  static const fromJsonFactory = _$RoutingWorkcenterFromJson;
  static const toJsonFactory = _$RoutingWorkcenterToJson;
  Map<String, dynamic> toJson() => _$RoutingWorkcenterToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RoutingWorkcenter &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.workCenterId, workCenterId) ||
                const DeepCollectionEquality()
                    .equals(other.workCenterId, workCenterId)) &&
            (identical(other.routingId, routingId) ||
                const DeepCollectionEquality()
                    .equals(other.routingId, routingId)) &&
            (identical(other.sequence, sequence) ||
                const DeepCollectionEquality()
                    .equals(other.sequence, sequence)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.companyId, companyId) ||
                const DeepCollectionEquality()
                    .equals(other.companyId, companyId)) &&
            (identical(other.worksheet, worksheet) ||
                const DeepCollectionEquality()
                    .equals(other.worksheet, worksheet)) &&
            (identical(other.timeMode, timeMode) ||
                const DeepCollectionEquality()
                    .equals(other.timeMode, timeMode)) &&
            (identical(other.timeModeBatch, timeModeBatch) ||
                const DeepCollectionEquality()
                    .equals(other.timeModeBatch, timeModeBatch)) &&
            (identical(other.timeCycleManual, timeCycleManual) ||
                const DeepCollectionEquality()
                    .equals(other.timeCycleManual, timeCycleManual)) &&
            (identical(other.batch, batch) ||
                const DeepCollectionEquality().equals(other.batch, batch)) &&
            (identical(other.batchSize, batchSize) ||
                const DeepCollectionEquality()
                    .equals(other.batchSize, batchSize)) &&
            (identical(other.deXeDecimal, deXeDecimal) ||
                const DeepCollectionEquality()
                    .equals(other.deXeDecimal, deXeDecimal)) &&
            (identical(other.isLast, isLast) ||
                const DeepCollectionEquality().equals(other.isLast, isLast)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(workCenterId) ^
      const DeepCollectionEquality().hash(routingId) ^
      const DeepCollectionEquality().hash(sequence) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(companyId) ^
      const DeepCollectionEquality().hash(worksheet) ^
      const DeepCollectionEquality().hash(timeMode) ^
      const DeepCollectionEquality().hash(timeModeBatch) ^
      const DeepCollectionEquality().hash(timeCycleManual) ^
      const DeepCollectionEquality().hash(batch) ^
      const DeepCollectionEquality().hash(batchSize) ^
      const DeepCollectionEquality().hash(deXeDecimal) ^
      const DeepCollectionEquality().hash(isLast) ^
      runtimeType.hashCode;
}

extension $RoutingWorkcenterExtension on RoutingWorkcenter {
  RoutingWorkcenter copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? name,
      String? workCenterId,
      String? routingId,
      int? sequence,
      String? description,
      String? companyId,
      String? worksheet,
      String? timeMode,
      int? timeModeBatch,
      double? timeCycleManual,
      String? batch,
      double? batchSize,
      double? deXeDecimal,
      bool? isLast}) {
    return RoutingWorkcenter(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        name: name ?? this.name,
        workCenterId: workCenterId ?? this.workCenterId,
        routingId: routingId ?? this.routingId,
        sequence: sequence ?? this.sequence,
        description: description ?? this.description,
        companyId: companyId ?? this.companyId,
        worksheet: worksheet ?? this.worksheet,
        timeMode: timeMode ?? this.timeMode,
        timeModeBatch: timeModeBatch ?? this.timeModeBatch,
        timeCycleManual: timeCycleManual ?? this.timeCycleManual,
        batch: batch ?? this.batch,
        batchSize: batchSize ?? this.batchSize,
        deXeDecimal: deXeDecimal ?? this.deXeDecimal,
        isLast: isLast ?? this.isLast);
  }
}

@JsonSerializable(explicitToJson: true)
class SimpleNodeBaseResponseModel {
  SimpleNodeBaseResponseModel({
    this.id,
    required this.name,
    this.imageUrl,
    this.parentId,
    this.nodeTypeObj,
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.completePath,
    this.completeName,
  });

  factory SimpleNodeBaseResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SimpleNodeBaseResponseModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(
      name: 'nodeTypeObj',
      includeIfNull: false,
      toJson: nodeTypeEnumToJson,
      fromJson: nodeTypeEnumFromJson)
  final enums.NodeTypeEnum? nodeTypeObj;
  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'completePath', includeIfNull: false)
  final String? completePath;
  @JsonKey(name: 'completeName', includeIfNull: false)
  final String? completeName;
  static const fromJsonFactory = _$SimpleNodeBaseResponseModelFromJson;
  static const toJsonFactory = _$SimpleNodeBaseResponseModelToJson;
  Map<String, dynamic> toJson() => _$SimpleNodeBaseResponseModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SimpleNodeBaseResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.nodeTypeObj, nodeTypeObj) ||
                const DeepCollectionEquality()
                    .equals(other.nodeTypeObj, nodeTypeObj)) &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.cLeft, cLeft) ||
                const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) ||
                const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) ||
                const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.completePath, completePath) ||
                const DeepCollectionEquality()
                    .equals(other.completePath, completePath)) &&
            (identical(other.completeName, completeName) ||
                const DeepCollectionEquality()
                    .equals(other.completeName, completeName)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(nodeTypeObj) ^
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(completePath) ^
      const DeepCollectionEquality().hash(completeName) ^
      runtimeType.hashCode;
}

extension $SimpleNodeBaseResponseModelExtension on SimpleNodeBaseResponseModel {
  SimpleNodeBaseResponseModel copyWith(
      {String? id,
      String? name,
      String? imageUrl,
      String? parentId,
      enums.NodeTypeEnum? nodeTypeObj,
      String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      int? cLeft,
      int? cRight,
      int? cLevel,
      String? completePath,
      String? completeName}) {
    return SimpleNodeBaseResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        imageUrl: imageUrl ?? this.imageUrl,
        parentId: parentId ?? this.parentId,
        nodeTypeObj: nodeTypeObj ?? this.nodeTypeObj,
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        completePath: completePath ?? this.completePath,
        completeName: completeName ?? this.completeName);
  }
}

@JsonSerializable(explicitToJson: true)
class StockMoveLine {
  StockMoveLine({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.reference,
    this.referenceType,
    this.note,
    this.pickingId,
    this.moveId,
    this.objectId,
    this.objectCode,
    this.objectType,
    this.referenceDetailId,
    this.unitId,
    this.unit,
    this.productQty,
    this.quantityConvert,
    this.qtyDone,
    this.locationSrcId,
    this.locationSrcName,
    this.locationDestId,
    this.locationDestName,
    this.state,
    this.packageId,
    this.packageLevelId,
    this.lotId,
    this.lotName,
    this.productionId,
    this.productionNo,
    this.lotProducedQty,
    this.isDone,
    this.totalAmount,
    this.isMark,
    this.metadataContentObjs,
    this.metadataContent,
  });

  factory StockMoveLine.fromJson(Map<String, dynamic> json) =>
      _$StockMoveLineFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'reference', includeIfNull: false)
  final String? reference;
  @JsonKey(name: 'referenceType', includeIfNull: false)
  final String? referenceType;
  @JsonKey(name: 'note', includeIfNull: false)
  final String? note;
  @JsonKey(name: 'pickingId', includeIfNull: false)
  final String? pickingId;
  @JsonKey(name: 'moveId', includeIfNull: false)
  final String? moveId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectCode', includeIfNull: false)
  final String? objectCode;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'referenceDetailId', includeIfNull: false)
  final String? referenceDetailId;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'unit', includeIfNull: false)
  final String? unit;
  @JsonKey(name: 'productQty', includeIfNull: false)
  final double? productQty;
  @JsonKey(name: 'quantityConvert', includeIfNull: false)
  final double? quantityConvert;
  @JsonKey(name: 'qtyDone', includeIfNull: false)
  final double? qtyDone;
  @JsonKey(name: 'locationSrcId', includeIfNull: false)
  final String? locationSrcId;
  @JsonKey(name: 'locationSrcName', includeIfNull: false)
  final String? locationSrcName;
  @JsonKey(name: 'locationDestId', includeIfNull: false)
  final String? locationDestId;
  @JsonKey(name: 'locationDestName', includeIfNull: false)
  final String? locationDestName;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(name: 'packageId', includeIfNull: false)
  final String? packageId;
  @JsonKey(name: 'packageLevelId', includeIfNull: false)
  final int? packageLevelId;
  @JsonKey(name: 'lotId', includeIfNull: false)
  final String? lotId;
  @JsonKey(name: 'lotName', includeIfNull: false)
  final String? lotName;
  @JsonKey(name: 'productionId', includeIfNull: false)
  final String? productionId;
  @JsonKey(name: 'productionNo', includeIfNull: false)
  final String? productionNo;
  @JsonKey(name: 'lotProducedQty', includeIfNull: false)
  final double? lotProducedQty;
  @JsonKey(name: 'isDone', includeIfNull: false)
  final bool? isDone;
  @JsonKey(name: 'totalAmount', includeIfNull: false)
  final double? totalAmount;
  @JsonKey(name: 'isMark', includeIfNull: false)
  final bool? isMark;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  static const fromJsonFactory = _$StockMoveLineFromJson;
  static const toJsonFactory = _$StockMoveLineToJson;
  Map<String, dynamic> toJson() => _$StockMoveLineToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StockMoveLine &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.referenceType, referenceType) ||
                const DeepCollectionEquality()
                    .equals(other.referenceType, referenceType)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.pickingId, pickingId) ||
                const DeepCollectionEquality()
                    .equals(other.pickingId, pickingId)) &&
            (identical(other.moveId, moveId) ||
                const DeepCollectionEquality().equals(other.moveId, moveId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectCode, objectCode) ||
                const DeepCollectionEquality()
                    .equals(other.objectCode, objectCode)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.referenceDetailId, referenceDetailId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceDetailId, referenceDetailId)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unit, unit) ||
                const DeepCollectionEquality().equals(other.unit, unit)) &&
            (identical(other.productQty, productQty) ||
                const DeepCollectionEquality()
                    .equals(other.productQty, productQty)) &&
            (identical(other.quantityConvert, quantityConvert) ||
                const DeepCollectionEquality()
                    .equals(other.quantityConvert, quantityConvert)) &&
            (identical(other.qtyDone, qtyDone) ||
                const DeepCollectionEquality()
                    .equals(other.qtyDone, qtyDone)) &&
            (identical(other.locationSrcId, locationSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcId, locationSrcId)) &&
            (identical(other.locationSrcName, locationSrcName) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcName, locationSrcName)) &&
            (identical(other.locationDestId, locationDestId) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestId, locationDestId)) &&
            (identical(other.locationDestName, locationDestName) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestName, locationDestName)) &&
            (identical(other.state, state) || const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.packageId, packageId) || const DeepCollectionEquality().equals(other.packageId, packageId)) &&
            (identical(other.packageLevelId, packageLevelId) || const DeepCollectionEquality().equals(other.packageLevelId, packageLevelId)) &&
            (identical(other.lotId, lotId) || const DeepCollectionEquality().equals(other.lotId, lotId)) &&
            (identical(other.lotName, lotName) || const DeepCollectionEquality().equals(other.lotName, lotName)) &&
            (identical(other.productionId, productionId) || const DeepCollectionEquality().equals(other.productionId, productionId)) &&
            (identical(other.productionNo, productionNo) || const DeepCollectionEquality().equals(other.productionNo, productionNo)) &&
            (identical(other.lotProducedQty, lotProducedQty) || const DeepCollectionEquality().equals(other.lotProducedQty, lotProducedQty)) &&
            (identical(other.isDone, isDone) || const DeepCollectionEquality().equals(other.isDone, isDone)) &&
            (identical(other.totalAmount, totalAmount) || const DeepCollectionEquality().equals(other.totalAmount, totalAmount)) &&
            (identical(other.isMark, isMark) || const DeepCollectionEquality().equals(other.isMark, isMark)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) || const DeepCollectionEquality().equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) || const DeepCollectionEquality().equals(other.metadataContent, metadataContent)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(referenceType) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(pickingId) ^
      const DeepCollectionEquality().hash(moveId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectCode) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(referenceDetailId) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unit) ^
      const DeepCollectionEquality().hash(productQty) ^
      const DeepCollectionEquality().hash(quantityConvert) ^
      const DeepCollectionEquality().hash(qtyDone) ^
      const DeepCollectionEquality().hash(locationSrcId) ^
      const DeepCollectionEquality().hash(locationSrcName) ^
      const DeepCollectionEquality().hash(locationDestId) ^
      const DeepCollectionEquality().hash(locationDestName) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(packageId) ^
      const DeepCollectionEquality().hash(packageLevelId) ^
      const DeepCollectionEquality().hash(lotId) ^
      const DeepCollectionEquality().hash(lotName) ^
      const DeepCollectionEquality().hash(productionId) ^
      const DeepCollectionEquality().hash(productionNo) ^
      const DeepCollectionEquality().hash(lotProducedQty) ^
      const DeepCollectionEquality().hash(isDone) ^
      const DeepCollectionEquality().hash(totalAmount) ^
      const DeepCollectionEquality().hash(isMark) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      runtimeType.hashCode;
}

extension $StockMoveLineExtension on StockMoveLine {
  StockMoveLine copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? reference,
      String? referenceType,
      String? note,
      String? pickingId,
      String? moveId,
      String? objectId,
      String? objectCode,
      String? objectType,
      String? referenceDetailId,
      String? unitId,
      String? unit,
      double? productQty,
      double? quantityConvert,
      double? qtyDone,
      String? locationSrcId,
      String? locationSrcName,
      String? locationDestId,
      String? locationDestName,
      String? state,
      String? packageId,
      int? packageLevelId,
      String? lotId,
      String? lotName,
      String? productionId,
      String? productionNo,
      double? lotProducedQty,
      bool? isDone,
      double? totalAmount,
      bool? isMark,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent}) {
    return StockMoveLine(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        reference: reference ?? this.reference,
        referenceType: referenceType ?? this.referenceType,
        note: note ?? this.note,
        pickingId: pickingId ?? this.pickingId,
        moveId: moveId ?? this.moveId,
        objectId: objectId ?? this.objectId,
        objectCode: objectCode ?? this.objectCode,
        objectType: objectType ?? this.objectType,
        referenceDetailId: referenceDetailId ?? this.referenceDetailId,
        unitId: unitId ?? this.unitId,
        unit: unit ?? this.unit,
        productQty: productQty ?? this.productQty,
        quantityConvert: quantityConvert ?? this.quantityConvert,
        qtyDone: qtyDone ?? this.qtyDone,
        locationSrcId: locationSrcId ?? this.locationSrcId,
        locationSrcName: locationSrcName ?? this.locationSrcName,
        locationDestId: locationDestId ?? this.locationDestId,
        locationDestName: locationDestName ?? this.locationDestName,
        state: state ?? this.state,
        packageId: packageId ?? this.packageId,
        packageLevelId: packageLevelId ?? this.packageLevelId,
        lotId: lotId ?? this.lotId,
        lotName: lotName ?? this.lotName,
        productionId: productionId ?? this.productionId,
        productionNo: productionNo ?? this.productionNo,
        lotProducedQty: lotProducedQty ?? this.lotProducedQty,
        isDone: isDone ?? this.isDone,
        totalAmount: totalAmount ?? this.totalAmount,
        isMark: isMark ?? this.isMark,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent);
  }
}

@JsonSerializable(explicitToJson: true)
class StringArrayResponseObject {
  StringArrayResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory StringArrayResponseObject.fromJson(Map<String, dynamic> json) =>
      _$StringArrayResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <String>[])
  final List<String>? data;
  static const fromJsonFactory = _$StringArrayResponseObjectFromJson;
  static const toJsonFactory = _$StringArrayResponseObjectToJson;
  Map<String, dynamic> toJson() => _$StringArrayResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StringArrayResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $StringArrayResponseObjectExtension on StringArrayResponseObject {
  StringArrayResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, List<String>? data}) {
    return StringArrayResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class StringResponseList {
  StringResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory StringResponseList.fromJson(Map<String, dynamic> json) =>
      _$StringResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <String>[])
  final List<String>? data;
  static const fromJsonFactory = _$StringResponseListFromJson;
  static const toJsonFactory = _$StringResponseListToJson;
  Map<String, dynamic> toJson() => _$StringResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StringResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $StringResponseListExtension on StringResponseList {
  StringResponseList copyWith(
      {enums.Code? code, String? message, num? totalTime, List<String>? data}) {
    return StringResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class StringResponseObject {
  StringResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory StringResponseObject.fromJson(Map<String, dynamic> json) =>
      _$StringResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final String? data;
  static const fromJsonFactory = _$StringResponseObjectFromJson;
  static const toJsonFactory = _$StringResponseObjectToJson;
  Map<String, dynamic> toJson() => _$StringResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StringResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $StringResponseObjectExtension on StringResponseObject {
  StringResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, String? data}) {
    return StringResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamCategory {
  SysParamCategory({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.key,
    this.value,
    this.note,
    this.isActive,
    this.order,
    this.isDeleted,
  });

  factory SysParamCategory.fromJson(Map<String, dynamic> json) =>
      _$SysParamCategoryFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'key', includeIfNull: false)
  final String? key;
  @JsonKey(name: 'value', includeIfNull: false)
  final String? value;
  @JsonKey(name: 'note', includeIfNull: false)
  final String? note;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isDeleted', includeIfNull: false)
  final bool? isDeleted;
  static const fromJsonFactory = _$SysParamCategoryFromJson;
  static const toJsonFactory = _$SysParamCategoryToJson;
  Map<String, dynamic> toJson() => _$SysParamCategoryToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamCategory &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isDeleted, isDeleted) ||
                const DeepCollectionEquality()
                    .equals(other.isDeleted, isDeleted)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isDeleted) ^
      runtimeType.hashCode;
}

extension $SysParamCategoryExtension on SysParamCategory {
  SysParamCategory copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? key,
      String? value,
      String? note,
      bool? isActive,
      int? order,
      bool? isDeleted}) {
    return SysParamCategory(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        key: key ?? this.key,
        value: value ?? this.value,
        note: note ?? this.note,
        isActive: isActive ?? this.isActive,
        order: order ?? this.order,
        isDeleted: isDeleted ?? this.isDeleted);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamCategoryModel {
  SysParamCategoryModel({
    this.id,
    this.key,
    this.value,
    this.note,
    this.applicationId,
    this.isActive,
    this.order,
    this.isDeleted,
  });

  factory SysParamCategoryModel.fromJson(Map<String, dynamic> json) =>
      _$SysParamCategoryModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'key', includeIfNull: false)
  final String? key;
  @JsonKey(name: 'value', includeIfNull: false)
  final String? value;
  @JsonKey(name: 'note', includeIfNull: false)
  final String? note;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isDeleted', includeIfNull: false)
  final bool? isDeleted;
  static const fromJsonFactory = _$SysParamCategoryModelFromJson;
  static const toJsonFactory = _$SysParamCategoryModelToJson;
  Map<String, dynamic> toJson() => _$SysParamCategoryModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamCategoryModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isDeleted, isDeleted) ||
                const DeepCollectionEquality()
                    .equals(other.isDeleted, isDeleted)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isDeleted) ^
      runtimeType.hashCode;
}

extension $SysParamCategoryModelExtension on SysParamCategoryModel {
  SysParamCategoryModel copyWith(
      {String? id,
      String? key,
      String? value,
      String? note,
      String? applicationId,
      bool? isActive,
      int? order,
      bool? isDeleted}) {
    return SysParamCategoryModel(
        id: id ?? this.id,
        key: key ?? this.key,
        value: value ?? this.value,
        note: note ?? this.note,
        applicationId: applicationId ?? this.applicationId,
        isActive: isActive ?? this.isActive,
        order: order ?? this.order,
        isDeleted: isDeleted ?? this.isDeleted);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamCategoryModelPagination {
  SysParamCategoryModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory SysParamCategoryModelPagination.fromJson(Map<String, dynamic> json) =>
      _$SysParamCategoryModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content',
      includeIfNull: false,
      defaultValue: <SysParamCategoryModel>[])
  final List<SysParamCategoryModel>? content;
  static const fromJsonFactory = _$SysParamCategoryModelPaginationFromJson;
  static const toJsonFactory = _$SysParamCategoryModelPaginationToJson;
  Map<String, dynamic> toJson() =>
      _$SysParamCategoryModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamCategoryModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $SysParamCategoryModelPaginationExtension
    on SysParamCategoryModelPagination {
  SysParamCategoryModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<SysParamCategoryModel>? content}) {
    return SysParamCategoryModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamCategoryModelResponsePagination {
  SysParamCategoryModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory SysParamCategoryModelResponsePagination.fromJson(
          Map<String, dynamic> json) =>
      _$SysParamCategoryModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final SysParamCategoryModelPagination? data;
  static const fromJsonFactory =
      _$SysParamCategoryModelResponsePaginationFromJson;
  static const toJsonFactory = _$SysParamCategoryModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$SysParamCategoryModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamCategoryModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $SysParamCategoryModelResponsePaginationExtension
    on SysParamCategoryModelResponsePagination {
  SysParamCategoryModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      SysParamCategoryModelPagination? data}) {
    return SysParamCategoryModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamCategoryRequestModel {
  SysParamCategoryRequestModel({
    this.key,
    this.value,
    this.note,
    this.isActive,
    this.order,
  });

  factory SysParamCategoryRequestModel.fromJson(Map<String, dynamic> json) =>
      _$SysParamCategoryRequestModelFromJson(json);

  @JsonKey(name: 'key', includeIfNull: false)
  final String? key;
  @JsonKey(name: 'value', includeIfNull: false)
  final String? value;
  @JsonKey(name: 'note', includeIfNull: false)
  final String? note;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  static const fromJsonFactory = _$SysParamCategoryRequestModelFromJson;
  static const toJsonFactory = _$SysParamCategoryRequestModelToJson;
  Map<String, dynamic> toJson() => _$SysParamCategoryRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamCategoryRequestModel &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(order) ^
      runtimeType.hashCode;
}

extension $SysParamCategoryRequestModelExtension
    on SysParamCategoryRequestModel {
  SysParamCategoryRequestModel copyWith(
      {String? key, String? value, String? note, bool? isActive, int? order}) {
    return SysParamCategoryRequestModel(
        key: key ?? this.key,
        value: value ?? this.value,
        note: note ?? this.note,
        isActive: isActive ?? this.isActive,
        order: order ?? this.order);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamCategoryResponseObject {
  SysParamCategoryResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory SysParamCategoryResponseObject.fromJson(Map<String, dynamic> json) =>
      _$SysParamCategoryResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final SysParamCategory? data;
  static const fromJsonFactory = _$SysParamCategoryResponseObjectFromJson;
  static const toJsonFactory = _$SysParamCategoryResponseObjectToJson;
  Map<String, dynamic> toJson() => _$SysParamCategoryResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamCategoryResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $SysParamCategoryResponseObjectExtension
    on SysParamCategoryResponseObject {
  SysParamCategoryResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      SysParamCategory? data}) {
    return SysParamCategoryResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamModel {
  SysParamModel({
    this.id,
    this.categoryId,
    this.parentId,
    this.key,
    this.value,
    this.note,
    this.color,
    this.isActive,
    this.applicationId,
    this.order,
    this.isDeleted,
    this.categoryKey,
    this.category,
    this.conditionFrom,
    this.conditionTo,
    this.valueFrom,
    this.valueTo,
    this.keywords,
    this.cLeft,
    this.cRight,
    this.cLevel,
  });

  factory SysParamModel.fromJson(Map<String, dynamic> json) =>
      _$SysParamModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'categoryId', includeIfNull: false)
  final String? categoryId;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'key', includeIfNull: false)
  final String? key;
  @JsonKey(name: 'value', includeIfNull: false)
  final String? value;
  @JsonKey(name: 'note', includeIfNull: false)
  final String? note;
  @JsonKey(name: 'color', includeIfNull: false)
  final String? color;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isDeleted', includeIfNull: false)
  final bool? isDeleted;
  @JsonKey(name: 'categoryKey', includeIfNull: false)
  final String? categoryKey;
  @JsonKey(name: 'category', includeIfNull: false)
  final String? category;
  @JsonKey(name: 'conditionFrom', includeIfNull: false)
  final double? conditionFrom;
  @JsonKey(name: 'conditionTo', includeIfNull: false)
  final double? conditionTo;
  @JsonKey(name: 'valueFrom', includeIfNull: false)
  final double? valueFrom;
  @JsonKey(name: 'valueTo', includeIfNull: false)
  final double? valueTo;
  @JsonKey(name: 'keywords', includeIfNull: false, defaultValue: <String>[])
  final List<String>? keywords;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  static const fromJsonFactory = _$SysParamModelFromJson;
  static const toJsonFactory = _$SysParamModelToJson;
  Map<String, dynamic> toJson() => _$SysParamModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.color, color) ||
                const DeepCollectionEquality().equals(other.color, color)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isDeleted, isDeleted) ||
                const DeepCollectionEquality()
                    .equals(other.isDeleted, isDeleted)) &&
            (identical(other.categoryKey, categoryKey) ||
                const DeepCollectionEquality()
                    .equals(other.categoryKey, categoryKey)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.conditionFrom, conditionFrom) ||
                const DeepCollectionEquality()
                    .equals(other.conditionFrom, conditionFrom)) &&
            (identical(other.conditionTo, conditionTo) ||
                const DeepCollectionEquality()
                    .equals(other.conditionTo, conditionTo)) &&
            (identical(other.valueFrom, valueFrom) ||
                const DeepCollectionEquality()
                    .equals(other.valueFrom, valueFrom)) &&
            (identical(other.valueTo, valueTo) ||
                const DeepCollectionEquality()
                    .equals(other.valueTo, valueTo)) &&
            (identical(other.keywords, keywords) ||
                const DeepCollectionEquality()
                    .equals(other.keywords, keywords)) &&
            (identical(other.cLeft, cLeft) ||
                const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) ||
                const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) ||
                const DeepCollectionEquality().equals(other.cLevel, cLevel)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(color) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isDeleted) ^
      const DeepCollectionEquality().hash(categoryKey) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(conditionFrom) ^
      const DeepCollectionEquality().hash(conditionTo) ^
      const DeepCollectionEquality().hash(valueFrom) ^
      const DeepCollectionEquality().hash(valueTo) ^
      const DeepCollectionEquality().hash(keywords) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      runtimeType.hashCode;
}

extension $SysParamModelExtension on SysParamModel {
  SysParamModel copyWith(
      {String? id,
      String? categoryId,
      String? parentId,
      String? key,
      String? value,
      String? note,
      String? color,
      bool? isActive,
      String? applicationId,
      int? order,
      bool? isDeleted,
      String? categoryKey,
      String? category,
      double? conditionFrom,
      double? conditionTo,
      double? valueFrom,
      double? valueTo,
      List<String>? keywords,
      int? cLeft,
      int? cRight,
      int? cLevel}) {
    return SysParamModel(
        id: id ?? this.id,
        categoryId: categoryId ?? this.categoryId,
        parentId: parentId ?? this.parentId,
        key: key ?? this.key,
        value: value ?? this.value,
        note: note ?? this.note,
        color: color ?? this.color,
        isActive: isActive ?? this.isActive,
        applicationId: applicationId ?? this.applicationId,
        order: order ?? this.order,
        isDeleted: isDeleted ?? this.isDeleted,
        categoryKey: categoryKey ?? this.categoryKey,
        category: category ?? this.category,
        conditionFrom: conditionFrom ?? this.conditionFrom,
        conditionTo: conditionTo ?? this.conditionTo,
        valueFrom: valueFrom ?? this.valueFrom,
        valueTo: valueTo ?? this.valueTo,
        keywords: keywords ?? this.keywords,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamModelPagination {
  SysParamModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory SysParamModelPagination.fromJson(Map<String, dynamic> json) =>
      _$SysParamModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content', includeIfNull: false, defaultValue: <SysParamModel>[])
  final List<SysParamModel>? content;
  static const fromJsonFactory = _$SysParamModelPaginationFromJson;
  static const toJsonFactory = _$SysParamModelPaginationToJson;
  Map<String, dynamic> toJson() => _$SysParamModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $SysParamModelPaginationExtension on SysParamModelPagination {
  SysParamModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<SysParamModel>? content}) {
    return SysParamModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamModelResponseObject {
  SysParamModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory SysParamModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$SysParamModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final SysParamModel? data;
  static const fromJsonFactory = _$SysParamModelResponseObjectFromJson;
  static const toJsonFactory = _$SysParamModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$SysParamModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $SysParamModelResponseObjectExtension on SysParamModelResponseObject {
  SysParamModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      SysParamModel? data}) {
    return SysParamModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamModelResponsePagination {
  SysParamModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory SysParamModelResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$SysParamModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final SysParamModelPagination? data;
  static const fromJsonFactory = _$SysParamModelResponsePaginationFromJson;
  static const toJsonFactory = _$SysParamModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$SysParamModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $SysParamModelResponsePaginationExtension
    on SysParamModelResponsePagination {
  SysParamModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      SysParamModelPagination? data}) {
    return SysParamModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class SysParamRequestModel {
  SysParamRequestModel({
    this.id,
    this.categoryId,
    this.parentId,
    this.key,
    this.value,
    this.note,
    this.color,
    this.isActive,
    this.applicationId,
    this.order,
    this.isDeleted,
    this.categoryKey,
    this.category,
    this.conditionFrom,
    this.conditionTo,
    this.valueFrom,
    this.valueTo,
    this.keywords,
    this.cLeft,
    this.cRight,
    this.cLevel,
  });

  factory SysParamRequestModel.fromJson(Map<String, dynamic> json) =>
      _$SysParamRequestModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'categoryId', includeIfNull: false)
  final String? categoryId;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'key', includeIfNull: false)
  final String? key;
  @JsonKey(name: 'value', includeIfNull: false)
  final String? value;
  @JsonKey(name: 'note', includeIfNull: false)
  final String? note;
  @JsonKey(name: 'color', includeIfNull: false)
  final String? color;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isDeleted', includeIfNull: false)
  final bool? isDeleted;
  @JsonKey(name: 'categoryKey', includeIfNull: false)
  final String? categoryKey;
  @JsonKey(name: 'category', includeIfNull: false)
  final String? category;
  @JsonKey(name: 'conditionFrom', includeIfNull: false)
  final double? conditionFrom;
  @JsonKey(name: 'conditionTo', includeIfNull: false)
  final double? conditionTo;
  @JsonKey(name: 'valueFrom', includeIfNull: false)
  final double? valueFrom;
  @JsonKey(name: 'valueTo', includeIfNull: false)
  final double? valueTo;
  @JsonKey(name: 'keywords', includeIfNull: false, defaultValue: <String>[])
  final List<String>? keywords;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  static const fromJsonFactory = _$SysParamRequestModelFromJson;
  static const toJsonFactory = _$SysParamRequestModelToJson;
  Map<String, dynamic> toJson() => _$SysParamRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SysParamRequestModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.color, color) ||
                const DeepCollectionEquality().equals(other.color, color)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isDeleted, isDeleted) ||
                const DeepCollectionEquality()
                    .equals(other.isDeleted, isDeleted)) &&
            (identical(other.categoryKey, categoryKey) ||
                const DeepCollectionEquality()
                    .equals(other.categoryKey, categoryKey)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.conditionFrom, conditionFrom) ||
                const DeepCollectionEquality()
                    .equals(other.conditionFrom, conditionFrom)) &&
            (identical(other.conditionTo, conditionTo) ||
                const DeepCollectionEquality()
                    .equals(other.conditionTo, conditionTo)) &&
            (identical(other.valueFrom, valueFrom) ||
                const DeepCollectionEquality()
                    .equals(other.valueFrom, valueFrom)) &&
            (identical(other.valueTo, valueTo) ||
                const DeepCollectionEquality()
                    .equals(other.valueTo, valueTo)) &&
            (identical(other.keywords, keywords) ||
                const DeepCollectionEquality()
                    .equals(other.keywords, keywords)) &&
            (identical(other.cLeft, cLeft) ||
                const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) ||
                const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) ||
                const DeepCollectionEquality().equals(other.cLevel, cLevel)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(color) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isDeleted) ^
      const DeepCollectionEquality().hash(categoryKey) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(conditionFrom) ^
      const DeepCollectionEquality().hash(conditionTo) ^
      const DeepCollectionEquality().hash(valueFrom) ^
      const DeepCollectionEquality().hash(valueTo) ^
      const DeepCollectionEquality().hash(keywords) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      runtimeType.hashCode;
}

extension $SysParamRequestModelExtension on SysParamRequestModel {
  SysParamRequestModel copyWith(
      {String? id,
      String? categoryId,
      String? parentId,
      String? key,
      String? value,
      String? note,
      String? color,
      bool? isActive,
      String? applicationId,
      int? order,
      bool? isDeleted,
      String? categoryKey,
      String? category,
      double? conditionFrom,
      double? conditionTo,
      double? valueFrom,
      double? valueTo,
      List<String>? keywords,
      int? cLeft,
      int? cRight,
      int? cLevel}) {
    return SysParamRequestModel(
        id: id ?? this.id,
        categoryId: categoryId ?? this.categoryId,
        parentId: parentId ?? this.parentId,
        key: key ?? this.key,
        value: value ?? this.value,
        note: note ?? this.note,
        color: color ?? this.color,
        isActive: isActive ?? this.isActive,
        applicationId: applicationId ?? this.applicationId,
        order: order ?? this.order,
        isDeleted: isDeleted ?? this.isDeleted,
        categoryKey: categoryKey ?? this.categoryKey,
        category: category ?? this.category,
        conditionFrom: conditionFrom ?? this.conditionFrom,
        conditionTo: conditionTo ?? this.conditionTo,
        valueFrom: valueFrom ?? this.valueFrom,
        valueTo: valueTo ?? this.valueTo,
        keywords: keywords ?? this.keywords,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskAssigneeResquestModel {
  TaskAssigneeResquestModel({
    this.assigneeObj,
  });

  factory TaskAssigneeResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskAssigneeResquestModelFromJson(json);

  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  static const fromJsonFactory = _$TaskAssigneeResquestModelFromJson;
  static const toJsonFactory = _$TaskAssigneeResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskAssigneeResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskAssigneeResquestModel &&
            (identical(other.assigneeObj, assigneeObj) ||
                const DeepCollectionEquality()
                    .equals(other.assigneeObj, assigneeObj)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assigneeObj) ^ runtimeType.hashCode;
}

extension $TaskAssigneeResquestModelExtension on TaskAssigneeResquestModel {
  TaskAssigneeResquestModel copyWith({List<String>? assigneeObj}) {
    return TaskAssigneeResquestModel(
        assigneeObj: assigneeObj ?? this.assigneeObj);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskBaseModel {
  TaskBaseModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.acl,
    this.id,
    required this.name,
    this.description,
    this.parentId,
    this.parentType,
    this.priorityObj,
    this.priority,
    this.weight,
    this.rank,
    this.labelsObjs,
    this.labels,
    this.managementObj,
    this.management,
    this.ownerObj,
    this.owner,
    this.supervisorObj,
    this.supervisor,
    this.coordinatorObj,
    this.coordinator,
    this.assigneeObj,
    this.assignee,
    this.viewerObj,
    this.viewer,
    this.statusObj,
    this.status,
    this.objectId,
    this.objectType,
    this.objectAction,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.allowToModify,
    this.allowToView,
    this.allowToChangeStatus,
    this.allowToModifyCoordinator,
    this.allowToModifyFromDate,
    this.allowToModifyToDate,
    this.allowToModifyFinishDate,
    this.relatedFolderId,
    this.allowToCreateSubTasks,
    this.aclObject,
    this.projectId,
    this.code,
    this.type,
    this.attachment,
    this.workflowStatus,
    this.metadata,
    this.ref,
  });

  factory TaskBaseModel.fromJson(Map<String, dynamic> json) =>
      _$TaskBaseModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'acl', includeIfNull: false)
  final String? acl;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentType', includeIfNull: false)
  final String? parentType;
  @JsonKey(
      name: 'priorityObj',
      includeIfNull: false,
      toJson: priorityEnumsToJson,
      fromJson: priorityEnumsFromJson)
  final enums.PriorityEnums? priorityObj;
  @JsonKey(name: 'priority', includeIfNull: false)
  final int? priority;
  @JsonKey(name: 'weight', includeIfNull: false)
  final int? weight;
  @JsonKey(name: 'rank', includeIfNull: false)
  final int? rank;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labels', includeIfNull: false)
  final String? labels;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'management', includeIfNull: false)
  final String? management;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(name: 'owner', includeIfNull: false)
  final String? owner;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(name: 'supervisor', includeIfNull: false)
  final String? supervisor;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'coordinator', includeIfNull: false)
  final String? coordinator;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'assignee', includeIfNull: false)
  final String? assignee;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'viewer', includeIfNull: false)
  final String? viewer;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: pMStatusEnumsToJson,
      fromJson: pMStatusEnumsFromJson)
  final enums.PMStatusEnums? statusObj;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectAction', includeIfNull: false)
  final String? objectAction;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'allowToModify', includeIfNull: false)
  final bool? allowToModify;
  @JsonKey(name: 'allowToView', includeIfNull: false)
  final bool? allowToView;
  @JsonKey(name: 'allowToChangeStatus', includeIfNull: false)
  final bool? allowToChangeStatus;
  @JsonKey(name: 'allowToModifyCoordinator', includeIfNull: false)
  final bool? allowToModifyCoordinator;
  @JsonKey(name: 'allowToModifyFromDate', includeIfNull: false)
  final bool? allowToModifyFromDate;
  @JsonKey(name: 'allowToModifyToDate', includeIfNull: false)
  final bool? allowToModifyToDate;
  @JsonKey(name: 'allowToModifyFinishDate', includeIfNull: false)
  final bool? allowToModifyFinishDate;
  @JsonKey(name: 'relatedFolderId', includeIfNull: false)
  final String? relatedFolderId;
  @JsonKey(name: 'allowToCreateSubTasks', includeIfNull: false)
  final bool? allowToCreateSubTasks;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'projectId', includeIfNull: false)
  final String? projectId;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'attachment', includeIfNull: false)
  final String? attachment;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final int? workflowStatus;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final String? metadata;
  @JsonKey(name: 'ref', includeIfNull: false)
  final String? ref;
  static const fromJsonFactory = _$TaskBaseModelFromJson;
  static const toJsonFactory = _$TaskBaseModelToJson;
  Map<String, dynamic> toJson() => _$TaskBaseModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskBaseModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentType, parentType) ||
                const DeepCollectionEquality()
                    .equals(other.parentType, parentType)) &&
            (identical(other.priorityObj, priorityObj) ||
                const DeepCollectionEquality()
                    .equals(other.priorityObj, priorityObj)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.management, management) ||
                const DeepCollectionEquality()
                    .equals(other.management, management)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.supervisor, supervisor) ||
                const DeepCollectionEquality()
                    .equals(other.supervisor, supervisor)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.coordinator, coordinator) ||
                const DeepCollectionEquality()
                    .equals(other.coordinator, coordinator)) &&
            (identical(other.assigneeObj, assigneeObj) || const DeepCollectionEquality().equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.assignee, assignee) || const DeepCollectionEquality().equals(other.assignee, assignee)) &&
            (identical(other.viewerObj, viewerObj) || const DeepCollectionEquality().equals(other.viewerObj, viewerObj)) &&
            (identical(other.viewer, viewer) || const DeepCollectionEquality().equals(other.viewer, viewer)) &&
            (identical(other.statusObj, statusObj) || const DeepCollectionEquality().equals(other.statusObj, statusObj)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.objectId, objectId) || const DeepCollectionEquality().equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) || const DeepCollectionEquality().equals(other.objectType, objectType)) &&
            (identical(other.objectAction, objectAction) || const DeepCollectionEquality().equals(other.objectAction, objectAction)) &&
            (identical(other.fromDate, fromDate) || const DeepCollectionEquality().equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) || const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) || const DeepCollectionEquality().equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) || const DeepCollectionEquality().equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) || const DeepCollectionEquality().equals(other.actualTime, actualTime)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) || const DeepCollectionEquality().equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) || const DeepCollectionEquality().equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) || const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) || const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) || const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.allowToModify, allowToModify) || const DeepCollectionEquality().equals(other.allowToModify, allowToModify)) &&
            (identical(other.allowToView, allowToView) || const DeepCollectionEquality().equals(other.allowToView, allowToView)) &&
            (identical(other.allowToChangeStatus, allowToChangeStatus) || const DeepCollectionEquality().equals(other.allowToChangeStatus, allowToChangeStatus)) &&
            (identical(other.allowToModifyCoordinator, allowToModifyCoordinator) || const DeepCollectionEquality().equals(other.allowToModifyCoordinator, allowToModifyCoordinator)) &&
            (identical(other.allowToModifyFromDate, allowToModifyFromDate) || const DeepCollectionEquality().equals(other.allowToModifyFromDate, allowToModifyFromDate)) &&
            (identical(other.allowToModifyToDate, allowToModifyToDate) || const DeepCollectionEquality().equals(other.allowToModifyToDate, allowToModifyToDate)) &&
            (identical(other.allowToModifyFinishDate, allowToModifyFinishDate) || const DeepCollectionEquality().equals(other.allowToModifyFinishDate, allowToModifyFinishDate)) &&
            (identical(other.relatedFolderId, relatedFolderId) || const DeepCollectionEquality().equals(other.relatedFolderId, relatedFolderId)) &&
            (identical(other.allowToCreateSubTasks, allowToCreateSubTasks) || const DeepCollectionEquality().equals(other.allowToCreateSubTasks, allowToCreateSubTasks)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.projectId, projectId) || const DeepCollectionEquality().equals(other.projectId, projectId)) &&
            (identical(other.code, code) || const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.attachment, attachment) || const DeepCollectionEquality().equals(other.attachment, attachment)) &&
            (identical(other.workflowStatus, workflowStatus) || const DeepCollectionEquality().equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.metadata, metadata) || const DeepCollectionEquality().equals(other.metadata, metadata)) &&
            (identical(other.ref, ref) || const DeepCollectionEquality().equals(other.ref, ref)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentType) ^
      const DeepCollectionEquality().hash(priorityObj) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(management) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(supervisor) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(coordinator) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(viewer) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectAction) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(allowToModify) ^
      const DeepCollectionEquality().hash(allowToView) ^
      const DeepCollectionEquality().hash(allowToChangeStatus) ^
      const DeepCollectionEquality().hash(allowToModifyCoordinator) ^
      const DeepCollectionEquality().hash(allowToModifyFromDate) ^
      const DeepCollectionEquality().hash(allowToModifyToDate) ^
      const DeepCollectionEquality().hash(allowToModifyFinishDate) ^
      const DeepCollectionEquality().hash(relatedFolderId) ^
      const DeepCollectionEquality().hash(allowToCreateSubTasks) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(attachment) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(ref) ^
      runtimeType.hashCode;
}

extension $TaskBaseModelExtension on TaskBaseModel {
  TaskBaseModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? acl,
      String? id,
      String? name,
      String? description,
      String? parentId,
      String? parentType,
      enums.PriorityEnums? priorityObj,
      int? priority,
      int? weight,
      int? rank,
      List<LabelsObj>? labelsObjs,
      String? labels,
      List<String>? managementObj,
      String? management,
      List<String>? ownerObj,
      String? owner,
      List<String>? supervisorObj,
      String? supervisor,
      List<String>? coordinatorObj,
      String? coordinator,
      List<String>? assigneeObj,
      String? assignee,
      List<String>? viewerObj,
      String? viewer,
      enums.PMStatusEnums? statusObj,
      int? status,
      String? objectId,
      String? objectType,
      String? objectAction,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel,
      bool? allowToModify,
      bool? allowToView,
      bool? allowToChangeStatus,
      bool? allowToModifyCoordinator,
      bool? allowToModifyFromDate,
      bool? allowToModifyToDate,
      bool? allowToModifyFinishDate,
      String? relatedFolderId,
      bool? allowToCreateSubTasks,
      ACLObject? aclObject,
      String? projectId,
      String? code,
      String? type,
      String? attachment,
      int? workflowStatus,
      String? metadata,
      String? ref}) {
    return TaskBaseModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        acl: acl ?? this.acl,
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        parentId: parentId ?? this.parentId,
        parentType: parentType ?? this.parentType,
        priorityObj: priorityObj ?? this.priorityObj,
        priority: priority ?? this.priority,
        weight: weight ?? this.weight,
        rank: rank ?? this.rank,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labels: labels ?? this.labels,
        managementObj: managementObj ?? this.managementObj,
        management: management ?? this.management,
        ownerObj: ownerObj ?? this.ownerObj,
        owner: owner ?? this.owner,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        supervisor: supervisor ?? this.supervisor,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        coordinator: coordinator ?? this.coordinator,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        assignee: assignee ?? this.assignee,
        viewerObj: viewerObj ?? this.viewerObj,
        viewer: viewer ?? this.viewer,
        statusObj: statusObj ?? this.statusObj,
        status: status ?? this.status,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        objectAction: objectAction ?? this.objectAction,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        allowToModify: allowToModify ?? this.allowToModify,
        allowToView: allowToView ?? this.allowToView,
        allowToChangeStatus: allowToChangeStatus ?? this.allowToChangeStatus,
        allowToModifyCoordinator:
            allowToModifyCoordinator ?? this.allowToModifyCoordinator,
        allowToModifyFromDate:
            allowToModifyFromDate ?? this.allowToModifyFromDate,
        allowToModifyToDate: allowToModifyToDate ?? this.allowToModifyToDate,
        allowToModifyFinishDate:
            allowToModifyFinishDate ?? this.allowToModifyFinishDate,
        relatedFolderId: relatedFolderId ?? this.relatedFolderId,
        allowToCreateSubTasks:
            allowToCreateSubTasks ?? this.allowToCreateSubTasks,
        aclObject: aclObject ?? this.aclObject,
        projectId: projectId ?? this.projectId,
        code: code ?? this.code,
        type: type ?? this.type,
        attachment: attachment ?? this.attachment,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        metadata: metadata ?? this.metadata,
        ref: ref ?? this.ref);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskBaseModelResponseObject {
  TaskBaseModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory TaskBaseModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$TaskBaseModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final TaskBaseModel? data;
  static const fromJsonFactory = _$TaskBaseModelResponseObjectFromJson;
  static const toJsonFactory = _$TaskBaseModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$TaskBaseModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskBaseModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $TaskBaseModelResponseObjectExtension on TaskBaseModelResponseObject {
  TaskBaseModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      TaskBaseModel? data}) {
    return TaskBaseModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskCorrdinatorResquestModel {
  TaskCorrdinatorResquestModel({
    this.coordinatorObj,
  });

  factory TaskCorrdinatorResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskCorrdinatorResquestModelFromJson(json);

  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  static const fromJsonFactory = _$TaskCorrdinatorResquestModelFromJson;
  static const toJsonFactory = _$TaskCorrdinatorResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskCorrdinatorResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskCorrdinatorResquestModel &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(coordinatorObj) ^
      runtimeType.hashCode;
}

extension $TaskCorrdinatorResquestModelExtension
    on TaskCorrdinatorResquestModel {
  TaskCorrdinatorResquestModel copyWith({List<String>? coordinatorObj}) {
    return TaskCorrdinatorResquestModel(
        coordinatorObj: coordinatorObj ?? this.coordinatorObj);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskExternalLinkModel {
  TaskExternalLinkModel({
    this.listTaskId,
    this.objectId,
    this.objectType,
    this.objectAction,
  });

  factory TaskExternalLinkModel.fromJson(Map<String, dynamic> json) =>
      _$TaskExternalLinkModelFromJson(json);

  @JsonKey(name: 'listTaskId', includeIfNull: false, defaultValue: <String>[])
  final List<String>? listTaskId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectAction', includeIfNull: false)
  final String? objectAction;
  static const fromJsonFactory = _$TaskExternalLinkModelFromJson;
  static const toJsonFactory = _$TaskExternalLinkModelToJson;
  Map<String, dynamic> toJson() => _$TaskExternalLinkModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskExternalLinkModel &&
            (identical(other.listTaskId, listTaskId) ||
                const DeepCollectionEquality()
                    .equals(other.listTaskId, listTaskId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.objectAction, objectAction) ||
                const DeepCollectionEquality()
                    .equals(other.objectAction, objectAction)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(listTaskId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectAction) ^
      runtimeType.hashCode;
}

extension $TaskExternalLinkModelExtension on TaskExternalLinkModel {
  TaskExternalLinkModel copyWith(
      {List<String>? listTaskId,
      String? objectId,
      String? objectType,
      String? objectAction}) {
    return TaskExternalLinkModel(
        listTaskId: listTaskId ?? this.listTaskId,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        objectAction: objectAction ?? this.objectAction);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskGenerateByTempResquestModel {
  TaskGenerateByTempResquestModel({
    this.templateId,
    this.projectId,
  });

  factory TaskGenerateByTempResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskGenerateByTempResquestModelFromJson(json);

  @JsonKey(name: 'templateId', includeIfNull: false)
  final String? templateId;
  @JsonKey(name: 'projectId', includeIfNull: false)
  final String? projectId;
  static const fromJsonFactory = _$TaskGenerateByTempResquestModelFromJson;
  static const toJsonFactory = _$TaskGenerateByTempResquestModelToJson;
  Map<String, dynamic> toJson() =>
      _$TaskGenerateByTempResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskGenerateByTempResquestModel &&
            (identical(other.templateId, templateId) ||
                const DeepCollectionEquality()
                    .equals(other.templateId, templateId)) &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(templateId) ^
      const DeepCollectionEquality().hash(projectId) ^
      runtimeType.hashCode;
}

extension $TaskGenerateByTempResquestModelExtension
    on TaskGenerateByTempResquestModel {
  TaskGenerateByTempResquestModel copyWith(
      {String? templateId, String? projectId}) {
    return TaskGenerateByTempResquestModel(
        templateId: templateId ?? this.templateId,
        projectId: projectId ?? this.projectId);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskManagementResquestModel {
  TaskManagementResquestModel({
    this.managementObj,
  });

  factory TaskManagementResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskManagementResquestModelFromJson(json);

  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  static const fromJsonFactory = _$TaskManagementResquestModelFromJson;
  static const toJsonFactory = _$TaskManagementResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskManagementResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskManagementResquestModel &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(managementObj) ^ runtimeType.hashCode;
}

extension $TaskManagementResquestModelExtension on TaskManagementResquestModel {
  TaskManagementResquestModel copyWith({List<String>? managementObj}) {
    return TaskManagementResquestModel(
        managementObj: managementObj ?? this.managementObj);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskOwnerResquestModel {
  TaskOwnerResquestModel({
    this.ownerObj,
  });

  factory TaskOwnerResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskOwnerResquestModelFromJson(json);

  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  static const fromJsonFactory = _$TaskOwnerResquestModelFromJson;
  static const toJsonFactory = _$TaskOwnerResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskOwnerResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskOwnerResquestModel &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ownerObj) ^ runtimeType.hashCode;
}

extension $TaskOwnerResquestModelExtension on TaskOwnerResquestModel {
  TaskOwnerResquestModel copyWith({List<String>? ownerObj}) {
    return TaskOwnerResquestModel(ownerObj: ownerObj ?? this.ownerObj);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskPatchResquestModel {
  TaskPatchResquestModel({
    this.id,
    this.parentId,
    this.code,
    this.name,
    this.description,
    this.order,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.labelsObjs,
    this.priorityObj,
    this.weight,
    this.rank,
    this.statusObj,
    this.managementObj,
    this.ownerObj,
    this.supervisorObj,
    this.coordinatorObj,
    this.assigneeObj,
    this.viewerObj,
    this.metadataContentObjs,
    this.aclObject,
    this.metaContentType,
    this.projectId,
    this.type,
    this.workflowStatus,
    this.objectId,
    this.objectAction,
    this.objectType,
  });

  factory TaskPatchResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskPatchResquestModelFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'priorityObj',
      includeIfNull: false,
      toJson: priorityEnumsToJson,
      fromJson: priorityEnumsFromJson)
  final enums.PriorityEnums? priorityObj;
  @JsonKey(name: 'weight', includeIfNull: false)
  final int? weight;
  @JsonKey(name: 'rank', includeIfNull: false)
  final int? rank;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: pMStatusEnumsToJson,
      fromJson: pMStatusEnumsFromJson)
  final enums.PMStatusEnums? statusObj;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'projectId', includeIfNull: false)
  final String? projectId;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final int? workflowStatus;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectAction', includeIfNull: false)
  final String? objectAction;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  static const fromJsonFactory = _$TaskPatchResquestModelFromJson;
  static const toJsonFactory = _$TaskPatchResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskPatchResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskPatchResquestModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.fromDate, fromDate) ||
                const DeepCollectionEquality()
                    .equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) ||
                const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) ||
                const DeepCollectionEquality()
                    .equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) ||
                const DeepCollectionEquality()
                    .equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) ||
                const DeepCollectionEquality()
                    .equals(other.actualTime, actualTime)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.priorityObj, priorityObj) ||
                const DeepCollectionEquality()
                    .equals(other.priorityObj, priorityObj)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.statusObj, statusObj) ||
                const DeepCollectionEquality()
                    .equals(other.statusObj, statusObj)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.assigneeObj, assigneeObj) ||
                const DeepCollectionEquality()
                    .equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.viewerObj, viewerObj) ||
                const DeepCollectionEquality()
                    .equals(other.viewerObj, viewerObj)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.aclObject, aclObject) ||
                const DeepCollectionEquality()
                    .equals(other.aclObject, aclObject)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.projectId, projectId) || const DeepCollectionEquality().equals(other.projectId, projectId)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.workflowStatus, workflowStatus) || const DeepCollectionEquality().equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.objectId, objectId) || const DeepCollectionEquality().equals(other.objectId, objectId)) &&
            (identical(other.objectAction, objectAction) || const DeepCollectionEquality().equals(other.objectAction, objectAction)) &&
            (identical(other.objectType, objectType) || const DeepCollectionEquality().equals(other.objectType, objectType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(priorityObj) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectAction) ^
      const DeepCollectionEquality().hash(objectType) ^
      runtimeType.hashCode;
}

extension $TaskPatchResquestModelExtension on TaskPatchResquestModel {
  TaskPatchResquestModel copyWith(
      {String? id,
      String? parentId,
      String? code,
      String? name,
      String? description,
      int? order,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<LabelsObj>? labelsObjs,
      enums.PriorityEnums? priorityObj,
      int? weight,
      int? rank,
      enums.PMStatusEnums? statusObj,
      List<String>? managementObj,
      List<String>? ownerObj,
      List<String>? supervisorObj,
      List<String>? coordinatorObj,
      List<String>? assigneeObj,
      List<String>? viewerObj,
      List<MetadataValue>? metadataContentObjs,
      ACLObject? aclObject,
      String? metaContentType,
      String? projectId,
      String? type,
      int? workflowStatus,
      String? objectId,
      String? objectAction,
      String? objectType}) {
    return TaskPatchResquestModel(
        id: id ?? this.id,
        parentId: parentId ?? this.parentId,
        code: code ?? this.code,
        name: name ?? this.name,
        description: description ?? this.description,
        order: order ?? this.order,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        priorityObj: priorityObj ?? this.priorityObj,
        weight: weight ?? this.weight,
        rank: rank ?? this.rank,
        statusObj: statusObj ?? this.statusObj,
        managementObj: managementObj ?? this.managementObj,
        ownerObj: ownerObj ?? this.ownerObj,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        viewerObj: viewerObj ?? this.viewerObj,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        aclObject: aclObject ?? this.aclObject,
        metaContentType: metaContentType ?? this.metaContentType,
        projectId: projectId ?? this.projectId,
        type: type ?? this.type,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        objectId: objectId ?? this.objectId,
        objectAction: objectAction ?? this.objectAction,
        objectType: objectType ?? this.objectType);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskRelationResquestModel {
  TaskRelationResquestModel({
    this.relationTypeObj,
    this.taskId,
    this.note,
  });

  factory TaskRelationResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskRelationResquestModelFromJson(json);

  @JsonKey(
      name: 'relationTypeObj',
      includeIfNull: false,
      toJson: relationTypeEnumsToJson,
      fromJson: relationTypeEnumsFromJson)
  final enums.RelationTypeEnums? relationTypeObj;
  @JsonKey(name: 'taskId', includeIfNull: false)
  final String? taskId;
  @JsonKey(name: 'note', includeIfNull: false)
  final String? note;
  static const fromJsonFactory = _$TaskRelationResquestModelFromJson;
  static const toJsonFactory = _$TaskRelationResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskRelationResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskRelationResquestModel &&
            (identical(other.relationTypeObj, relationTypeObj) ||
                const DeepCollectionEquality()
                    .equals(other.relationTypeObj, relationTypeObj)) &&
            (identical(other.taskId, taskId) ||
                const DeepCollectionEquality().equals(other.taskId, taskId)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(relationTypeObj) ^
      const DeepCollectionEquality().hash(taskId) ^
      const DeepCollectionEquality().hash(note) ^
      runtimeType.hashCode;
}

extension $TaskRelationResquestModelExtension on TaskRelationResquestModel {
  TaskRelationResquestModel copyWith(
      {enums.RelationTypeEnums? relationTypeObj,
      String? taskId,
      String? note}) {
    return TaskRelationResquestModel(
        relationTypeObj: relationTypeObj ?? this.relationTypeObj,
        taskId: taskId ?? this.taskId,
        note: note ?? this.note);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskResquestModel {
  TaskResquestModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.acl,
    this.id,
    required this.name,
    this.description,
    this.parentId,
    this.parentType,
    this.priorityObj,
    this.priority,
    this.weight,
    this.rank,
    this.labelsObjs,
    this.labels,
    this.managementObj,
    this.management,
    this.ownerObj,
    this.owner,
    this.supervisorObj,
    this.supervisor,
    this.coordinatorObj,
    this.coordinator,
    this.assigneeObj,
    this.assignee,
    this.viewerObj,
    this.viewer,
    this.statusObj,
    this.status,
    this.objectId,
    this.objectType,
    this.objectAction,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.allowToModify,
    this.allowToView,
    this.allowToChangeStatus,
    this.allowToModifyCoordinator,
    this.allowToModifyFromDate,
    this.allowToModifyToDate,
    this.allowToModifyFinishDate,
    this.relatedFolderId,
    this.allowToCreateSubTasks,
    this.aclObject,
    this.projectId,
    this.code,
    this.type,
    this.attachment,
    this.workflowStatus,
    this.metadata,
    this.ref,
  });

  factory TaskResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskResquestModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'acl', includeIfNull: false)
  final String? acl;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentType', includeIfNull: false)
  final String? parentType;
  @JsonKey(
      name: 'priorityObj',
      includeIfNull: false,
      toJson: priorityEnumsToJson,
      fromJson: priorityEnumsFromJson)
  final enums.PriorityEnums? priorityObj;
  @JsonKey(name: 'priority', includeIfNull: false)
  final int? priority;
  @JsonKey(name: 'weight', includeIfNull: false)
  final int? weight;
  @JsonKey(name: 'rank', includeIfNull: false)
  final int? rank;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labels', includeIfNull: false)
  final String? labels;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'management', includeIfNull: false)
  final String? management;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(name: 'owner', includeIfNull: false)
  final String? owner;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(name: 'supervisor', includeIfNull: false)
  final String? supervisor;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'coordinator', includeIfNull: false)
  final String? coordinator;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'assignee', includeIfNull: false)
  final String? assignee;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'viewer', includeIfNull: false)
  final String? viewer;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: pMStatusEnumsToJson,
      fromJson: pMStatusEnumsFromJson)
  final enums.PMStatusEnums? statusObj;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectAction', includeIfNull: false)
  final String? objectAction;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'allowToModify', includeIfNull: false)
  final bool? allowToModify;
  @JsonKey(name: 'allowToView', includeIfNull: false)
  final bool? allowToView;
  @JsonKey(name: 'allowToChangeStatus', includeIfNull: false)
  final bool? allowToChangeStatus;
  @JsonKey(name: 'allowToModifyCoordinator', includeIfNull: false)
  final bool? allowToModifyCoordinator;
  @JsonKey(name: 'allowToModifyFromDate', includeIfNull: false)
  final bool? allowToModifyFromDate;
  @JsonKey(name: 'allowToModifyToDate', includeIfNull: false)
  final bool? allowToModifyToDate;
  @JsonKey(name: 'allowToModifyFinishDate', includeIfNull: false)
  final bool? allowToModifyFinishDate;
  @JsonKey(name: 'relatedFolderId', includeIfNull: false)
  final String? relatedFolderId;
  @JsonKey(name: 'allowToCreateSubTasks', includeIfNull: false)
  final bool? allowToCreateSubTasks;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'projectId', includeIfNull: false)
  final String? projectId;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'attachment', includeIfNull: false)
  final String? attachment;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final int? workflowStatus;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final String? metadata;
  @JsonKey(name: 'ref', includeIfNull: false)
  final String? ref;
  static const fromJsonFactory = _$TaskResquestModelFromJson;
  static const toJsonFactory = _$TaskResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskResquestModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentType, parentType) ||
                const DeepCollectionEquality()
                    .equals(other.parentType, parentType)) &&
            (identical(other.priorityObj, priorityObj) ||
                const DeepCollectionEquality()
                    .equals(other.priorityObj, priorityObj)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.management, management) ||
                const DeepCollectionEquality()
                    .equals(other.management, management)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.supervisor, supervisor) ||
                const DeepCollectionEquality()
                    .equals(other.supervisor, supervisor)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.coordinator, coordinator) ||
                const DeepCollectionEquality()
                    .equals(other.coordinator, coordinator)) &&
            (identical(other.assigneeObj, assigneeObj) || const DeepCollectionEquality().equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.assignee, assignee) || const DeepCollectionEquality().equals(other.assignee, assignee)) &&
            (identical(other.viewerObj, viewerObj) || const DeepCollectionEquality().equals(other.viewerObj, viewerObj)) &&
            (identical(other.viewer, viewer) || const DeepCollectionEquality().equals(other.viewer, viewer)) &&
            (identical(other.statusObj, statusObj) || const DeepCollectionEquality().equals(other.statusObj, statusObj)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.objectId, objectId) || const DeepCollectionEquality().equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) || const DeepCollectionEquality().equals(other.objectType, objectType)) &&
            (identical(other.objectAction, objectAction) || const DeepCollectionEquality().equals(other.objectAction, objectAction)) &&
            (identical(other.fromDate, fromDate) || const DeepCollectionEquality().equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) || const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) || const DeepCollectionEquality().equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) || const DeepCollectionEquality().equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) || const DeepCollectionEquality().equals(other.actualTime, actualTime)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) || const DeepCollectionEquality().equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) || const DeepCollectionEquality().equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) || const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) || const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) || const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.allowToModify, allowToModify) || const DeepCollectionEquality().equals(other.allowToModify, allowToModify)) &&
            (identical(other.allowToView, allowToView) || const DeepCollectionEquality().equals(other.allowToView, allowToView)) &&
            (identical(other.allowToChangeStatus, allowToChangeStatus) || const DeepCollectionEquality().equals(other.allowToChangeStatus, allowToChangeStatus)) &&
            (identical(other.allowToModifyCoordinator, allowToModifyCoordinator) || const DeepCollectionEquality().equals(other.allowToModifyCoordinator, allowToModifyCoordinator)) &&
            (identical(other.allowToModifyFromDate, allowToModifyFromDate) || const DeepCollectionEquality().equals(other.allowToModifyFromDate, allowToModifyFromDate)) &&
            (identical(other.allowToModifyToDate, allowToModifyToDate) || const DeepCollectionEquality().equals(other.allowToModifyToDate, allowToModifyToDate)) &&
            (identical(other.allowToModifyFinishDate, allowToModifyFinishDate) || const DeepCollectionEquality().equals(other.allowToModifyFinishDate, allowToModifyFinishDate)) &&
            (identical(other.relatedFolderId, relatedFolderId) || const DeepCollectionEquality().equals(other.relatedFolderId, relatedFolderId)) &&
            (identical(other.allowToCreateSubTasks, allowToCreateSubTasks) || const DeepCollectionEquality().equals(other.allowToCreateSubTasks, allowToCreateSubTasks)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.projectId, projectId) || const DeepCollectionEquality().equals(other.projectId, projectId)) &&
            (identical(other.code, code) || const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.attachment, attachment) || const DeepCollectionEquality().equals(other.attachment, attachment)) &&
            (identical(other.workflowStatus, workflowStatus) || const DeepCollectionEquality().equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.metadata, metadata) || const DeepCollectionEquality().equals(other.metadata, metadata)) &&
            (identical(other.ref, ref) || const DeepCollectionEquality().equals(other.ref, ref)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentType) ^
      const DeepCollectionEquality().hash(priorityObj) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(management) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(supervisor) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(coordinator) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(viewer) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectAction) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(allowToModify) ^
      const DeepCollectionEquality().hash(allowToView) ^
      const DeepCollectionEquality().hash(allowToChangeStatus) ^
      const DeepCollectionEquality().hash(allowToModifyCoordinator) ^
      const DeepCollectionEquality().hash(allowToModifyFromDate) ^
      const DeepCollectionEquality().hash(allowToModifyToDate) ^
      const DeepCollectionEquality().hash(allowToModifyFinishDate) ^
      const DeepCollectionEquality().hash(relatedFolderId) ^
      const DeepCollectionEquality().hash(allowToCreateSubTasks) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(attachment) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(ref) ^
      runtimeType.hashCode;
}

extension $TaskResquestModelExtension on TaskResquestModel {
  TaskResquestModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? acl,
      String? id,
      String? name,
      String? description,
      String? parentId,
      String? parentType,
      enums.PriorityEnums? priorityObj,
      int? priority,
      int? weight,
      int? rank,
      List<LabelsObj>? labelsObjs,
      String? labels,
      List<String>? managementObj,
      String? management,
      List<String>? ownerObj,
      String? owner,
      List<String>? supervisorObj,
      String? supervisor,
      List<String>? coordinatorObj,
      String? coordinator,
      List<String>? assigneeObj,
      String? assignee,
      List<String>? viewerObj,
      String? viewer,
      enums.PMStatusEnums? statusObj,
      int? status,
      String? objectId,
      String? objectType,
      String? objectAction,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel,
      bool? allowToModify,
      bool? allowToView,
      bool? allowToChangeStatus,
      bool? allowToModifyCoordinator,
      bool? allowToModifyFromDate,
      bool? allowToModifyToDate,
      bool? allowToModifyFinishDate,
      String? relatedFolderId,
      bool? allowToCreateSubTasks,
      ACLObject? aclObject,
      String? projectId,
      String? code,
      String? type,
      String? attachment,
      int? workflowStatus,
      String? metadata,
      String? ref}) {
    return TaskResquestModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        acl: acl ?? this.acl,
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        parentId: parentId ?? this.parentId,
        parentType: parentType ?? this.parentType,
        priorityObj: priorityObj ?? this.priorityObj,
        priority: priority ?? this.priority,
        weight: weight ?? this.weight,
        rank: rank ?? this.rank,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labels: labels ?? this.labels,
        managementObj: managementObj ?? this.managementObj,
        management: management ?? this.management,
        ownerObj: ownerObj ?? this.ownerObj,
        owner: owner ?? this.owner,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        supervisor: supervisor ?? this.supervisor,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        coordinator: coordinator ?? this.coordinator,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        assignee: assignee ?? this.assignee,
        viewerObj: viewerObj ?? this.viewerObj,
        viewer: viewer ?? this.viewer,
        statusObj: statusObj ?? this.statusObj,
        status: status ?? this.status,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        objectAction: objectAction ?? this.objectAction,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        allowToModify: allowToModify ?? this.allowToModify,
        allowToView: allowToView ?? this.allowToView,
        allowToChangeStatus: allowToChangeStatus ?? this.allowToChangeStatus,
        allowToModifyCoordinator:
            allowToModifyCoordinator ?? this.allowToModifyCoordinator,
        allowToModifyFromDate:
            allowToModifyFromDate ?? this.allowToModifyFromDate,
        allowToModifyToDate: allowToModifyToDate ?? this.allowToModifyToDate,
        allowToModifyFinishDate:
            allowToModifyFinishDate ?? this.allowToModifyFinishDate,
        relatedFolderId: relatedFolderId ?? this.relatedFolderId,
        allowToCreateSubTasks:
            allowToCreateSubTasks ?? this.allowToCreateSubTasks,
        aclObject: aclObject ?? this.aclObject,
        projectId: projectId ?? this.projectId,
        code: code ?? this.code,
        type: type ?? this.type,
        attachment: attachment ?? this.attachment,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        metadata: metadata ?? this.metadata,
        ref: ref ?? this.ref);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskSupervisorResquestModel {
  TaskSupervisorResquestModel({
    this.supervisorObj,
  });

  factory TaskSupervisorResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskSupervisorResquestModelFromJson(json);

  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  static const fromJsonFactory = _$TaskSupervisorResquestModelFromJson;
  static const toJsonFactory = _$TaskSupervisorResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskSupervisorResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskSupervisorResquestModel &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(supervisorObj) ^ runtimeType.hashCode;
}

extension $TaskSupervisorResquestModelExtension on TaskSupervisorResquestModel {
  TaskSupervisorResquestModel copyWith({List<String>? supervisorObj}) {
    return TaskSupervisorResquestModel(
        supervisorObj: supervisorObj ?? this.supervisorObj);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskTemplateRequestModel {
  TaskTemplateRequestModel({
    this.code,
    this.parentId,
  });

  factory TaskTemplateRequestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskTemplateRequestModelFromJson(json);

  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  static const fromJsonFactory = _$TaskTemplateRequestModelFromJson;
  static const toJsonFactory = _$TaskTemplateRequestModelToJson;
  Map<String, dynamic> toJson() => _$TaskTemplateRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskTemplateRequestModel &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(parentId) ^
      runtimeType.hashCode;
}

extension $TaskTemplateRequestModelExtension on TaskTemplateRequestModel {
  TaskTemplateRequestModel copyWith({String? code, String? parentId}) {
    return TaskTemplateRequestModel(
        code: code ?? this.code, parentId: parentId ?? this.parentId);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskTemplateResquestModel {
  TaskTemplateResquestModel({
    this.parentId,
    this.name,
    required this.code,
    this.description,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.labelsObjs,
    this.managementObj,
    this.ownerObj,
    this.supervisorObj,
    this.coordinatorObj,
    this.assigneeObj,
    this.viewerObj,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
  });

  factory TaskTemplateResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TaskTemplateResquestModelFromJson(json);

  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'code', includeIfNull: false)
  final String code;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  static const fromJsonFactory = _$TaskTemplateResquestModelFromJson;
  static const toJsonFactory = _$TaskTemplateResquestModelToJson;
  Map<String, dynamic> toJson() => _$TaskTemplateResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskTemplateResquestModel &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.fromDate, fromDate) ||
                const DeepCollectionEquality()
                    .equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) ||
                const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) ||
                const DeepCollectionEquality()
                    .equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) ||
                const DeepCollectionEquality()
                    .equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) ||
                const DeepCollectionEquality()
                    .equals(other.actualTime, actualTime)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.assigneeObj, assigneeObj) ||
                const DeepCollectionEquality()
                    .equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.viewerObj, viewerObj) ||
                const DeepCollectionEquality()
                    .equals(other.viewerObj, viewerObj)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) ||
                const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) ||
                const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) ||
                const DeepCollectionEquality().equals(other.cLevel, cLevel)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      runtimeType.hashCode;
}

extension $TaskTemplateResquestModelExtension on TaskTemplateResquestModel {
  TaskTemplateResquestModel copyWith(
      {String? parentId,
      String? name,
      String? code,
      String? description,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<LabelsObj>? labelsObjs,
      List<String>? managementObj,
      List<String>? ownerObj,
      List<String>? supervisorObj,
      List<String>? coordinatorObj,
      List<String>? assigneeObj,
      List<String>? viewerObj,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel}) {
    return TaskTemplateResquestModel(
        parentId: parentId ?? this.parentId,
        name: name ?? this.name,
        code: code ?? this.code,
        description: description ?? this.description,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        managementObj: managementObj ?? this.managementObj,
        ownerObj: ownerObj ?? this.ownerObj,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        viewerObj: viewerObj ?? this.viewerObj,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskViewModel {
  TaskViewModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.acl,
    this.id,
    required this.name,
    this.description,
    this.parentId,
    this.parentType,
    this.priorityObj,
    this.priority,
    this.weight,
    this.rank,
    this.labelsObjs,
    this.labels,
    this.managementObj,
    this.management,
    this.ownerObj,
    this.owner,
    this.supervisorObj,
    this.supervisor,
    this.coordinatorObj,
    this.coordinator,
    this.assigneeObj,
    this.assignee,
    this.viewerObj,
    this.viewer,
    this.statusObj,
    this.status,
    this.objectId,
    this.objectType,
    this.objectAction,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.allowToModify,
    this.allowToView,
    this.allowToChangeStatus,
    this.allowToModifyCoordinator,
    this.allowToModifyFromDate,
    this.allowToModifyToDate,
    this.allowToModifyFinishDate,
    this.relatedFolderId,
    this.allowToCreateSubTasks,
    this.aclObject,
    this.projectId,
    this.code,
    this.type,
    this.attachment,
    this.workflowStatus,
    this.metadata,
    this.ref,
    this.relatedTasks,
  });

  factory TaskViewModel.fromJson(Map<String, dynamic> json) =>
      _$TaskViewModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'acl', includeIfNull: false)
  final String? acl;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'parentType', includeIfNull: false)
  final String? parentType;
  @JsonKey(
      name: 'priorityObj',
      includeIfNull: false,
      toJson: priorityEnumsToJson,
      fromJson: priorityEnumsFromJson)
  final enums.PriorityEnums? priorityObj;
  @JsonKey(name: 'priority', includeIfNull: false)
  final int? priority;
  @JsonKey(name: 'weight', includeIfNull: false)
  final int? weight;
  @JsonKey(name: 'rank', includeIfNull: false)
  final int? rank;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labels', includeIfNull: false)
  final String? labels;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'management', includeIfNull: false)
  final String? management;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(name: 'owner', includeIfNull: false)
  final String? owner;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(name: 'supervisor', includeIfNull: false)
  final String? supervisor;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'coordinator', includeIfNull: false)
  final String? coordinator;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'assignee', includeIfNull: false)
  final String? assignee;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'viewer', includeIfNull: false)
  final String? viewer;
  @JsonKey(
      name: 'statusObj',
      includeIfNull: false,
      toJson: pMStatusEnumsToJson,
      fromJson: pMStatusEnumsFromJson)
  final enums.PMStatusEnums? statusObj;
  @JsonKey(name: 'status', includeIfNull: false)
  final int? status;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectAction', includeIfNull: false)
  final String? objectAction;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'allowToModify', includeIfNull: false)
  final bool? allowToModify;
  @JsonKey(name: 'allowToView', includeIfNull: false)
  final bool? allowToView;
  @JsonKey(name: 'allowToChangeStatus', includeIfNull: false)
  final bool? allowToChangeStatus;
  @JsonKey(name: 'allowToModifyCoordinator', includeIfNull: false)
  final bool? allowToModifyCoordinator;
  @JsonKey(name: 'allowToModifyFromDate', includeIfNull: false)
  final bool? allowToModifyFromDate;
  @JsonKey(name: 'allowToModifyToDate', includeIfNull: false)
  final bool? allowToModifyToDate;
  @JsonKey(name: 'allowToModifyFinishDate', includeIfNull: false)
  final bool? allowToModifyFinishDate;
  @JsonKey(name: 'relatedFolderId', includeIfNull: false)
  final String? relatedFolderId;
  @JsonKey(name: 'allowToCreateSubTasks', includeIfNull: false)
  final bool? allowToCreateSubTasks;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'projectId', includeIfNull: false)
  final String? projectId;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'attachment', includeIfNull: false)
  final String? attachment;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final int? workflowStatus;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final String? metadata;
  @JsonKey(name: 'ref', includeIfNull: false)
  final String? ref;
  @JsonKey(
      name: 'relatedTasks', includeIfNull: false, defaultValue: <RelatedTask>[])
  final List<RelatedTask>? relatedTasks;
  static const fromJsonFactory = _$TaskViewModelFromJson;
  static const toJsonFactory = _$TaskViewModelToJson;
  Map<String, dynamic> toJson() => _$TaskViewModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskViewModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.parentType, parentType) ||
                const DeepCollectionEquality()
                    .equals(other.parentType, parentType)) &&
            (identical(other.priorityObj, priorityObj) ||
                const DeepCollectionEquality()
                    .equals(other.priorityObj, priorityObj)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.weight, weight) ||
                const DeepCollectionEquality().equals(other.weight, weight)) &&
            (identical(other.rank, rank) ||
                const DeepCollectionEquality().equals(other.rank, rank)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.management, management) ||
                const DeepCollectionEquality()
                    .equals(other.management, management)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.supervisor, supervisor) ||
                const DeepCollectionEquality()
                    .equals(other.supervisor, supervisor)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.coordinator, coordinator) ||
                const DeepCollectionEquality()
                    .equals(other.coordinator, coordinator)) &&
            (identical(other.assigneeObj, assigneeObj) || const DeepCollectionEquality().equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.assignee, assignee) || const DeepCollectionEquality().equals(other.assignee, assignee)) &&
            (identical(other.viewerObj, viewerObj) || const DeepCollectionEquality().equals(other.viewerObj, viewerObj)) &&
            (identical(other.viewer, viewer) || const DeepCollectionEquality().equals(other.viewer, viewer)) &&
            (identical(other.statusObj, statusObj) || const DeepCollectionEquality().equals(other.statusObj, statusObj)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.objectId, objectId) || const DeepCollectionEquality().equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) || const DeepCollectionEquality().equals(other.objectType, objectType)) &&
            (identical(other.objectAction, objectAction) || const DeepCollectionEquality().equals(other.objectAction, objectAction)) &&
            (identical(other.fromDate, fromDate) || const DeepCollectionEquality().equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) || const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) || const DeepCollectionEquality().equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) || const DeepCollectionEquality().equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) || const DeepCollectionEquality().equals(other.actualTime, actualTime)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) || const DeepCollectionEquality().equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) || const DeepCollectionEquality().equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) || const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) || const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) || const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.allowToModify, allowToModify) || const DeepCollectionEquality().equals(other.allowToModify, allowToModify)) &&
            (identical(other.allowToView, allowToView) || const DeepCollectionEquality().equals(other.allowToView, allowToView)) &&
            (identical(other.allowToChangeStatus, allowToChangeStatus) || const DeepCollectionEquality().equals(other.allowToChangeStatus, allowToChangeStatus)) &&
            (identical(other.allowToModifyCoordinator, allowToModifyCoordinator) || const DeepCollectionEquality().equals(other.allowToModifyCoordinator, allowToModifyCoordinator)) &&
            (identical(other.allowToModifyFromDate, allowToModifyFromDate) || const DeepCollectionEquality().equals(other.allowToModifyFromDate, allowToModifyFromDate)) &&
            (identical(other.allowToModifyToDate, allowToModifyToDate) || const DeepCollectionEquality().equals(other.allowToModifyToDate, allowToModifyToDate)) &&
            (identical(other.allowToModifyFinishDate, allowToModifyFinishDate) || const DeepCollectionEquality().equals(other.allowToModifyFinishDate, allowToModifyFinishDate)) &&
            (identical(other.relatedFolderId, relatedFolderId) || const DeepCollectionEquality().equals(other.relatedFolderId, relatedFolderId)) &&
            (identical(other.allowToCreateSubTasks, allowToCreateSubTasks) || const DeepCollectionEquality().equals(other.allowToCreateSubTasks, allowToCreateSubTasks)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.projectId, projectId) || const DeepCollectionEquality().equals(other.projectId, projectId)) &&
            (identical(other.code, code) || const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.attachment, attachment) || const DeepCollectionEquality().equals(other.attachment, attachment)) &&
            (identical(other.workflowStatus, workflowStatus) || const DeepCollectionEquality().equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.metadata, metadata) || const DeepCollectionEquality().equals(other.metadata, metadata)) &&
            (identical(other.ref, ref) || const DeepCollectionEquality().equals(other.ref, ref)) &&
            (identical(other.relatedTasks, relatedTasks) || const DeepCollectionEquality().equals(other.relatedTasks, relatedTasks)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(parentType) ^
      const DeepCollectionEquality().hash(priorityObj) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(weight) ^
      const DeepCollectionEquality().hash(rank) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(management) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(supervisor) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(coordinator) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(viewer) ^
      const DeepCollectionEquality().hash(statusObj) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectAction) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(allowToModify) ^
      const DeepCollectionEquality().hash(allowToView) ^
      const DeepCollectionEquality().hash(allowToChangeStatus) ^
      const DeepCollectionEquality().hash(allowToModifyCoordinator) ^
      const DeepCollectionEquality().hash(allowToModifyFromDate) ^
      const DeepCollectionEquality().hash(allowToModifyToDate) ^
      const DeepCollectionEquality().hash(allowToModifyFinishDate) ^
      const DeepCollectionEquality().hash(relatedFolderId) ^
      const DeepCollectionEquality().hash(allowToCreateSubTasks) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(attachment) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(ref) ^
      const DeepCollectionEquality().hash(relatedTasks) ^
      runtimeType.hashCode;
}

extension $TaskViewModelExtension on TaskViewModel {
  TaskViewModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? acl,
      String? id,
      String? name,
      String? description,
      String? parentId,
      String? parentType,
      enums.PriorityEnums? priorityObj,
      int? priority,
      int? weight,
      int? rank,
      List<LabelsObj>? labelsObjs,
      String? labels,
      List<String>? managementObj,
      String? management,
      List<String>? ownerObj,
      String? owner,
      List<String>? supervisorObj,
      String? supervisor,
      List<String>? coordinatorObj,
      String? coordinator,
      List<String>? assigneeObj,
      String? assignee,
      List<String>? viewerObj,
      String? viewer,
      enums.PMStatusEnums? statusObj,
      int? status,
      String? objectId,
      String? objectType,
      String? objectAction,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel,
      bool? allowToModify,
      bool? allowToView,
      bool? allowToChangeStatus,
      bool? allowToModifyCoordinator,
      bool? allowToModifyFromDate,
      bool? allowToModifyToDate,
      bool? allowToModifyFinishDate,
      String? relatedFolderId,
      bool? allowToCreateSubTasks,
      ACLObject? aclObject,
      String? projectId,
      String? code,
      String? type,
      String? attachment,
      int? workflowStatus,
      String? metadata,
      String? ref,
      List<RelatedTask>? relatedTasks}) {
    return TaskViewModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        acl: acl ?? this.acl,
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        parentId: parentId ?? this.parentId,
        parentType: parentType ?? this.parentType,
        priorityObj: priorityObj ?? this.priorityObj,
        priority: priority ?? this.priority,
        weight: weight ?? this.weight,
        rank: rank ?? this.rank,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labels: labels ?? this.labels,
        managementObj: managementObj ?? this.managementObj,
        management: management ?? this.management,
        ownerObj: ownerObj ?? this.ownerObj,
        owner: owner ?? this.owner,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        supervisor: supervisor ?? this.supervisor,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        coordinator: coordinator ?? this.coordinator,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        assignee: assignee ?? this.assignee,
        viewerObj: viewerObj ?? this.viewerObj,
        viewer: viewer ?? this.viewer,
        statusObj: statusObj ?? this.statusObj,
        status: status ?? this.status,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        objectAction: objectAction ?? this.objectAction,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        allowToModify: allowToModify ?? this.allowToModify,
        allowToView: allowToView ?? this.allowToView,
        allowToChangeStatus: allowToChangeStatus ?? this.allowToChangeStatus,
        allowToModifyCoordinator:
            allowToModifyCoordinator ?? this.allowToModifyCoordinator,
        allowToModifyFromDate:
            allowToModifyFromDate ?? this.allowToModifyFromDate,
        allowToModifyToDate: allowToModifyToDate ?? this.allowToModifyToDate,
        allowToModifyFinishDate:
            allowToModifyFinishDate ?? this.allowToModifyFinishDate,
        relatedFolderId: relatedFolderId ?? this.relatedFolderId,
        allowToCreateSubTasks:
            allowToCreateSubTasks ?? this.allowToCreateSubTasks,
        aclObject: aclObject ?? this.aclObject,
        projectId: projectId ?? this.projectId,
        code: code ?? this.code,
        type: type ?? this.type,
        attachment: attachment ?? this.attachment,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        metadata: metadata ?? this.metadata,
        ref: ref ?? this.ref,
        relatedTasks: relatedTasks ?? this.relatedTasks);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskViewModelListResponseObject {
  TaskViewModelListResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory TaskViewModelListResponseObject.fromJson(Map<String, dynamic> json) =>
      _$TaskViewModelListResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <TaskViewModel>[])
  final List<TaskViewModel>? data;
  static const fromJsonFactory = _$TaskViewModelListResponseObjectFromJson;
  static const toJsonFactory = _$TaskViewModelListResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$TaskViewModelListResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskViewModelListResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $TaskViewModelListResponseObjectExtension
    on TaskViewModelListResponseObject {
  TaskViewModelListResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<TaskViewModel>? data}) {
    return TaskViewModelListResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskViewModelPagination {
  TaskViewModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory TaskViewModelPagination.fromJson(Map<String, dynamic> json) =>
      _$TaskViewModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content', includeIfNull: false, defaultValue: <TaskViewModel>[])
  final List<TaskViewModel>? content;
  static const fromJsonFactory = _$TaskViewModelPaginationFromJson;
  static const toJsonFactory = _$TaskViewModelPaginationToJson;
  Map<String, dynamic> toJson() => _$TaskViewModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskViewModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $TaskViewModelPaginationExtension on TaskViewModelPagination {
  TaskViewModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<TaskViewModel>? content}) {
    return TaskViewModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskViewModelResponseList {
  TaskViewModelResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory TaskViewModelResponseList.fromJson(Map<String, dynamic> json) =>
      _$TaskViewModelResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <TaskViewModel>[])
  final List<TaskViewModel>? data;
  static const fromJsonFactory = _$TaskViewModelResponseListFromJson;
  static const toJsonFactory = _$TaskViewModelResponseListToJson;
  Map<String, dynamic> toJson() => _$TaskViewModelResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskViewModelResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $TaskViewModelResponseListExtension on TaskViewModelResponseList {
  TaskViewModelResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<TaskViewModel>? data}) {
    return TaskViewModelResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskViewModelResponseObject {
  TaskViewModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory TaskViewModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$TaskViewModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final TaskViewModel? data;
  static const fromJsonFactory = _$TaskViewModelResponseObjectFromJson;
  static const toJsonFactory = _$TaskViewModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$TaskViewModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskViewModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $TaskViewModelResponseObjectExtension on TaskViewModelResponseObject {
  TaskViewModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      TaskViewModel? data}) {
    return TaskViewModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class TaskViewModelResponsePagination {
  TaskViewModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory TaskViewModelResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$TaskViewModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final TaskViewModelPagination? data;
  static const fromJsonFactory = _$TaskViewModelResponsePaginationFromJson;
  static const toJsonFactory = _$TaskViewModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$TaskViewModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaskViewModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $TaskViewModelResponsePaginationExtension
    on TaskViewModelResponsePagination {
  TaskViewModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      TaskViewModelPagination? data}) {
    return TaskViewModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class TemplateResquestModel {
  TemplateResquestModel({
    this.parentId,
    this.name,
    required this.code,
    this.description,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.labelsObjs,
    this.managementObj,
    this.ownerObj,
    this.supervisorObj,
    this.coordinatorObj,
    this.assigneeObj,
    this.viewerObj,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.templateContentObj,
    this.metadataContentObjs,
  });

  factory TemplateResquestModel.fromJson(Map<String, dynamic> json) =>
      _$TemplateResquestModelFromJson(json);

  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'code', includeIfNull: false)
  final String code;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(
      name: 'templateContentObj',
      includeIfNull: false,
      defaultValue: <TaskBaseModel>[])
  final List<TaskBaseModel>? templateContentObj;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  static const fromJsonFactory = _$TemplateResquestModelFromJson;
  static const toJsonFactory = _$TemplateResquestModelToJson;
  Map<String, dynamic> toJson() => _$TemplateResquestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TemplateResquestModel &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.fromDate, fromDate) ||
                const DeepCollectionEquality()
                    .equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) ||
                const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) ||
                const DeepCollectionEquality()
                    .equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) ||
                const DeepCollectionEquality()
                    .equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) ||
                const DeepCollectionEquality()
                    .equals(other.actualTime, actualTime)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.assigneeObj, assigneeObj) ||
                const DeepCollectionEquality()
                    .equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.viewerObj, viewerObj) ||
                const DeepCollectionEquality()
                    .equals(other.viewerObj, viewerObj)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) ||
                const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) ||
                const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) ||
                const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.templateContentObj, templateContentObj) ||
                const DeepCollectionEquality()
                    .equals(other.templateContentObj, templateContentObj)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(templateContentObj) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      runtimeType.hashCode;
}

extension $TemplateResquestModelExtension on TemplateResquestModel {
  TemplateResquestModel copyWith(
      {String? parentId,
      String? name,
      String? code,
      String? description,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<LabelsObj>? labelsObjs,
      List<String>? managementObj,
      List<String>? ownerObj,
      List<String>? supervisorObj,
      List<String>? coordinatorObj,
      List<String>? assigneeObj,
      List<String>? viewerObj,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel,
      List<TaskBaseModel>? templateContentObj,
      List<MetadataValue>? metadataContentObjs}) {
    return TemplateResquestModel(
        parentId: parentId ?? this.parentId,
        name: name ?? this.name,
        code: code ?? this.code,
        description: description ?? this.description,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        managementObj: managementObj ?? this.managementObj,
        ownerObj: ownerObj ?? this.ownerObj,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        viewerObj: viewerObj ?? this.viewerObj,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        templateContentObj: templateContentObj ?? this.templateContentObj,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs);
  }
}

@JsonSerializable(explicitToJson: true)
class TemplateViewModel {
  TemplateViewModel({
    this.parentId,
    this.name,
    required this.code,
    this.description,
    this.fromDate,
    this.toDate,
    this.finishDate,
    this.estimateTime,
    this.actualTime,
    this.labelsObjs,
    this.managementObj,
    this.ownerObj,
    this.supervisorObj,
    this.coordinatorObj,
    this.assigneeObj,
    this.viewerObj,
    this.order,
    this.cLeft,
    this.cRight,
    this.cLevel,
    this.id,
    this.templateContentObj,
    this.metadataContentObjs,
  });

  factory TemplateViewModel.fromJson(Map<String, dynamic> json) =>
      _$TemplateViewModelFromJson(json);

  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'code', includeIfNull: false)
  final String code;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'fromDate', includeIfNull: false)
  final DateTime? fromDate;
  @JsonKey(name: 'toDate', includeIfNull: false)
  final DateTime? toDate;
  @JsonKey(name: 'finishDate', includeIfNull: false)
  final DateTime? finishDate;
  @JsonKey(name: 'estimateTime', includeIfNull: false)
  final double? estimateTime;
  @JsonKey(name: 'actualTime', includeIfNull: false)
  final double? actualTime;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(
      name: 'managementObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? managementObj;
  @JsonKey(name: 'ownerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? ownerObj;
  @JsonKey(
      name: 'supervisorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? supervisorObj;
  @JsonKey(
      name: 'coordinatorObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? coordinatorObj;
  @JsonKey(name: 'assigneeObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? assigneeObj;
  @JsonKey(name: 'viewerObj', includeIfNull: false, defaultValue: <String>[])
  final List<String>? viewerObj;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'c_left', includeIfNull: false)
  final int? cLeft;
  @JsonKey(name: 'c_right', includeIfNull: false)
  final int? cRight;
  @JsonKey(name: 'c_level', includeIfNull: false)
  final int? cLevel;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(
      name: 'templateContentObj',
      includeIfNull: false,
      defaultValue: <TaskViewModel>[])
  final List<TaskViewModel>? templateContentObj;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  static const fromJsonFactory = _$TemplateViewModelFromJson;
  static const toJsonFactory = _$TemplateViewModelToJson;
  Map<String, dynamic> toJson() => _$TemplateViewModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TemplateViewModel &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.fromDate, fromDate) ||
                const DeepCollectionEquality()
                    .equals(other.fromDate, fromDate)) &&
            (identical(other.toDate, toDate) ||
                const DeepCollectionEquality().equals(other.toDate, toDate)) &&
            (identical(other.finishDate, finishDate) ||
                const DeepCollectionEquality()
                    .equals(other.finishDate, finishDate)) &&
            (identical(other.estimateTime, estimateTime) ||
                const DeepCollectionEquality()
                    .equals(other.estimateTime, estimateTime)) &&
            (identical(other.actualTime, actualTime) ||
                const DeepCollectionEquality()
                    .equals(other.actualTime, actualTime)) &&
            (identical(other.labelsObjs, labelsObjs) ||
                const DeepCollectionEquality()
                    .equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.managementObj, managementObj) ||
                const DeepCollectionEquality()
                    .equals(other.managementObj, managementObj)) &&
            (identical(other.ownerObj, ownerObj) ||
                const DeepCollectionEquality()
                    .equals(other.ownerObj, ownerObj)) &&
            (identical(other.supervisorObj, supervisorObj) ||
                const DeepCollectionEquality()
                    .equals(other.supervisorObj, supervisorObj)) &&
            (identical(other.coordinatorObj, coordinatorObj) ||
                const DeepCollectionEquality()
                    .equals(other.coordinatorObj, coordinatorObj)) &&
            (identical(other.assigneeObj, assigneeObj) ||
                const DeepCollectionEquality()
                    .equals(other.assigneeObj, assigneeObj)) &&
            (identical(other.viewerObj, viewerObj) ||
                const DeepCollectionEquality()
                    .equals(other.viewerObj, viewerObj)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.cLeft, cLeft) ||
                const DeepCollectionEquality().equals(other.cLeft, cLeft)) &&
            (identical(other.cRight, cRight) ||
                const DeepCollectionEquality().equals(other.cRight, cRight)) &&
            (identical(other.cLevel, cLevel) ||
                const DeepCollectionEquality().equals(other.cLevel, cLevel)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.templateContentObj, templateContentObj) ||
                const DeepCollectionEquality()
                    .equals(other.templateContentObj, templateContentObj)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(fromDate) ^
      const DeepCollectionEquality().hash(toDate) ^
      const DeepCollectionEquality().hash(finishDate) ^
      const DeepCollectionEquality().hash(estimateTime) ^
      const DeepCollectionEquality().hash(actualTime) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(managementObj) ^
      const DeepCollectionEquality().hash(ownerObj) ^
      const DeepCollectionEquality().hash(supervisorObj) ^
      const DeepCollectionEquality().hash(coordinatorObj) ^
      const DeepCollectionEquality().hash(assigneeObj) ^
      const DeepCollectionEquality().hash(viewerObj) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(cLeft) ^
      const DeepCollectionEquality().hash(cRight) ^
      const DeepCollectionEquality().hash(cLevel) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(templateContentObj) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      runtimeType.hashCode;
}

extension $TemplateViewModelExtension on TemplateViewModel {
  TemplateViewModel copyWith(
      {String? parentId,
      String? name,
      String? code,
      String? description,
      DateTime? fromDate,
      DateTime? toDate,
      DateTime? finishDate,
      double? estimateTime,
      double? actualTime,
      List<LabelsObj>? labelsObjs,
      List<String>? managementObj,
      List<String>? ownerObj,
      List<String>? supervisorObj,
      List<String>? coordinatorObj,
      List<String>? assigneeObj,
      List<String>? viewerObj,
      int? order,
      int? cLeft,
      int? cRight,
      int? cLevel,
      String? id,
      List<TaskViewModel>? templateContentObj,
      List<MetadataValue>? metadataContentObjs}) {
    return TemplateViewModel(
        parentId: parentId ?? this.parentId,
        name: name ?? this.name,
        code: code ?? this.code,
        description: description ?? this.description,
        fromDate: fromDate ?? this.fromDate,
        toDate: toDate ?? this.toDate,
        finishDate: finishDate ?? this.finishDate,
        estimateTime: estimateTime ?? this.estimateTime,
        actualTime: actualTime ?? this.actualTime,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        managementObj: managementObj ?? this.managementObj,
        ownerObj: ownerObj ?? this.ownerObj,
        supervisorObj: supervisorObj ?? this.supervisorObj,
        coordinatorObj: coordinatorObj ?? this.coordinatorObj,
        assigneeObj: assigneeObj ?? this.assigneeObj,
        viewerObj: viewerObj ?? this.viewerObj,
        order: order ?? this.order,
        cLeft: cLeft ?? this.cLeft,
        cRight: cRight ?? this.cRight,
        cLevel: cLevel ?? this.cLevel,
        id: id ?? this.id,
        templateContentObj: templateContentObj ?? this.templateContentObj,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs);
  }
}

@JsonSerializable(explicitToJson: true)
class TemplateViewModelPagination {
  TemplateViewModelPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory TemplateViewModelPagination.fromJson(Map<String, dynamic> json) =>
      _$TemplateViewModelPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content',
      includeIfNull: false,
      defaultValue: <TemplateViewModel>[])
  final List<TemplateViewModel>? content;
  static const fromJsonFactory = _$TemplateViewModelPaginationFromJson;
  static const toJsonFactory = _$TemplateViewModelPaginationToJson;
  Map<String, dynamic> toJson() => _$TemplateViewModelPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TemplateViewModelPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $TemplateViewModelPaginationExtension on TemplateViewModelPagination {
  TemplateViewModelPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<TemplateViewModel>? content}) {
    return TemplateViewModelPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class TemplateViewModelResponseObject {
  TemplateViewModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory TemplateViewModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$TemplateViewModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final TemplateViewModel? data;
  static const fromJsonFactory = _$TemplateViewModelResponseObjectFromJson;
  static const toJsonFactory = _$TemplateViewModelResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$TemplateViewModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TemplateViewModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $TemplateViewModelResponseObjectExtension
    on TemplateViewModelResponseObject {
  TemplateViewModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      TemplateViewModel? data}) {
    return TemplateViewModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class TemplateViewModelResponsePagination {
  TemplateViewModelResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory TemplateViewModelResponsePagination.fromJson(
          Map<String, dynamic> json) =>
      _$TemplateViewModelResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final TemplateViewModelPagination? data;
  static const fromJsonFactory = _$TemplateViewModelResponsePaginationFromJson;
  static const toJsonFactory = _$TemplateViewModelResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$TemplateViewModelResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TemplateViewModelResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $TemplateViewModelResponsePaginationExtension
    on TemplateViewModelResponsePagination {
  TemplateViewModelResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      TemplateViewModelPagination? data}) {
    return TemplateViewModelResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class TreeBomTempModel {
  TreeBomTempModel({
    this.routing,
    this.companyName,
    this.companyId,
    this.pickingTypeId,
    this.readyToProduce,
    this.order,
    this.type,
    this.isActive,
    this.code,
    this.deXe,
    this.description,
    this.routingName,
    this.routingId,
    this.unitName,
    this.unitId,
    this.quantity,
    this.objectType,
    this.objectName,
    this.objectId,
    this.id,
    this.metadataContentObjs,
    this.bomTempDetails,
  });

  factory TreeBomTempModel.fromJson(Map<String, dynamic> json) =>
      _$TreeBomTempModelFromJson(json);

  @JsonKey(name: 'routing', includeIfNull: false)
  final RoutingModel? routing;
  @JsonKey(name: 'companyName', includeIfNull: false)
  final String? companyName;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  @JsonKey(name: 'pickingTypeId', includeIfNull: false)
  final String? pickingTypeId;
  @JsonKey(name: 'readyToProduce', includeIfNull: false)
  final String? readyToProduce;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'deXe', includeIfNull: false)
  final double? deXe;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'routingName', includeIfNull: false)
  final String? routingName;
  @JsonKey(name: 'routingId', includeIfNull: false)
  final String? routingId;
  @JsonKey(name: 'unitName', includeIfNull: false)
  final String? unitName;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(
      name: 'bomTempDetails',
      includeIfNull: false,
      defaultValue: <BomTempLineModel>[])
  final List<BomTempLineModel>? bomTempDetails;
  static const fromJsonFactory = _$TreeBomTempModelFromJson;
  static const toJsonFactory = _$TreeBomTempModelToJson;
  Map<String, dynamic> toJson() => _$TreeBomTempModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TreeBomTempModel &&
            (identical(other.routing, routing) ||
                const DeepCollectionEquality()
                    .equals(other.routing, routing)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.companyId, companyId) ||
                const DeepCollectionEquality()
                    .equals(other.companyId, companyId)) &&
            (identical(other.pickingTypeId, pickingTypeId) ||
                const DeepCollectionEquality()
                    .equals(other.pickingTypeId, pickingTypeId)) &&
            (identical(other.readyToProduce, readyToProduce) ||
                const DeepCollectionEquality()
                    .equals(other.readyToProduce, readyToProduce)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.deXe, deXe) ||
                const DeepCollectionEquality().equals(other.deXe, deXe)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.routingName, routingName) ||
                const DeepCollectionEquality()
                    .equals(other.routingName, routingName)) &&
            (identical(other.routingId, routingId) ||
                const DeepCollectionEquality()
                    .equals(other.routingId, routingId)) &&
            (identical(other.unitName, unitName) ||
                const DeepCollectionEquality()
                    .equals(other.unitName, unitName)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.bomTempDetails, bomTempDetails) ||
                const DeepCollectionEquality()
                    .equals(other.bomTempDetails, bomTempDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(routing) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(companyId) ^
      const DeepCollectionEquality().hash(pickingTypeId) ^
      const DeepCollectionEquality().hash(readyToProduce) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(deXe) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(routingName) ^
      const DeepCollectionEquality().hash(routingId) ^
      const DeepCollectionEquality().hash(unitName) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(bomTempDetails) ^
      runtimeType.hashCode;
}

extension $TreeBomTempModelExtension on TreeBomTempModel {
  TreeBomTempModel copyWith(
      {RoutingModel? routing,
      String? companyName,
      String? companyId,
      String? pickingTypeId,
      String? readyToProduce,
      int? order,
      String? type,
      bool? isActive,
      String? code,
      double? deXe,
      String? description,
      String? routingName,
      String? routingId,
      String? unitName,
      String? unitId,
      double? quantity,
      String? objectType,
      String? objectName,
      String? objectId,
      String? id,
      List<MetadataValue>? metadataContentObjs,
      List<BomTempLineModel>? bomTempDetails}) {
    return TreeBomTempModel(
        routing: routing ?? this.routing,
        companyName: companyName ?? this.companyName,
        companyId: companyId ?? this.companyId,
        pickingTypeId: pickingTypeId ?? this.pickingTypeId,
        readyToProduce: readyToProduce ?? this.readyToProduce,
        order: order ?? this.order,
        type: type ?? this.type,
        isActive: isActive ?? this.isActive,
        code: code ?? this.code,
        deXe: deXe ?? this.deXe,
        description: description ?? this.description,
        routingName: routingName ?? this.routingName,
        routingId: routingId ?? this.routingId,
        unitName: unitName ?? this.unitName,
        unitId: unitId ?? this.unitId,
        quantity: quantity ?? this.quantity,
        objectType: objectType ?? this.objectType,
        objectName: objectName ?? this.objectName,
        objectId: objectId ?? this.objectId,
        id: id ?? this.id,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        bomTempDetails: bomTempDetails ?? this.bomTempDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class TreeGrownCreateRequestModel {
  TreeGrownCreateRequestModel({
    this.locationSrcId,
    this.locationSrcName,
    this.parentLocationSrcId,
    this.parentLocationSrcName,
    this.parentPath,
    this.productAttributeValue,
    this.productAttributeName,
    this.productTmpId,
    this.productTmpName,
    this.referenceSrcId,
    this.referenceSrc,
    this.objectId,
    this.movelineDetails,
  });

  factory TreeGrownCreateRequestModel.fromJson(Map<String, dynamic> json) =>
      _$TreeGrownCreateRequestModelFromJson(json);

  @JsonKey(name: 'locationSrcId', includeIfNull: false)
  final String? locationSrcId;
  @JsonKey(name: 'locationSrcName', includeIfNull: false)
  final String? locationSrcName;
  @JsonKey(name: 'parentLocationSrcId', includeIfNull: false)
  final String? parentLocationSrcId;
  @JsonKey(name: 'parentLocationSrcName', includeIfNull: false)
  final String? parentLocationSrcName;
  @JsonKey(name: 'parentPath', includeIfNull: false)
  final String? parentPath;
  @JsonKey(name: 'productAttributeValue', includeIfNull: false)
  final String? productAttributeValue;
  @JsonKey(name: 'productAttributeName', includeIfNull: false)
  final String? productAttributeName;
  @JsonKey(name: 'productTmpId', includeIfNull: false)
  final String? productTmpId;
  @JsonKey(name: 'productTmpName', includeIfNull: false)
  final String? productTmpName;
  @JsonKey(name: 'referenceSrcId', includeIfNull: false)
  final String? referenceSrcId;
  @JsonKey(name: 'referenceSrc', includeIfNull: false)
  final String? referenceSrc;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(
      name: 'movelineDetails',
      includeIfNull: false,
      defaultValue: <StockMoveLine>[])
  final List<StockMoveLine>? movelineDetails;
  static const fromJsonFactory = _$TreeGrownCreateRequestModelFromJson;
  static const toJsonFactory = _$TreeGrownCreateRequestModelToJson;
  Map<String, dynamic> toJson() => _$TreeGrownCreateRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TreeGrownCreateRequestModel &&
            (identical(other.locationSrcId, locationSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcId, locationSrcId)) &&
            (identical(other.locationSrcName, locationSrcName) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcName, locationSrcName)) &&
            (identical(other.parentLocationSrcId, parentLocationSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.parentLocationSrcId, parentLocationSrcId)) &&
            (identical(other.parentLocationSrcName, parentLocationSrcName) ||
                const DeepCollectionEquality().equals(
                    other.parentLocationSrcName, parentLocationSrcName)) &&
            (identical(other.parentPath, parentPath) ||
                const DeepCollectionEquality()
                    .equals(other.parentPath, parentPath)) &&
            (identical(other.productAttributeValue, productAttributeValue) ||
                const DeepCollectionEquality().equals(
                    other.productAttributeValue, productAttributeValue)) &&
            (identical(other.productAttributeName, productAttributeName) ||
                const DeepCollectionEquality().equals(
                    other.productAttributeName, productAttributeName)) &&
            (identical(other.productTmpId, productTmpId) ||
                const DeepCollectionEquality()
                    .equals(other.productTmpId, productTmpId)) &&
            (identical(other.productTmpName, productTmpName) ||
                const DeepCollectionEquality()
                    .equals(other.productTmpName, productTmpName)) &&
            (identical(other.referenceSrcId, referenceSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceSrcId, referenceSrcId)) &&
            (identical(other.referenceSrc, referenceSrc) ||
                const DeepCollectionEquality()
                    .equals(other.referenceSrc, referenceSrc)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.movelineDetails, movelineDetails) ||
                const DeepCollectionEquality()
                    .equals(other.movelineDetails, movelineDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationSrcId) ^
      const DeepCollectionEquality().hash(locationSrcName) ^
      const DeepCollectionEquality().hash(parentLocationSrcId) ^
      const DeepCollectionEquality().hash(parentLocationSrcName) ^
      const DeepCollectionEquality().hash(parentPath) ^
      const DeepCollectionEquality().hash(productAttributeValue) ^
      const DeepCollectionEquality().hash(productAttributeName) ^
      const DeepCollectionEquality().hash(productTmpId) ^
      const DeepCollectionEquality().hash(productTmpName) ^
      const DeepCollectionEquality().hash(referenceSrcId) ^
      const DeepCollectionEquality().hash(referenceSrc) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(movelineDetails) ^
      runtimeType.hashCode;
}

extension $TreeGrownCreateRequestModelExtension on TreeGrownCreateRequestModel {
  TreeGrownCreateRequestModel copyWith(
      {String? locationSrcId,
      String? locationSrcName,
      String? parentLocationSrcId,
      String? parentLocationSrcName,
      String? parentPath,
      String? productAttributeValue,
      String? productAttributeName,
      String? productTmpId,
      String? productTmpName,
      String? referenceSrcId,
      String? referenceSrc,
      String? objectId,
      List<StockMoveLine>? movelineDetails}) {
    return TreeGrownCreateRequestModel(
        locationSrcId: locationSrcId ?? this.locationSrcId,
        locationSrcName: locationSrcName ?? this.locationSrcName,
        parentLocationSrcId: parentLocationSrcId ?? this.parentLocationSrcId,
        parentLocationSrcName:
            parentLocationSrcName ?? this.parentLocationSrcName,
        parentPath: parentPath ?? this.parentPath,
        productAttributeValue:
            productAttributeValue ?? this.productAttributeValue,
        productAttributeName: productAttributeName ?? this.productAttributeName,
        productTmpId: productTmpId ?? this.productTmpId,
        productTmpName: productTmpName ?? this.productTmpName,
        referenceSrcId: referenceSrcId ?? this.referenceSrcId,
        referenceSrc: referenceSrc ?? this.referenceSrc,
        objectId: objectId ?? this.objectId,
        movelineDetails: movelineDetails ?? this.movelineDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class TreePlanningCreateModel {
  TreePlanningCreateModel({
    this.year,
  });

  factory TreePlanningCreateModel.fromJson(Map<String, dynamic> json) =>
      _$TreePlanningCreateModelFromJson(json);

  @JsonKey(name: 'year', includeIfNull: false)
  final int? year;
  static const fromJsonFactory = _$TreePlanningCreateModelFromJson;
  static const toJsonFactory = _$TreePlanningCreateModelToJson;
  Map<String, dynamic> toJson() => _$TreePlanningCreateModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TreePlanningCreateModel &&
            (identical(other.year, year) ||
                const DeepCollectionEquality().equals(other.year, year)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(year) ^ runtimeType.hashCode;
}

extension $TreePlanningCreateModelExtension on TreePlanningCreateModel {
  TreePlanningCreateModel copyWith({int? year}) {
    return TreePlanningCreateModel(year: year ?? this.year);
  }
}

@JsonSerializable(explicitToJson: true)
class TreeStockOnHand {
  TreeStockOnHand({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.id,
    this.objectName,
    this.objectId,
    this.objectType,
    this.productTmpId,
    this.locationId,
    this.locationName,
    this.parentLocationId,
    this.parentLocationName,
    this.parentPath,
    this.unitId,
    this.unitName,
    this.quantity,
    this.metadataContentObjs,
    this.metadataContent,
    this.metaContentType,
    this.referenceId,
    this.reference,
  });

  factory TreeStockOnHand.fromJson(Map<String, dynamic> json) =>
      _$TreeStockOnHandFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'productTmpId', includeIfNull: false)
  final String? productTmpId;
  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'locationName', includeIfNull: false)
  final String? locationName;
  @JsonKey(name: 'parentLocationId', includeIfNull: false)
  final String? parentLocationId;
  @JsonKey(name: 'parentLocationName', includeIfNull: false)
  final String? parentLocationName;
  @JsonKey(name: 'parentPath', includeIfNull: false)
  final String? parentPath;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'unitName', includeIfNull: false)
  final String? unitName;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'referenceId', includeIfNull: false)
  final String? referenceId;
  @JsonKey(name: 'reference', includeIfNull: false)
  final String? reference;
  static const fromJsonFactory = _$TreeStockOnHandFromJson;
  static const toJsonFactory = _$TreeStockOnHandToJson;
  Map<String, dynamic> toJson() => _$TreeStockOnHandToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TreeStockOnHand &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.productTmpId, productTmpId) ||
                const DeepCollectionEquality()
                    .equals(other.productTmpId, productTmpId)) &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.locationName, locationName) ||
                const DeepCollectionEquality()
                    .equals(other.locationName, locationName)) &&
            (identical(other.parentLocationId, parentLocationId) ||
                const DeepCollectionEquality()
                    .equals(other.parentLocationId, parentLocationId)) &&
            (identical(other.parentLocationName, parentLocationName) ||
                const DeepCollectionEquality()
                    .equals(other.parentLocationName, parentLocationName)) &&
            (identical(other.parentPath, parentPath) ||
                const DeepCollectionEquality()
                    .equals(other.parentPath, parentPath)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unitName, unitName) ||
                const DeepCollectionEquality()
                    .equals(other.unitName, unitName)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.referenceId, referenceId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceId, referenceId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality().equals(other.reference, reference)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(productTmpId) ^
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(locationName) ^
      const DeepCollectionEquality().hash(parentLocationId) ^
      const DeepCollectionEquality().hash(parentLocationName) ^
      const DeepCollectionEquality().hash(parentPath) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unitName) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(referenceId) ^
      const DeepCollectionEquality().hash(reference) ^
      runtimeType.hashCode;
}

extension $TreeStockOnHandExtension on TreeStockOnHand {
  TreeStockOnHand copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      String? id,
      String? objectName,
      String? objectId,
      String? objectType,
      String? productTmpId,
      String? locationId,
      String? locationName,
      String? parentLocationId,
      String? parentLocationName,
      String? parentPath,
      String? unitId,
      String? unitName,
      double? quantity,
      List<MetadataValue>? metadataContentObjs,
      String? metadataContent,
      String? metaContentType,
      String? referenceId,
      String? reference}) {
    return TreeStockOnHand(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        id: id ?? this.id,
        objectName: objectName ?? this.objectName,
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        productTmpId: productTmpId ?? this.productTmpId,
        locationId: locationId ?? this.locationId,
        locationName: locationName ?? this.locationName,
        parentLocationId: parentLocationId ?? this.parentLocationId,
        parentLocationName: parentLocationName ?? this.parentLocationName,
        parentPath: parentPath ?? this.parentPath,
        unitId: unitId ?? this.unitId,
        unitName: unitName ?? this.unitName,
        quantity: quantity ?? this.quantity,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metadataContent: metadataContent ?? this.metadataContent,
        metaContentType: metaContentType ?? this.metaContentType,
        referenceId: referenceId ?? this.referenceId,
        reference: reference ?? this.reference);
  }
}

@JsonSerializable(explicitToJson: true)
class TreeStockOnHandExtendQueryModel {
  TreeStockOnHandExtendQueryModel({
    this.locationId,
    this.productAttributeId,
    this.referenceId,
    this.objectId,
    this.owner,
    this.productTmpId,
    this.parentPath,
  });

  factory TreeStockOnHandExtendQueryModel.fromJson(Map<String, dynamic> json) =>
      _$TreeStockOnHandExtendQueryModelFromJson(json);

  @JsonKey(name: 'locationId', includeIfNull: false)
  final String? locationId;
  @JsonKey(name: 'productAttributeId', includeIfNull: false)
  final String? productAttributeId;
  @JsonKey(name: 'referenceId', includeIfNull: false)
  final String? referenceId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'owner', includeIfNull: false)
  final String? owner;
  @JsonKey(name: 'productTmpId', includeIfNull: false)
  final String? productTmpId;
  @JsonKey(name: 'parentPath', includeIfNull: false)
  final String? parentPath;
  static const fromJsonFactory = _$TreeStockOnHandExtendQueryModelFromJson;
  static const toJsonFactory = _$TreeStockOnHandExtendQueryModelToJson;
  Map<String, dynamic> toJson() =>
      _$TreeStockOnHandExtendQueryModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TreeStockOnHandExtendQueryModel &&
            (identical(other.locationId, locationId) ||
                const DeepCollectionEquality()
                    .equals(other.locationId, locationId)) &&
            (identical(other.productAttributeId, productAttributeId) ||
                const DeepCollectionEquality()
                    .equals(other.productAttributeId, productAttributeId)) &&
            (identical(other.referenceId, referenceId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceId, referenceId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.productTmpId, productTmpId) ||
                const DeepCollectionEquality()
                    .equals(other.productTmpId, productTmpId)) &&
            (identical(other.parentPath, parentPath) ||
                const DeepCollectionEquality()
                    .equals(other.parentPath, parentPath)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationId) ^
      const DeepCollectionEquality().hash(productAttributeId) ^
      const DeepCollectionEquality().hash(referenceId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(productTmpId) ^
      const DeepCollectionEquality().hash(parentPath) ^
      runtimeType.hashCode;
}

extension $TreeStockOnHandExtendQueryModelExtension
    on TreeStockOnHandExtendQueryModel {
  TreeStockOnHandExtendQueryModel copyWith(
      {String? locationId,
      String? productAttributeId,
      String? referenceId,
      String? objectId,
      String? owner,
      String? productTmpId,
      String? parentPath}) {
    return TreeStockOnHandExtendQueryModel(
        locationId: locationId ?? this.locationId,
        productAttributeId: productAttributeId ?? this.productAttributeId,
        referenceId: referenceId ?? this.referenceId,
        objectId: objectId ?? this.objectId,
        owner: owner ?? this.owner,
        productTmpId: productTmpId ?? this.productTmpId,
        parentPath: parentPath ?? this.parentPath);
  }
}

@JsonSerializable(explicitToJson: true)
class TreeStockOnHandUpdateModel {
  TreeStockOnHandUpdateModel({
    this.oldObjName,
    this.newObjName,
    this.productTmpId,
  });

  factory TreeStockOnHandUpdateModel.fromJson(Map<String, dynamic> json) =>
      _$TreeStockOnHandUpdateModelFromJson(json);

  @JsonKey(name: 'oldObjName', includeIfNull: false)
  final String? oldObjName;
  @JsonKey(name: 'newObjName', includeIfNull: false)
  final String? newObjName;
  @JsonKey(name: 'productTmpId', includeIfNull: false)
  final String? productTmpId;
  static const fromJsonFactory = _$TreeStockOnHandUpdateModelFromJson;
  static const toJsonFactory = _$TreeStockOnHandUpdateModelToJson;
  Map<String, dynamic> toJson() => _$TreeStockOnHandUpdateModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TreeStockOnHandUpdateModel &&
            (identical(other.oldObjName, oldObjName) ||
                const DeepCollectionEquality()
                    .equals(other.oldObjName, oldObjName)) &&
            (identical(other.newObjName, newObjName) ||
                const DeepCollectionEquality()
                    .equals(other.newObjName, newObjName)) &&
            (identical(other.productTmpId, productTmpId) ||
                const DeepCollectionEquality()
                    .equals(other.productTmpId, productTmpId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oldObjName) ^
      const DeepCollectionEquality().hash(newObjName) ^
      const DeepCollectionEquality().hash(productTmpId) ^
      runtimeType.hashCode;
}

extension $TreeStockOnHandUpdateModelExtension on TreeStockOnHandUpdateModel {
  TreeStockOnHandUpdateModel copyWith(
      {String? oldObjName, String? newObjName, String? productTmpId}) {
    return TreeStockOnHandUpdateModel(
        oldObjName: oldObjName ?? this.oldObjName,
        newObjName: newObjName ?? this.newObjName,
        productTmpId: productTmpId ?? this.productTmpId);
  }
}

@JsonSerializable(explicitToJson: true)
class TreeStockTransferModel {
  TreeStockTransferModel({
    this.locationSrcId,
    this.locationSrcName,
    this.referenceSrc,
    this.referenceSrcId,
    this.referenceDest,
    this.referenceDestId,
    this.locationDestId,
    this.parentLocationDestId,
    this.parentPathDest,
    this.parentLocationDestName,
    this.locationDestName,
    this.productTmpId,
    this.objectType,
    this.objectName,
    this.quantity,
    this.unitId,
    this.unitName,
    this.isAutoGenerateLine,
    this.voucherType,
    this.isConfirm,
    this.metadataContentObjs,
    this.moveLineDetail,
  });

  factory TreeStockTransferModel.fromJson(Map<String, dynamic> json) =>
      _$TreeStockTransferModelFromJson(json);

  @JsonKey(name: 'locationSrcId', includeIfNull: false)
  final String? locationSrcId;
  @JsonKey(name: 'locationSrcName', includeIfNull: false)
  final String? locationSrcName;
  @JsonKey(name: 'referenceSrc', includeIfNull: false)
  final String? referenceSrc;
  @JsonKey(name: 'referenceSrcId', includeIfNull: false)
  final String? referenceSrcId;
  @JsonKey(name: 'referenceDest', includeIfNull: false)
  final String? referenceDest;
  @JsonKey(name: 'referenceDestId', includeIfNull: false)
  final String? referenceDestId;
  @JsonKey(name: 'locationDestId', includeIfNull: false)
  final String? locationDestId;
  @JsonKey(name: 'parentLocationDestId', includeIfNull: false)
  final String? parentLocationDestId;
  @JsonKey(name: 'parentPathDest', includeIfNull: false)
  final String? parentPathDest;
  @JsonKey(name: 'parentLocationDestName', includeIfNull: false)
  final String? parentLocationDestName;
  @JsonKey(name: 'locationDestName', includeIfNull: false)
  final String? locationDestName;
  @JsonKey(name: 'productTmpId', includeIfNull: false)
  final String? productTmpId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(name: 'objectName', includeIfNull: false)
  final String? objectName;
  @JsonKey(name: 'quantity', includeIfNull: false)
  final double? quantity;
  @JsonKey(name: 'unitId', includeIfNull: false)
  final String? unitId;
  @JsonKey(name: 'unitName', includeIfNull: false)
  final String? unitName;
  @JsonKey(name: 'isAutoGenerateLine', includeIfNull: false)
  final bool? isAutoGenerateLine;
  @JsonKey(name: 'voucherType', includeIfNull: false)
  final String? voucherType;
  @JsonKey(name: 'isConfirm', includeIfNull: false)
  final bool? isConfirm;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(
      name: 'moveLineDetail',
      includeIfNull: false,
      defaultValue: <LotDetailModel>[])
  final List<LotDetailModel>? moveLineDetail;
  static const fromJsonFactory = _$TreeStockTransferModelFromJson;
  static const toJsonFactory = _$TreeStockTransferModelToJson;
  Map<String, dynamic> toJson() => _$TreeStockTransferModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TreeStockTransferModel &&
            (identical(other.locationSrcId, locationSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcId, locationSrcId)) &&
            (identical(other.locationSrcName, locationSrcName) ||
                const DeepCollectionEquality()
                    .equals(other.locationSrcName, locationSrcName)) &&
            (identical(other.referenceSrc, referenceSrc) ||
                const DeepCollectionEquality()
                    .equals(other.referenceSrc, referenceSrc)) &&
            (identical(other.referenceSrcId, referenceSrcId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceSrcId, referenceSrcId)) &&
            (identical(other.referenceDest, referenceDest) ||
                const DeepCollectionEquality()
                    .equals(other.referenceDest, referenceDest)) &&
            (identical(other.referenceDestId, referenceDestId) ||
                const DeepCollectionEquality()
                    .equals(other.referenceDestId, referenceDestId)) &&
            (identical(other.locationDestId, locationDestId) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestId, locationDestId)) &&
            (identical(other.parentLocationDestId, parentLocationDestId) ||
                const DeepCollectionEquality().equals(
                    other.parentLocationDestId, parentLocationDestId)) &&
            (identical(other.parentPathDest, parentPathDest) ||
                const DeepCollectionEquality()
                    .equals(other.parentPathDest, parentPathDest)) &&
            (identical(other.parentLocationDestName, parentLocationDestName) ||
                const DeepCollectionEquality().equals(
                    other.parentLocationDestName, parentLocationDestName)) &&
            (identical(other.locationDestName, locationDestName) ||
                const DeepCollectionEquality()
                    .equals(other.locationDestName, locationDestName)) &&
            (identical(other.productTmpId, productTmpId) ||
                const DeepCollectionEquality()
                    .equals(other.productTmpId, productTmpId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.objectName, objectName) ||
                const DeepCollectionEquality()
                    .equals(other.objectName, objectName)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.unitId, unitId) ||
                const DeepCollectionEquality().equals(other.unitId, unitId)) &&
            (identical(other.unitName, unitName) ||
                const DeepCollectionEquality()
                    .equals(other.unitName, unitName)) &&
            (identical(other.isAutoGenerateLine, isAutoGenerateLine) ||
                const DeepCollectionEquality()
                    .equals(other.isAutoGenerateLine, isAutoGenerateLine)) &&
            (identical(other.voucherType, voucherType) ||
                const DeepCollectionEquality()
                    .equals(other.voucherType, voucherType)) &&
            (identical(other.isConfirm, isConfirm) ||
                const DeepCollectionEquality()
                    .equals(other.isConfirm, isConfirm)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.moveLineDetail, moveLineDetail) ||
                const DeepCollectionEquality()
                    .equals(other.moveLineDetail, moveLineDetail)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(locationSrcId) ^
      const DeepCollectionEquality().hash(locationSrcName) ^
      const DeepCollectionEquality().hash(referenceSrc) ^
      const DeepCollectionEquality().hash(referenceSrcId) ^
      const DeepCollectionEquality().hash(referenceDest) ^
      const DeepCollectionEquality().hash(referenceDestId) ^
      const DeepCollectionEquality().hash(locationDestId) ^
      const DeepCollectionEquality().hash(parentLocationDestId) ^
      const DeepCollectionEquality().hash(parentPathDest) ^
      const DeepCollectionEquality().hash(parentLocationDestName) ^
      const DeepCollectionEquality().hash(locationDestName) ^
      const DeepCollectionEquality().hash(productTmpId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(objectName) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(unitId) ^
      const DeepCollectionEquality().hash(unitName) ^
      const DeepCollectionEquality().hash(isAutoGenerateLine) ^
      const DeepCollectionEquality().hash(voucherType) ^
      const DeepCollectionEquality().hash(isConfirm) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(moveLineDetail) ^
      runtimeType.hashCode;
}

extension $TreeStockTransferModelExtension on TreeStockTransferModel {
  TreeStockTransferModel copyWith(
      {String? locationSrcId,
      String? locationSrcName,
      String? referenceSrc,
      String? referenceSrcId,
      String? referenceDest,
      String? referenceDestId,
      String? locationDestId,
      String? parentLocationDestId,
      String? parentPathDest,
      String? parentLocationDestName,
      String? locationDestName,
      String? productTmpId,
      String? objectType,
      String? objectName,
      double? quantity,
      String? unitId,
      String? unitName,
      bool? isAutoGenerateLine,
      String? voucherType,
      bool? isConfirm,
      List<MetadataValue>? metadataContentObjs,
      List<LotDetailModel>? moveLineDetail}) {
    return TreeStockTransferModel(
        locationSrcId: locationSrcId ?? this.locationSrcId,
        locationSrcName: locationSrcName ?? this.locationSrcName,
        referenceSrc: referenceSrc ?? this.referenceSrc,
        referenceSrcId: referenceSrcId ?? this.referenceSrcId,
        referenceDest: referenceDest ?? this.referenceDest,
        referenceDestId: referenceDestId ?? this.referenceDestId,
        locationDestId: locationDestId ?? this.locationDestId,
        parentLocationDestId: parentLocationDestId ?? this.parentLocationDestId,
        parentPathDest: parentPathDest ?? this.parentPathDest,
        parentLocationDestName:
            parentLocationDestName ?? this.parentLocationDestName,
        locationDestName: locationDestName ?? this.locationDestName,
        productTmpId: productTmpId ?? this.productTmpId,
        objectType: objectType ?? this.objectType,
        objectName: objectName ?? this.objectName,
        quantity: quantity ?? this.quantity,
        unitId: unitId ?? this.unitId,
        unitName: unitName ?? this.unitName,
        isAutoGenerateLine: isAutoGenerateLine ?? this.isAutoGenerateLine,
        voucherType: voucherType ?? this.voucherType,
        isConfirm: isConfirm ?? this.isConfirm,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        moveLineDetail: moveLineDetail ?? this.moveLineDetail);
  }
}

@JsonSerializable(explicitToJson: true)
class UploadFileRequestModel {
  UploadFileRequestModel({
    this.objectId,
    this.objectType,
    this.relatedRoleCodeObjects,
    this.relatedRoleCode,
    this.relatedObjectIdList,
    this.relatedBaseCategory,
    this.relatedFondId,
    this.relatedArchiveTypeId,
    this.relatedRecordCollectionId,
    this.relatedRecordId,
    this.relatedProjectId,
    this.relatedTaskId,
    this.relatedRespartnerId,
    this.relatedObject1,
    this.relatedObject1Type,
    this.relatedObject2,
    this.relatedObject2Type,
    this.id,
    this.parentId,
    this.name,
    this.type,
    this.labelsObjs,
    this.labels,
    this.imageUrl,
    this.description,
    this.nodeTypeObj,
    this.metaContentType,
    this.metadataContentObj,
    this.metadataObj,
    this.ownerId,
    this.isPublish,
    this.isSearchable,
    this.aclObject,
    this.metaContent,
    this.parentIds,
    required this.file,
  });

  factory UploadFileRequestModel.fromJson(Map<String, dynamic> json) =>
      _$UploadFileRequestModelFromJson(json);

  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'objectType', includeIfNull: false)
  final String? objectType;
  @JsonKey(
      name: 'relatedRoleCodeObjects',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? relatedRoleCodeObjects;
  @JsonKey(name: 'relatedRoleCode', includeIfNull: false)
  final String? relatedRoleCode;
  @JsonKey(
      name: 'relatedObjectIdList',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? relatedObjectIdList;
  @JsonKey(name: 'relatedBaseCategory', includeIfNull: false)
  final String? relatedBaseCategory;
  @JsonKey(name: 'relatedFondId', includeIfNull: false)
  final String? relatedFondId;
  @JsonKey(name: 'relatedArchiveTypeId', includeIfNull: false)
  final String? relatedArchiveTypeId;
  @JsonKey(name: 'relatedRecordCollectionId', includeIfNull: false)
  final String? relatedRecordCollectionId;
  @JsonKey(name: 'relatedRecordId', includeIfNull: false)
  final String? relatedRecordId;
  @JsonKey(name: 'relatedProjectId', includeIfNull: false)
  final String? relatedProjectId;
  @JsonKey(name: 'relatedTaskId', includeIfNull: false)
  final String? relatedTaskId;
  @JsonKey(name: 'relatedRespartnerId', includeIfNull: false)
  final String? relatedRespartnerId;
  @JsonKey(name: 'relatedObject1', includeIfNull: false)
  final String? relatedObject1;
  @JsonKey(name: 'relatedObject1Type', includeIfNull: false)
  final String? relatedObject1Type;
  @JsonKey(name: 'relatedObject2', includeIfNull: false)
  final String? relatedObject2;
  @JsonKey(name: 'relatedObject2Type', includeIfNull: false)
  final String? relatedObject2Type;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'parentId', includeIfNull: false)
  final String? parentId;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'type', includeIfNull: false)
  final String? type;
  @JsonKey(
      name: 'labelsObjs', includeIfNull: false, defaultValue: <LabelsObj>[])
  final List<LabelsObj>? labelsObjs;
  @JsonKey(name: 'labels', includeIfNull: false)
  final String? labels;
  @JsonKey(name: 'imageUrl', includeIfNull: false)
  final String? imageUrl;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(
      name: 'nodeTypeObj',
      includeIfNull: false,
      toJson: nodeTypeEnumToJson,
      fromJson: nodeTypeEnumFromJson)
  final enums.NodeTypeEnum? nodeTypeObj;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(
      name: 'metadataContentObj',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObj;
  @JsonKey(
      name: 'metadataObj',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataObj;
  @JsonKey(name: 'ownerId', includeIfNull: false)
  final String? ownerId;
  @JsonKey(name: 'isPublish', includeIfNull: false)
  final bool? isPublish;
  @JsonKey(name: 'isSearchable', includeIfNull: false)
  final bool? isSearchable;
  @JsonKey(name: 'aclObject', includeIfNull: false)
  final ACLObject? aclObject;
  @JsonKey(name: 'metaContent', includeIfNull: false)
  final String? metaContent;
  @JsonKey(name: 'parentIds', includeIfNull: false, defaultValue: <String>[])
  final List<String>? parentIds;
  @JsonKey(name: 'file', includeIfNull: false)
  final String file;
  static const fromJsonFactory = _$UploadFileRequestModelFromJson;
  static const toJsonFactory = _$UploadFileRequestModelToJson;
  Map<String, dynamic> toJson() => _$UploadFileRequestModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UploadFileRequestModel &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.relatedRoleCodeObjects, relatedRoleCodeObjects) ||
                const DeepCollectionEquality().equals(
                    other.relatedRoleCodeObjects, relatedRoleCodeObjects)) &&
            (identical(other.relatedRoleCode, relatedRoleCode) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRoleCode, relatedRoleCode)) &&
            (identical(other.relatedObjectIdList, relatedObjectIdList) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObjectIdList, relatedObjectIdList)) &&
            (identical(other.relatedBaseCategory, relatedBaseCategory) ||
                const DeepCollectionEquality()
                    .equals(other.relatedBaseCategory, relatedBaseCategory)) &&
            (identical(other.relatedFondId, relatedFondId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedFondId, relatedFondId)) &&
            (identical(other.relatedArchiveTypeId, relatedArchiveTypeId) ||
                const DeepCollectionEquality().equals(
                    other.relatedArchiveTypeId, relatedArchiveTypeId)) &&
            (identical(other.relatedRecordCollectionId, relatedRecordCollectionId) ||
                const DeepCollectionEquality().equals(
                    other.relatedRecordCollectionId,
                    relatedRecordCollectionId)) &&
            (identical(other.relatedRecordId, relatedRecordId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRecordId, relatedRecordId)) &&
            (identical(other.relatedProjectId, relatedProjectId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedProjectId, relatedProjectId)) &&
            (identical(other.relatedTaskId, relatedTaskId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedTaskId, relatedTaskId)) &&
            (identical(other.relatedRespartnerId, relatedRespartnerId) ||
                const DeepCollectionEquality()
                    .equals(other.relatedRespartnerId, relatedRespartnerId)) &&
            (identical(other.relatedObject1, relatedObject1) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject1, relatedObject1)) &&
            (identical(other.relatedObject1Type, relatedObject1Type) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject1Type, relatedObject1Type)) &&
            (identical(other.relatedObject2, relatedObject2) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject2, relatedObject2)) &&
            (identical(other.relatedObject2Type, relatedObject2Type) ||
                const DeepCollectionEquality()
                    .equals(other.relatedObject2Type, relatedObject2Type)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.parentId, parentId) ||
                const DeepCollectionEquality()
                    .equals(other.parentId, parentId)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.labelsObjs, labelsObjs) || const DeepCollectionEquality().equals(other.labelsObjs, labelsObjs)) &&
            (identical(other.labels, labels) || const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.imageUrl, imageUrl) || const DeepCollectionEquality().equals(other.imageUrl, imageUrl)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.nodeTypeObj, nodeTypeObj) || const DeepCollectionEquality().equals(other.nodeTypeObj, nodeTypeObj)) &&
            (identical(other.metaContentType, metaContentType) || const DeepCollectionEquality().equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContentObj, metadataContentObj) || const DeepCollectionEquality().equals(other.metadataContentObj, metadataContentObj)) &&
            (identical(other.metadataObj, metadataObj) || const DeepCollectionEquality().equals(other.metadataObj, metadataObj)) &&
            (identical(other.ownerId, ownerId) || const DeepCollectionEquality().equals(other.ownerId, ownerId)) &&
            (identical(other.isPublish, isPublish) || const DeepCollectionEquality().equals(other.isPublish, isPublish)) &&
            (identical(other.isSearchable, isSearchable) || const DeepCollectionEquality().equals(other.isSearchable, isSearchable)) &&
            (identical(other.aclObject, aclObject) || const DeepCollectionEquality().equals(other.aclObject, aclObject)) &&
            (identical(other.metaContent, metaContent) || const DeepCollectionEquality().equals(other.metaContent, metaContent)) &&
            (identical(other.parentIds, parentIds) || const DeepCollectionEquality().equals(other.parentIds, parentIds)) &&
            (identical(other.file, file) || const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(relatedRoleCodeObjects) ^
      const DeepCollectionEquality().hash(relatedRoleCode) ^
      const DeepCollectionEquality().hash(relatedObjectIdList) ^
      const DeepCollectionEquality().hash(relatedBaseCategory) ^
      const DeepCollectionEquality().hash(relatedFondId) ^
      const DeepCollectionEquality().hash(relatedArchiveTypeId) ^
      const DeepCollectionEquality().hash(relatedRecordCollectionId) ^
      const DeepCollectionEquality().hash(relatedRecordId) ^
      const DeepCollectionEquality().hash(relatedProjectId) ^
      const DeepCollectionEquality().hash(relatedTaskId) ^
      const DeepCollectionEquality().hash(relatedRespartnerId) ^
      const DeepCollectionEquality().hash(relatedObject1) ^
      const DeepCollectionEquality().hash(relatedObject1Type) ^
      const DeepCollectionEquality().hash(relatedObject2) ^
      const DeepCollectionEquality().hash(relatedObject2Type) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(parentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(labelsObjs) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(nodeTypeObj) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContentObj) ^
      const DeepCollectionEquality().hash(metadataObj) ^
      const DeepCollectionEquality().hash(ownerId) ^
      const DeepCollectionEquality().hash(isPublish) ^
      const DeepCollectionEquality().hash(isSearchable) ^
      const DeepCollectionEquality().hash(aclObject) ^
      const DeepCollectionEquality().hash(metaContent) ^
      const DeepCollectionEquality().hash(parentIds) ^
      const DeepCollectionEquality().hash(file) ^
      runtimeType.hashCode;
}

extension $UploadFileRequestModelExtension on UploadFileRequestModel {
  UploadFileRequestModel copyWith(
      {String? objectId,
      String? objectType,
      List<String>? relatedRoleCodeObjects,
      String? relatedRoleCode,
      List<String>? relatedObjectIdList,
      String? relatedBaseCategory,
      String? relatedFondId,
      String? relatedArchiveTypeId,
      String? relatedRecordCollectionId,
      String? relatedRecordId,
      String? relatedProjectId,
      String? relatedTaskId,
      String? relatedRespartnerId,
      String? relatedObject1,
      String? relatedObject1Type,
      String? relatedObject2,
      String? relatedObject2Type,
      String? id,
      String? parentId,
      String? name,
      String? type,
      List<LabelsObj>? labelsObjs,
      String? labels,
      String? imageUrl,
      String? description,
      enums.NodeTypeEnum? nodeTypeObj,
      String? metaContentType,
      List<MetadataValue>? metadataContentObj,
      List<MetadataValue>? metadataObj,
      String? ownerId,
      bool? isPublish,
      bool? isSearchable,
      ACLObject? aclObject,
      String? metaContent,
      List<String>? parentIds,
      String? file}) {
    return UploadFileRequestModel(
        objectId: objectId ?? this.objectId,
        objectType: objectType ?? this.objectType,
        relatedRoleCodeObjects:
            relatedRoleCodeObjects ?? this.relatedRoleCodeObjects,
        relatedRoleCode: relatedRoleCode ?? this.relatedRoleCode,
        relatedObjectIdList: relatedObjectIdList ?? this.relatedObjectIdList,
        relatedBaseCategory: relatedBaseCategory ?? this.relatedBaseCategory,
        relatedFondId: relatedFondId ?? this.relatedFondId,
        relatedArchiveTypeId: relatedArchiveTypeId ?? this.relatedArchiveTypeId,
        relatedRecordCollectionId:
            relatedRecordCollectionId ?? this.relatedRecordCollectionId,
        relatedRecordId: relatedRecordId ?? this.relatedRecordId,
        relatedProjectId: relatedProjectId ?? this.relatedProjectId,
        relatedTaskId: relatedTaskId ?? this.relatedTaskId,
        relatedRespartnerId: relatedRespartnerId ?? this.relatedRespartnerId,
        relatedObject1: relatedObject1 ?? this.relatedObject1,
        relatedObject1Type: relatedObject1Type ?? this.relatedObject1Type,
        relatedObject2: relatedObject2 ?? this.relatedObject2,
        relatedObject2Type: relatedObject2Type ?? this.relatedObject2Type,
        id: id ?? this.id,
        parentId: parentId ?? this.parentId,
        name: name ?? this.name,
        type: type ?? this.type,
        labelsObjs: labelsObjs ?? this.labelsObjs,
        labels: labels ?? this.labels,
        imageUrl: imageUrl ?? this.imageUrl,
        description: description ?? this.description,
        nodeTypeObj: nodeTypeObj ?? this.nodeTypeObj,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContentObj: metadataContentObj ?? this.metadataContentObj,
        metadataObj: metadataObj ?? this.metadataObj,
        ownerId: ownerId ?? this.ownerId,
        isPublish: isPublish ?? this.isPublish,
        isSearchable: isSearchable ?? this.isSearchable,
        aclObject: aclObject ?? this.aclObject,
        metaContent: metaContent ?? this.metaContent,
        parentIds: parentIds ?? this.parentIds,
        file: file ?? this.file);
  }
}

@JsonSerializable(explicitToJson: true)
class UserEntity {
  UserEntity({
    this.userId,
    this.userEmail,
    this.name,
    this.userName,
  });

  factory UserEntity.fromJson(Map<String, dynamic> json) =>
      _$UserEntityFromJson(json);

  @JsonKey(name: 'userId', includeIfNull: false)
  final String? userId;
  @JsonKey(name: 'userEmail', includeIfNull: false)
  final String? userEmail;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'userName', includeIfNull: false)
  final String? userName;
  static const fromJsonFactory = _$UserEntityFromJson;
  static const toJsonFactory = _$UserEntityToJson;
  Map<String, dynamic> toJson() => _$UserEntityToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserEntity &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(userName) ^
      runtimeType.hashCode;
}

extension $UserEntityExtension on UserEntity {
  UserEntity copyWith(
      {String? userId, String? userEmail, String? name, String? userName}) {
    return UserEntity(
        userId: userId ?? this.userId,
        userEmail: userEmail ?? this.userEmail,
        name: name ?? this.name,
        userName: userName ?? this.userName);
  }
}

@JsonSerializable(explicitToJson: true)
class Website {
  Website({
    this.type,
    this.url,
  });

  factory Website.fromJson(Map<String, dynamic> json) =>
      _$WebsiteFromJson(json);

  @JsonKey(name: 'type', includeIfNull: false, defaultValue: <String>[])
  final List<String>? type;
  @JsonKey(name: 'url', includeIfNull: false)
  final String? url;
  static const fromJsonFactory = _$WebsiteFromJson;
  static const toJsonFactory = _$WebsiteToJson;
  Map<String, dynamic> toJson() => _$WebsiteToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Website &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $WebsiteExtension on Website {
  Website copyWith({List<String>? type, String? url}) {
    return Website(type: type ?? this.type, url: url ?? this.url);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkCenter {
  WorkCenter({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.name,
    this.timeEfficiency,
    this.code,
    this.capacity,
    this.costsHour,
    this.timeStart,
    this.timeStop,
    this.workingState,
    this.oeeTarget,
    this.resourceId,
    this.companyId,
    this.companyName,
    this.resourceCalendarId,
    this.deXeDecimal,
    this.description,
    this.order,
    this.isActive,
  });

  factory WorkCenter.fromJson(Map<String, dynamic> json) =>
      _$WorkCenterFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'timeEfficiency', includeIfNull: false)
  final double? timeEfficiency;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'capacity', includeIfNull: false)
  final double? capacity;
  @JsonKey(name: 'costsHour', includeIfNull: false)
  final double? costsHour;
  @JsonKey(name: 'timeStart', includeIfNull: false)
  final double? timeStart;
  @JsonKey(name: 'timeStop', includeIfNull: false)
  final double? timeStop;
  @JsonKey(name: 'workingState', includeIfNull: false)
  final String? workingState;
  @JsonKey(name: 'oeeTarget', includeIfNull: false)
  final double? oeeTarget;
  @JsonKey(name: 'resourceId', includeIfNull: false)
  final String? resourceId;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  @JsonKey(name: 'companyName', includeIfNull: false)
  final String? companyName;
  @JsonKey(name: 'resourceCalendarId', includeIfNull: false)
  final String? resourceCalendarId;
  @JsonKey(name: 'deXeDecimal', includeIfNull: false)
  final double? deXeDecimal;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  static const fromJsonFactory = _$WorkCenterFromJson;
  static const toJsonFactory = _$WorkCenterToJson;
  Map<String, dynamic> toJson() => _$WorkCenterToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkCenter &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.timeEfficiency, timeEfficiency) ||
                const DeepCollectionEquality()
                    .equals(other.timeEfficiency, timeEfficiency)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.capacity, capacity) ||
                const DeepCollectionEquality()
                    .equals(other.capacity, capacity)) &&
            (identical(other.costsHour, costsHour) ||
                const DeepCollectionEquality()
                    .equals(other.costsHour, costsHour)) &&
            (identical(other.timeStart, timeStart) ||
                const DeepCollectionEquality()
                    .equals(other.timeStart, timeStart)) &&
            (identical(other.timeStop, timeStop) ||
                const DeepCollectionEquality()
                    .equals(other.timeStop, timeStop)) &&
            (identical(other.workingState, workingState) ||
                const DeepCollectionEquality()
                    .equals(other.workingState, workingState)) &&
            (identical(other.oeeTarget, oeeTarget) ||
                const DeepCollectionEquality()
                    .equals(other.oeeTarget, oeeTarget)) &&
            (identical(other.resourceId, resourceId) ||
                const DeepCollectionEquality()
                    .equals(other.resourceId, resourceId)) &&
            (identical(other.companyId, companyId) ||
                const DeepCollectionEquality()
                    .equals(other.companyId, companyId)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.resourceCalendarId, resourceCalendarId) ||
                const DeepCollectionEquality()
                    .equals(other.resourceCalendarId, resourceCalendarId)) &&
            (identical(other.deXeDecimal, deXeDecimal) ||
                const DeepCollectionEquality()
                    .equals(other.deXeDecimal, deXeDecimal)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isActive, isActive) || const DeepCollectionEquality().equals(other.isActive, isActive)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(timeEfficiency) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(capacity) ^
      const DeepCollectionEquality().hash(costsHour) ^
      const DeepCollectionEquality().hash(timeStart) ^
      const DeepCollectionEquality().hash(timeStop) ^
      const DeepCollectionEquality().hash(workingState) ^
      const DeepCollectionEquality().hash(oeeTarget) ^
      const DeepCollectionEquality().hash(resourceId) ^
      const DeepCollectionEquality().hash(companyId) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(resourceCalendarId) ^
      const DeepCollectionEquality().hash(deXeDecimal) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $WorkCenterExtension on WorkCenter {
  WorkCenter copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? name,
      double? timeEfficiency,
      String? code,
      double? capacity,
      double? costsHour,
      double? timeStart,
      double? timeStop,
      String? workingState,
      double? oeeTarget,
      String? resourceId,
      String? companyId,
      String? companyName,
      String? resourceCalendarId,
      double? deXeDecimal,
      String? description,
      int? order,
      bool? isActive}) {
    return WorkCenter(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        name: name ?? this.name,
        timeEfficiency: timeEfficiency ?? this.timeEfficiency,
        code: code ?? this.code,
        capacity: capacity ?? this.capacity,
        costsHour: costsHour ?? this.costsHour,
        timeStart: timeStart ?? this.timeStart,
        timeStop: timeStop ?? this.timeStop,
        workingState: workingState ?? this.workingState,
        oeeTarget: oeeTarget ?? this.oeeTarget,
        resourceId: resourceId ?? this.resourceId,
        companyId: companyId ?? this.companyId,
        companyName: companyName ?? this.companyName,
        resourceCalendarId: resourceCalendarId ?? this.resourceCalendarId,
        deXeDecimal: deXeDecimal ?? this.deXeDecimal,
        description: description ?? this.description,
        order: order ?? this.order,
        isActive: isActive ?? this.isActive);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkCenterModel {
  WorkCenterModel({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.name,
    this.timeEfficiency,
    this.code,
    this.capacity,
    this.costsHour,
    this.timeStart,
    this.timeStop,
    this.workingState,
    this.oeeTarget,
    this.resourceId,
    this.companyId,
    this.companyName,
    this.resourceCalendarId,
    this.deXeDecimal,
    this.description,
    this.order,
    this.isActive,
    this.timeStartString,
    this.timeStopString,
  });

  factory WorkCenterModel.fromJson(Map<String, dynamic> json) =>
      _$WorkCenterModelFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'timeEfficiency', includeIfNull: false)
  final double? timeEfficiency;
  @JsonKey(name: 'code', includeIfNull: false)
  final String? code;
  @JsonKey(name: 'capacity', includeIfNull: false)
  final double? capacity;
  @JsonKey(name: 'costsHour', includeIfNull: false)
  final double? costsHour;
  @JsonKey(name: 'timeStart', includeIfNull: false)
  final double? timeStart;
  @JsonKey(name: 'timeStop', includeIfNull: false)
  final double? timeStop;
  @JsonKey(name: 'workingState', includeIfNull: false)
  final String? workingState;
  @JsonKey(name: 'oeeTarget', includeIfNull: false)
  final double? oeeTarget;
  @JsonKey(name: 'resourceId', includeIfNull: false)
  final String? resourceId;
  @JsonKey(name: 'companyId', includeIfNull: false)
  final String? companyId;
  @JsonKey(name: 'companyName', includeIfNull: false)
  final String? companyName;
  @JsonKey(name: 'resourceCalendarId', includeIfNull: false)
  final String? resourceCalendarId;
  @JsonKey(name: 'deXeDecimal', includeIfNull: false)
  final double? deXeDecimal;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'isActive', includeIfNull: false)
  final bool? isActive;
  @JsonKey(name: 'timeStartString', includeIfNull: false)
  final String? timeStartString;
  @JsonKey(name: 'timeStopString', includeIfNull: false)
  final String? timeStopString;
  static const fromJsonFactory = _$WorkCenterModelFromJson;
  static const toJsonFactory = _$WorkCenterModelToJson;
  Map<String, dynamic> toJson() => _$WorkCenterModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkCenterModel &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.timeEfficiency, timeEfficiency) ||
                const DeepCollectionEquality()
                    .equals(other.timeEfficiency, timeEfficiency)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.capacity, capacity) ||
                const DeepCollectionEquality()
                    .equals(other.capacity, capacity)) &&
            (identical(other.costsHour, costsHour) ||
                const DeepCollectionEquality()
                    .equals(other.costsHour, costsHour)) &&
            (identical(other.timeStart, timeStart) ||
                const DeepCollectionEquality()
                    .equals(other.timeStart, timeStart)) &&
            (identical(other.timeStop, timeStop) ||
                const DeepCollectionEquality()
                    .equals(other.timeStop, timeStop)) &&
            (identical(other.workingState, workingState) ||
                const DeepCollectionEquality()
                    .equals(other.workingState, workingState)) &&
            (identical(other.oeeTarget, oeeTarget) ||
                const DeepCollectionEquality()
                    .equals(other.oeeTarget, oeeTarget)) &&
            (identical(other.resourceId, resourceId) ||
                const DeepCollectionEquality()
                    .equals(other.resourceId, resourceId)) &&
            (identical(other.companyId, companyId) ||
                const DeepCollectionEquality()
                    .equals(other.companyId, companyId)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.resourceCalendarId, resourceCalendarId) ||
                const DeepCollectionEquality()
                    .equals(other.resourceCalendarId, resourceCalendarId)) &&
            (identical(other.deXeDecimal, deXeDecimal) ||
                const DeepCollectionEquality()
                    .equals(other.deXeDecimal, deXeDecimal)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.order, order) || const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.isActive, isActive) || const DeepCollectionEquality().equals(other.isActive, isActive)) &&
            (identical(other.timeStartString, timeStartString) || const DeepCollectionEquality().equals(other.timeStartString, timeStartString)) &&
            (identical(other.timeStopString, timeStopString) || const DeepCollectionEquality().equals(other.timeStopString, timeStopString)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(timeEfficiency) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(capacity) ^
      const DeepCollectionEquality().hash(costsHour) ^
      const DeepCollectionEquality().hash(timeStart) ^
      const DeepCollectionEquality().hash(timeStop) ^
      const DeepCollectionEquality().hash(workingState) ^
      const DeepCollectionEquality().hash(oeeTarget) ^
      const DeepCollectionEquality().hash(resourceId) ^
      const DeepCollectionEquality().hash(companyId) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(resourceCalendarId) ^
      const DeepCollectionEquality().hash(deXeDecimal) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(timeStartString) ^
      const DeepCollectionEquality().hash(timeStopString) ^
      runtimeType.hashCode;
}

extension $WorkCenterModelExtension on WorkCenterModel {
  WorkCenterModel copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? name,
      double? timeEfficiency,
      String? code,
      double? capacity,
      double? costsHour,
      double? timeStart,
      double? timeStop,
      String? workingState,
      double? oeeTarget,
      String? resourceId,
      String? companyId,
      String? companyName,
      String? resourceCalendarId,
      double? deXeDecimal,
      String? description,
      int? order,
      bool? isActive,
      String? timeStartString,
      String? timeStopString}) {
    return WorkCenterModel(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        name: name ?? this.name,
        timeEfficiency: timeEfficiency ?? this.timeEfficiency,
        code: code ?? this.code,
        capacity: capacity ?? this.capacity,
        costsHour: costsHour ?? this.costsHour,
        timeStart: timeStart ?? this.timeStart,
        timeStop: timeStop ?? this.timeStop,
        workingState: workingState ?? this.workingState,
        oeeTarget: oeeTarget ?? this.oeeTarget,
        resourceId: resourceId ?? this.resourceId,
        companyId: companyId ?? this.companyId,
        companyName: companyName ?? this.companyName,
        resourceCalendarId: resourceCalendarId ?? this.resourceCalendarId,
        deXeDecimal: deXeDecimal ?? this.deXeDecimal,
        description: description ?? this.description,
        order: order ?? this.order,
        isActive: isActive ?? this.isActive,
        timeStartString: timeStartString ?? this.timeStartString,
        timeStopString: timeStopString ?? this.timeStopString);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkCenterModelResponseObject {
  WorkCenterModelResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkCenterModelResponseObject.fromJson(Map<String, dynamic> json) =>
      _$WorkCenterModelResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final WorkCenterModel? data;
  static const fromJsonFactory = _$WorkCenterModelResponseObjectFromJson;
  static const toJsonFactory = _$WorkCenterModelResponseObjectToJson;
  Map<String, dynamic> toJson() => _$WorkCenterModelResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkCenterModelResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkCenterModelResponseObjectExtension
    on WorkCenterModelResponseObject {
  WorkCenterModelResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      WorkCenterModel? data}) {
    return WorkCenterModelResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkCenterPagination {
  WorkCenterPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory WorkCenterPagination.fromJson(Map<String, dynamic> json) =>
      _$WorkCenterPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: <WorkCenter>[])
  final List<WorkCenter>? content;
  static const fromJsonFactory = _$WorkCenterPaginationFromJson;
  static const toJsonFactory = _$WorkCenterPaginationToJson;
  Map<String, dynamic> toJson() => _$WorkCenterPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkCenterPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $WorkCenterPaginationExtension on WorkCenterPagination {
  WorkCenterPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<WorkCenter>? content}) {
    return WorkCenterPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkCenterResponseObject {
  WorkCenterResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkCenterResponseObject.fromJson(Map<String, dynamic> json) =>
      _$WorkCenterResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final WorkCenter? data;
  static const fromJsonFactory = _$WorkCenterResponseObjectFromJson;
  static const toJsonFactory = _$WorkCenterResponseObjectToJson;
  Map<String, dynamic> toJson() => _$WorkCenterResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkCenterResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkCenterResponseObjectExtension on WorkCenterResponseObject {
  WorkCenterResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, WorkCenter? data}) {
    return WorkCenterResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkCenterResponsePagination {
  WorkCenterResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkCenterResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$WorkCenterResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final WorkCenterPagination? data;
  static const fromJsonFactory = _$WorkCenterResponsePaginationFromJson;
  static const toJsonFactory = _$WorkCenterResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$WorkCenterResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkCenterResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkCenterResponsePaginationExtension
    on WorkCenterResponsePagination {
  WorkCenterResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      WorkCenterPagination? data}) {
    return WorkCenterResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkOrder {
  WorkOrder({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.name,
    this.workCenterId,
    this.productionId,
    this.objectId,
    this.productionAvailability,
    this.qtyProduced,
    this.qtyProducing,
    this.state,
    this.datePlannedStart,
    this.datePlannedFinished,
    this.dateStart,
    this.dateFinished,
    this.durationExpected,
    this.duration,
    this.durationUnit,
    this.durationPercent,
    this.operationId,
    this.finalLotId,
    this.nextWorkOrderId,
    this.productionDate,
    this.capacity,
    this.machineId,
    this.operatorId,
    this.semiFinishedProductId,
    this.semiFinishedProductUnitId,
    this.qtySemiFinishedProduct,
    this.description,
    this.totalQtyPlanned,
    this.convertToKgResult,
  });

  factory WorkOrder.fromJson(Map<String, dynamic> json) =>
      _$WorkOrderFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'workCenterId', includeIfNull: false)
  final String? workCenterId;
  @JsonKey(name: 'productionId', includeIfNull: false)
  final String? productionId;
  @JsonKey(name: 'objectId', includeIfNull: false)
  final String? objectId;
  @JsonKey(name: 'productionAvailability', includeIfNull: false)
  final String? productionAvailability;
  @JsonKey(name: 'qtyProduced', includeIfNull: false)
  final double? qtyProduced;
  @JsonKey(name: 'qtyProducing', includeIfNull: false)
  final double? qtyProducing;
  @JsonKey(name: 'state', includeIfNull: false)
  final String? state;
  @JsonKey(name: 'datePlannedStart', includeIfNull: false)
  final DateTime? datePlannedStart;
  @JsonKey(name: 'datePlannedFinished', includeIfNull: false)
  final DateTime? datePlannedFinished;
  @JsonKey(name: 'dateStart', includeIfNull: false)
  final DateTime? dateStart;
  @JsonKey(name: 'dateFinished', includeIfNull: false)
  final DateTime? dateFinished;
  @JsonKey(name: 'durationExpected', includeIfNull: false)
  final double? durationExpected;
  @JsonKey(name: 'duration', includeIfNull: false)
  final double? duration;
  @JsonKey(name: 'durationUnit', includeIfNull: false)
  final double? durationUnit;
  @JsonKey(name: 'durationPercent', includeIfNull: false)
  final int? durationPercent;
  @JsonKey(name: 'operationId', includeIfNull: false)
  final String? operationId;
  @JsonKey(name: 'finalLotId', includeIfNull: false)
  final String? finalLotId;
  @JsonKey(name: 'nextWorkOrderId', includeIfNull: false)
  final String? nextWorkOrderId;
  @JsonKey(name: 'productionDate', includeIfNull: false)
  final DateTime? productionDate;
  @JsonKey(name: 'capacity', includeIfNull: false)
  final double? capacity;
  @JsonKey(name: 'machineId', includeIfNull: false)
  final String? machineId;
  @JsonKey(name: 'operatorId', includeIfNull: false)
  final String? operatorId;
  @JsonKey(name: 'semiFinishedProductId', includeIfNull: false)
  final String? semiFinishedProductId;
  @JsonKey(name: 'semiFinishedProductUnitId', includeIfNull: false)
  final String? semiFinishedProductUnitId;
  @JsonKey(name: 'qtySemiFinishedProduct', includeIfNull: false)
  final double? qtySemiFinishedProduct;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  @JsonKey(name: 'totalQtyPlanned', includeIfNull: false)
  final double? totalQtyPlanned;
  @JsonKey(name: 'convertToKgResult', includeIfNull: false)
  final double? convertToKgResult;
  static const fromJsonFactory = _$WorkOrderFromJson;
  static const toJsonFactory = _$WorkOrderToJson;
  Map<String, dynamic> toJson() => _$WorkOrderToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkOrder &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.workCenterId, workCenterId) ||
                const DeepCollectionEquality()
                    .equals(other.workCenterId, workCenterId)) &&
            (identical(other.productionId, productionId) ||
                const DeepCollectionEquality()
                    .equals(other.productionId, productionId)) &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.productionAvailability, productionAvailability) ||
                const DeepCollectionEquality().equals(
                    other.productionAvailability, productionAvailability)) &&
            (identical(other.qtyProduced, qtyProduced) ||
                const DeepCollectionEquality()
                    .equals(other.qtyProduced, qtyProduced)) &&
            (identical(other.qtyProducing, qtyProducing) ||
                const DeepCollectionEquality()
                    .equals(other.qtyProducing, qtyProducing)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.datePlannedStart, datePlannedStart) ||
                const DeepCollectionEquality()
                    .equals(other.datePlannedStart, datePlannedStart)) &&
            (identical(other.datePlannedFinished, datePlannedFinished) ||
                const DeepCollectionEquality()
                    .equals(other.datePlannedFinished, datePlannedFinished)) &&
            (identical(other.dateStart, dateStart) ||
                const DeepCollectionEquality()
                    .equals(other.dateStart, dateStart)) &&
            (identical(other.dateFinished, dateFinished) ||
                const DeepCollectionEquality()
                    .equals(other.dateFinished, dateFinished)) &&
            (identical(other.durationExpected, durationExpected) ||
                const DeepCollectionEquality()
                    .equals(other.durationExpected, durationExpected)) &&
            (identical(other.duration, duration) ||
                const DeepCollectionEquality()
                    .equals(other.duration, duration)) &&
            (identical(other.durationUnit, durationUnit) || const DeepCollectionEquality().equals(other.durationUnit, durationUnit)) &&
            (identical(other.durationPercent, durationPercent) || const DeepCollectionEquality().equals(other.durationPercent, durationPercent)) &&
            (identical(other.operationId, operationId) || const DeepCollectionEquality().equals(other.operationId, operationId)) &&
            (identical(other.finalLotId, finalLotId) || const DeepCollectionEquality().equals(other.finalLotId, finalLotId)) &&
            (identical(other.nextWorkOrderId, nextWorkOrderId) || const DeepCollectionEquality().equals(other.nextWorkOrderId, nextWorkOrderId)) &&
            (identical(other.productionDate, productionDate) || const DeepCollectionEquality().equals(other.productionDate, productionDate)) &&
            (identical(other.capacity, capacity) || const DeepCollectionEquality().equals(other.capacity, capacity)) &&
            (identical(other.machineId, machineId) || const DeepCollectionEquality().equals(other.machineId, machineId)) &&
            (identical(other.operatorId, operatorId) || const DeepCollectionEquality().equals(other.operatorId, operatorId)) &&
            (identical(other.semiFinishedProductId, semiFinishedProductId) || const DeepCollectionEquality().equals(other.semiFinishedProductId, semiFinishedProductId)) &&
            (identical(other.semiFinishedProductUnitId, semiFinishedProductUnitId) || const DeepCollectionEquality().equals(other.semiFinishedProductUnitId, semiFinishedProductUnitId)) &&
            (identical(other.qtySemiFinishedProduct, qtySemiFinishedProduct) || const DeepCollectionEquality().equals(other.qtySemiFinishedProduct, qtySemiFinishedProduct)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.totalQtyPlanned, totalQtyPlanned) || const DeepCollectionEquality().equals(other.totalQtyPlanned, totalQtyPlanned)) &&
            (identical(other.convertToKgResult, convertToKgResult) || const DeepCollectionEquality().equals(other.convertToKgResult, convertToKgResult)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(workCenterId) ^
      const DeepCollectionEquality().hash(productionId) ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(productionAvailability) ^
      const DeepCollectionEquality().hash(qtyProduced) ^
      const DeepCollectionEquality().hash(qtyProducing) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(datePlannedStart) ^
      const DeepCollectionEquality().hash(datePlannedFinished) ^
      const DeepCollectionEquality().hash(dateStart) ^
      const DeepCollectionEquality().hash(dateFinished) ^
      const DeepCollectionEquality().hash(durationExpected) ^
      const DeepCollectionEquality().hash(duration) ^
      const DeepCollectionEquality().hash(durationUnit) ^
      const DeepCollectionEquality().hash(durationPercent) ^
      const DeepCollectionEquality().hash(operationId) ^
      const DeepCollectionEquality().hash(finalLotId) ^
      const DeepCollectionEquality().hash(nextWorkOrderId) ^
      const DeepCollectionEquality().hash(productionDate) ^
      const DeepCollectionEquality().hash(capacity) ^
      const DeepCollectionEquality().hash(machineId) ^
      const DeepCollectionEquality().hash(operatorId) ^
      const DeepCollectionEquality().hash(semiFinishedProductId) ^
      const DeepCollectionEquality().hash(semiFinishedProductUnitId) ^
      const DeepCollectionEquality().hash(qtySemiFinishedProduct) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(totalQtyPlanned) ^
      const DeepCollectionEquality().hash(convertToKgResult) ^
      runtimeType.hashCode;
}

extension $WorkOrderExtension on WorkOrder {
  WorkOrder copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? name,
      String? workCenterId,
      String? productionId,
      String? objectId,
      String? productionAvailability,
      double? qtyProduced,
      double? qtyProducing,
      String? state,
      DateTime? datePlannedStart,
      DateTime? datePlannedFinished,
      DateTime? dateStart,
      DateTime? dateFinished,
      double? durationExpected,
      double? duration,
      double? durationUnit,
      int? durationPercent,
      String? operationId,
      String? finalLotId,
      String? nextWorkOrderId,
      DateTime? productionDate,
      double? capacity,
      String? machineId,
      String? operatorId,
      String? semiFinishedProductId,
      String? semiFinishedProductUnitId,
      double? qtySemiFinishedProduct,
      String? description,
      double? totalQtyPlanned,
      double? convertToKgResult}) {
    return WorkOrder(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        name: name ?? this.name,
        workCenterId: workCenterId ?? this.workCenterId,
        productionId: productionId ?? this.productionId,
        objectId: objectId ?? this.objectId,
        productionAvailability:
            productionAvailability ?? this.productionAvailability,
        qtyProduced: qtyProduced ?? this.qtyProduced,
        qtyProducing: qtyProducing ?? this.qtyProducing,
        state: state ?? this.state,
        datePlannedStart: datePlannedStart ?? this.datePlannedStart,
        datePlannedFinished: datePlannedFinished ?? this.datePlannedFinished,
        dateStart: dateStart ?? this.dateStart,
        dateFinished: dateFinished ?? this.dateFinished,
        durationExpected: durationExpected ?? this.durationExpected,
        duration: duration ?? this.duration,
        durationUnit: durationUnit ?? this.durationUnit,
        durationPercent: durationPercent ?? this.durationPercent,
        operationId: operationId ?? this.operationId,
        finalLotId: finalLotId ?? this.finalLotId,
        nextWorkOrderId: nextWorkOrderId ?? this.nextWorkOrderId,
        productionDate: productionDate ?? this.productionDate,
        capacity: capacity ?? this.capacity,
        machineId: machineId ?? this.machineId,
        operatorId: operatorId ?? this.operatorId,
        semiFinishedProductId:
            semiFinishedProductId ?? this.semiFinishedProductId,
        semiFinishedProductUnitId:
            semiFinishedProductUnitId ?? this.semiFinishedProductUnitId,
        qtySemiFinishedProduct:
            qtySemiFinishedProduct ?? this.qtySemiFinishedProduct,
        description: description ?? this.description,
        totalQtyPlanned: totalQtyPlanned ?? this.totalQtyPlanned,
        convertToKgResult: convertToKgResult ?? this.convertToKgResult);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkOrderPagination {
  WorkOrderPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory WorkOrderPagination.fromJson(Map<String, dynamic> json) =>
      _$WorkOrderPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(name: 'content', includeIfNull: false, defaultValue: <WorkOrder>[])
  final List<WorkOrder>? content;
  static const fromJsonFactory = _$WorkOrderPaginationFromJson;
  static const toJsonFactory = _$WorkOrderPaginationToJson;
  Map<String, dynamic> toJson() => _$WorkOrderPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkOrderPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $WorkOrderPaginationExtension on WorkOrderPagination {
  WorkOrderPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<WorkOrder>? content}) {
    return WorkOrderPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkOrderPlanning {
  WorkOrderPlanning({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.workOrderId,
    this.workingTimeId,
    this.qtyPlanning,
    this.status,
  });

  factory WorkOrderPlanning.fromJson(Map<String, dynamic> json) =>
      _$WorkOrderPlanningFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'workOrderId', includeIfNull: false)
  final String? workOrderId;
  @JsonKey(name: 'workingTimeId', includeIfNull: false)
  final String? workingTimeId;
  @JsonKey(name: 'qtyPlanning', includeIfNull: false)
  final double? qtyPlanning;
  @JsonKey(name: 'status', includeIfNull: false)
  final String? status;
  static const fromJsonFactory = _$WorkOrderPlanningFromJson;
  static const toJsonFactory = _$WorkOrderPlanningToJson;
  Map<String, dynamic> toJson() => _$WorkOrderPlanningToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkOrderPlanning &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.workOrderId, workOrderId) ||
                const DeepCollectionEquality()
                    .equals(other.workOrderId, workOrderId)) &&
            (identical(other.workingTimeId, workingTimeId) ||
                const DeepCollectionEquality()
                    .equals(other.workingTimeId, workingTimeId)) &&
            (identical(other.qtyPlanning, qtyPlanning) ||
                const DeepCollectionEquality()
                    .equals(other.qtyPlanning, qtyPlanning)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(workOrderId) ^
      const DeepCollectionEquality().hash(workingTimeId) ^
      const DeepCollectionEquality().hash(qtyPlanning) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $WorkOrderPlanningExtension on WorkOrderPlanning {
  WorkOrderPlanning copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? workOrderId,
      String? workingTimeId,
      double? qtyPlanning,
      String? status}) {
    return WorkOrderPlanning(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        workOrderId: workOrderId ?? this.workOrderId,
        workingTimeId: workingTimeId ?? this.workingTimeId,
        qtyPlanning: qtyPlanning ?? this.qtyPlanning,
        status: status ?? this.status);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkOrderPlanningPagination {
  WorkOrderPlanningPagination({
    this.currentPage,
    this.totalPages,
    this.pageSize,
    this.numberOfRecords,
    this.totalRecords,
    this.content,
  });

  factory WorkOrderPlanningPagination.fromJson(Map<String, dynamic> json) =>
      _$WorkOrderPlanningPaginationFromJson(json);

  @JsonKey(name: 'currentPage', includeIfNull: false)
  final int? currentPage;
  @JsonKey(name: 'totalPages', includeIfNull: false)
  final int? totalPages;
  @JsonKey(name: 'pageSize', includeIfNull: false)
  final int? pageSize;
  @JsonKey(name: 'numberOfRecords', includeIfNull: false)
  final int? numberOfRecords;
  @JsonKey(name: 'totalRecords', includeIfNull: false)
  final int? totalRecords;
  @JsonKey(
      name: 'content',
      includeIfNull: false,
      defaultValue: <WorkOrderPlanning>[])
  final List<WorkOrderPlanning>? content;
  static const fromJsonFactory = _$WorkOrderPlanningPaginationFromJson;
  static const toJsonFactory = _$WorkOrderPlanningPaginationToJson;
  Map<String, dynamic> toJson() => _$WorkOrderPlanningPaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkOrderPlanningPagination &&
            (identical(other.currentPage, currentPage) ||
                const DeepCollectionEquality()
                    .equals(other.currentPage, currentPage)) &&
            (identical(other.totalPages, totalPages) ||
                const DeepCollectionEquality()
                    .equals(other.totalPages, totalPages)) &&
            (identical(other.pageSize, pageSize) ||
                const DeepCollectionEquality()
                    .equals(other.pageSize, pageSize)) &&
            (identical(other.numberOfRecords, numberOfRecords) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfRecords, numberOfRecords)) &&
            (identical(other.totalRecords, totalRecords) ||
                const DeepCollectionEquality()
                    .equals(other.totalRecords, totalRecords)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentPage) ^
      const DeepCollectionEquality().hash(totalPages) ^
      const DeepCollectionEquality().hash(pageSize) ^
      const DeepCollectionEquality().hash(numberOfRecords) ^
      const DeepCollectionEquality().hash(totalRecords) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $WorkOrderPlanningPaginationExtension on WorkOrderPlanningPagination {
  WorkOrderPlanningPagination copyWith(
      {int? currentPage,
      int? totalPages,
      int? pageSize,
      int? numberOfRecords,
      int? totalRecords,
      List<WorkOrderPlanning>? content}) {
    return WorkOrderPlanningPagination(
        currentPage: currentPage ?? this.currentPage,
        totalPages: totalPages ?? this.totalPages,
        pageSize: pageSize ?? this.pageSize,
        numberOfRecords: numberOfRecords ?? this.numberOfRecords,
        totalRecords: totalRecords ?? this.totalRecords,
        content: content ?? this.content);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkOrderPlanningResponseObject {
  WorkOrderPlanningResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkOrderPlanningResponseObject.fromJson(Map<String, dynamic> json) =>
      _$WorkOrderPlanningResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final WorkOrderPlanning? data;
  static const fromJsonFactory = _$WorkOrderPlanningResponseObjectFromJson;
  static const toJsonFactory = _$WorkOrderPlanningResponseObjectToJson;
  Map<String, dynamic> toJson() =>
      _$WorkOrderPlanningResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkOrderPlanningResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkOrderPlanningResponseObjectExtension
    on WorkOrderPlanningResponseObject {
  WorkOrderPlanningResponseObject copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      WorkOrderPlanning? data}) {
    return WorkOrderPlanningResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkOrderPlanningResponsePagination {
  WorkOrderPlanningResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkOrderPlanningResponsePagination.fromJson(
          Map<String, dynamic> json) =>
      _$WorkOrderPlanningResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final WorkOrderPlanningPagination? data;
  static const fromJsonFactory = _$WorkOrderPlanningResponsePaginationFromJson;
  static const toJsonFactory = _$WorkOrderPlanningResponsePaginationToJson;
  Map<String, dynamic> toJson() =>
      _$WorkOrderPlanningResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkOrderPlanningResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkOrderPlanningResponsePaginationExtension
    on WorkOrderPlanningResponsePagination {
  WorkOrderPlanningResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      WorkOrderPlanningPagination? data}) {
    return WorkOrderPlanningResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkOrderResponseObject {
  WorkOrderResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkOrderResponseObject.fromJson(Map<String, dynamic> json) =>
      _$WorkOrderResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final WorkOrder? data;
  static const fromJsonFactory = _$WorkOrderResponseObjectFromJson;
  static const toJsonFactory = _$WorkOrderResponseObjectToJson;
  Map<String, dynamic> toJson() => _$WorkOrderResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkOrderResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkOrderResponseObjectExtension on WorkOrderResponseObject {
  WorkOrderResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, WorkOrder? data}) {
    return WorkOrderResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkOrderResponsePagination {
  WorkOrderResponsePagination({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkOrderResponsePagination.fromJson(Map<String, dynamic> json) =>
      _$WorkOrderResponsePaginationFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final WorkOrderPagination? data;
  static const fromJsonFactory = _$WorkOrderResponsePaginationFromJson;
  static const toJsonFactory = _$WorkOrderResponsePaginationToJson;
  Map<String, dynamic> toJson() => _$WorkOrderResponsePaginationToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkOrderResponsePagination &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkOrderResponsePaginationExtension on WorkOrderResponsePagination {
  WorkOrderResponsePagination copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      WorkOrderPagination? data}) {
    return WorkOrderResponsePagination(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkflowEntity {
  WorkflowEntity({
    this.documentId,
    this.workflowCommand,
    this.workflowCode,
    this.commandName,
    this.classifier,
    this.applicationId,
  });

  factory WorkflowEntity.fromJson(Map<String, dynamic> json) =>
      _$WorkflowEntityFromJson(json);

  @JsonKey(name: 'documentId', includeIfNull: false)
  final String? documentId;
  @JsonKey(name: 'workflowCommand', includeIfNull: false)
  final String? workflowCommand;
  @JsonKey(name: 'workflowCode', includeIfNull: false)
  final String? workflowCode;
  @JsonKey(name: 'commandName', includeIfNull: false)
  final String? commandName;
  @JsonKey(name: 'classifier', includeIfNull: false)
  final int? classifier;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  static const fromJsonFactory = _$WorkflowEntityFromJson;
  static const toJsonFactory = _$WorkflowEntityToJson;
  Map<String, dynamic> toJson() => _$WorkflowEntityToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkflowEntity &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)) &&
            (identical(other.workflowCommand, workflowCommand) ||
                const DeepCollectionEquality()
                    .equals(other.workflowCommand, workflowCommand)) &&
            (identical(other.workflowCode, workflowCode) ||
                const DeepCollectionEquality()
                    .equals(other.workflowCode, workflowCode)) &&
            (identical(other.commandName, commandName) ||
                const DeepCollectionEquality()
                    .equals(other.commandName, commandName)) &&
            (identical(other.classifier, classifier) ||
                const DeepCollectionEquality()
                    .equals(other.classifier, classifier)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentId) ^
      const DeepCollectionEquality().hash(workflowCommand) ^
      const DeepCollectionEquality().hash(workflowCode) ^
      const DeepCollectionEquality().hash(commandName) ^
      const DeepCollectionEquality().hash(classifier) ^
      const DeepCollectionEquality().hash(applicationId) ^
      runtimeType.hashCode;
}

extension $WorkflowEntityExtension on WorkflowEntity {
  WorkflowEntity copyWith(
      {String? documentId,
      String? workflowCommand,
      String? workflowCode,
      String? commandName,
      int? classifier,
      String? applicationId}) {
    return WorkflowEntity(
        documentId: documentId ?? this.documentId,
        workflowCommand: workflowCommand ?? this.workflowCommand,
        workflowCode: workflowCode ?? this.workflowCode,
        commandName: commandName ?? this.commandName,
        classifier: classifier ?? this.classifier,
        applicationId: applicationId ?? this.applicationId);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkflowFinaceUpdateModel {
  WorkflowFinaceUpdateModel({
    this.documentId,
    this.workflowState,
    this.workflowStatus,
    this.isInitial,
  });

  factory WorkflowFinaceUpdateModel.fromJson(Map<String, dynamic> json) =>
      _$WorkflowFinaceUpdateModelFromJson(json);

  @JsonKey(name: 'documentId', includeIfNull: false)
  final String? documentId;
  @JsonKey(name: 'workflowState', includeIfNull: false)
  final String? workflowState;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final String? workflowStatus;
  @JsonKey(name: 'isInitial', includeIfNull: false)
  final bool? isInitial;
  static const fromJsonFactory = _$WorkflowFinaceUpdateModelFromJson;
  static const toJsonFactory = _$WorkflowFinaceUpdateModelToJson;
  Map<String, dynamic> toJson() => _$WorkflowFinaceUpdateModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkflowFinaceUpdateModel &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)) &&
            (identical(other.workflowState, workflowState) ||
                const DeepCollectionEquality()
                    .equals(other.workflowState, workflowState)) &&
            (identical(other.workflowStatus, workflowStatus) ||
                const DeepCollectionEquality()
                    .equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.isInitial, isInitial) ||
                const DeepCollectionEquality()
                    .equals(other.isInitial, isInitial)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentId) ^
      const DeepCollectionEquality().hash(workflowState) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(isInitial) ^
      runtimeType.hashCode;
}

extension $WorkflowFinaceUpdateModelExtension on WorkflowFinaceUpdateModel {
  WorkflowFinaceUpdateModel copyWith(
      {String? documentId,
      String? workflowState,
      String? workflowStatus,
      bool? isInitial}) {
    return WorkflowFinaceUpdateModel(
        documentId: documentId ?? this.documentId,
        workflowState: workflowState ?? this.workflowState,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        isInitial: isInitial ?? this.isInitial);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkflowUpdateModel {
  WorkflowUpdateModel({
    this.documentId,
    this.workflowState,
    this.workflowStatus,
    this.isInitial,
  });

  factory WorkflowUpdateModel.fromJson(Map<String, dynamic> json) =>
      _$WorkflowUpdateModelFromJson(json);

  @JsonKey(name: 'documentId', includeIfNull: false)
  final String? documentId;
  @JsonKey(name: 'workflowState', includeIfNull: false)
  final String? workflowState;
  @JsonKey(name: 'workflowStatus', includeIfNull: false)
  final String? workflowStatus;
  @JsonKey(name: 'isInitial', includeIfNull: false)
  final bool? isInitial;
  static const fromJsonFactory = _$WorkflowUpdateModelFromJson;
  static const toJsonFactory = _$WorkflowUpdateModelToJson;
  Map<String, dynamic> toJson() => _$WorkflowUpdateModelToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkflowUpdateModel &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)) &&
            (identical(other.workflowState, workflowState) ||
                const DeepCollectionEquality()
                    .equals(other.workflowState, workflowState)) &&
            (identical(other.workflowStatus, workflowStatus) ||
                const DeepCollectionEquality()
                    .equals(other.workflowStatus, workflowStatus)) &&
            (identical(other.isInitial, isInitial) ||
                const DeepCollectionEquality()
                    .equals(other.isInitial, isInitial)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentId) ^
      const DeepCollectionEquality().hash(workflowState) ^
      const DeepCollectionEquality().hash(workflowStatus) ^
      const DeepCollectionEquality().hash(isInitial) ^
      runtimeType.hashCode;
}

extension $WorkflowUpdateModelExtension on WorkflowUpdateModel {
  WorkflowUpdateModel copyWith(
      {String? documentId,
      String? workflowState,
      String? workflowStatus,
      bool? isInitial}) {
    return WorkflowUpdateModel(
        documentId: documentId ?? this.documentId,
        workflowState: workflowState ?? this.workflowState,
        workflowStatus: workflowStatus ?? this.workflowStatus,
        isInitial: isInitial ?? this.isInitial);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkingTime {
  WorkingTime({
    this.createdByUserId,
    this.lastModifiedByUserId,
    this.lastModifiedOnDate,
    this.createdOnDate,
    this.applicationId,
    this.metadataContentObjs,
    this.metaContentType,
    this.metadataContent,
    this.id,
    this.shiftId,
    this.workingDate,
    this.workingHours,
    this.description,
  });

  factory WorkingTime.fromJson(Map<String, dynamic> json) =>
      _$WorkingTimeFromJson(json);

  @JsonKey(name: 'createdByUserId', includeIfNull: false)
  final String? createdByUserId;
  @JsonKey(name: 'lastModifiedByUserId', includeIfNull: false)
  final String? lastModifiedByUserId;
  @JsonKey(name: 'lastModifiedOnDate', includeIfNull: false)
  final DateTime? lastModifiedOnDate;
  @JsonKey(name: 'createdOnDate', includeIfNull: false)
  final DateTime? createdOnDate;
  @JsonKey(name: 'applicationId', includeIfNull: false)
  final String? applicationId;
  @JsonKey(
      name: 'metadataContentObjs',
      includeIfNull: false,
      defaultValue: <MetadataValue>[])
  final List<MetadataValue>? metadataContentObjs;
  @JsonKey(name: 'metaContentType', includeIfNull: false)
  final String? metaContentType;
  @JsonKey(name: 'metadataContent', includeIfNull: false)
  final String? metadataContent;
  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'shiftId', includeIfNull: false)
  final String? shiftId;
  @JsonKey(name: 'workingDate', includeIfNull: false)
  final DateTime? workingDate;
  @JsonKey(name: 'workingHours', includeIfNull: false)
  final int? workingHours;
  @JsonKey(name: 'description', includeIfNull: false)
  final String? description;
  static const fromJsonFactory = _$WorkingTimeFromJson;
  static const toJsonFactory = _$WorkingTimeToJson;
  Map<String, dynamic> toJson() => _$WorkingTimeToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkingTime &&
            (identical(other.createdByUserId, createdByUserId) ||
                const DeepCollectionEquality()
                    .equals(other.createdByUserId, createdByUserId)) &&
            (identical(other.lastModifiedByUserId, lastModifiedByUserId) ||
                const DeepCollectionEquality().equals(
                    other.lastModifiedByUserId, lastModifiedByUserId)) &&
            (identical(other.lastModifiedOnDate, lastModifiedOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedOnDate, lastModifiedOnDate)) &&
            (identical(other.createdOnDate, createdOnDate) ||
                const DeepCollectionEquality()
                    .equals(other.createdOnDate, createdOnDate)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.metadataContentObjs, metadataContentObjs) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContentObjs, metadataContentObjs)) &&
            (identical(other.metaContentType, metaContentType) ||
                const DeepCollectionEquality()
                    .equals(other.metaContentType, metaContentType)) &&
            (identical(other.metadataContent, metadataContent) ||
                const DeepCollectionEquality()
                    .equals(other.metadataContent, metadataContent)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.shiftId, shiftId) ||
                const DeepCollectionEquality()
                    .equals(other.shiftId, shiftId)) &&
            (identical(other.workingDate, workingDate) ||
                const DeepCollectionEquality()
                    .equals(other.workingDate, workingDate)) &&
            (identical(other.workingHours, workingHours) ||
                const DeepCollectionEquality()
                    .equals(other.workingHours, workingHours)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedByUserId) ^
      const DeepCollectionEquality().hash(lastModifiedOnDate) ^
      const DeepCollectionEquality().hash(createdOnDate) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(metadataContentObjs) ^
      const DeepCollectionEquality().hash(metaContentType) ^
      const DeepCollectionEquality().hash(metadataContent) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(shiftId) ^
      const DeepCollectionEquality().hash(workingDate) ^
      const DeepCollectionEquality().hash(workingHours) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $WorkingTimeExtension on WorkingTime {
  WorkingTime copyWith(
      {String? createdByUserId,
      String? lastModifiedByUserId,
      DateTime? lastModifiedOnDate,
      DateTime? createdOnDate,
      String? applicationId,
      List<MetadataValue>? metadataContentObjs,
      String? metaContentType,
      String? metadataContent,
      String? id,
      String? shiftId,
      DateTime? workingDate,
      int? workingHours,
      String? description}) {
    return WorkingTime(
        createdByUserId: createdByUserId ?? this.createdByUserId,
        lastModifiedByUserId: lastModifiedByUserId ?? this.lastModifiedByUserId,
        lastModifiedOnDate: lastModifiedOnDate ?? this.lastModifiedOnDate,
        createdOnDate: createdOnDate ?? this.createdOnDate,
        applicationId: applicationId ?? this.applicationId,
        metadataContentObjs: metadataContentObjs ?? this.metadataContentObjs,
        metaContentType: metaContentType ?? this.metaContentType,
        metadataContent: metadataContent ?? this.metadataContent,
        id: id ?? this.id,
        shiftId: shiftId ?? this.shiftId,
        workingDate: workingDate ?? this.workingDate,
        workingHours: workingHours ?? this.workingHours,
        description: description ?? this.description);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkingTimeResponseList {
  WorkingTimeResponseList({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkingTimeResponseList.fromJson(Map<String, dynamic> json) =>
      _$WorkingTimeResponseListFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false, defaultValue: <WorkingTime>[])
  final List<WorkingTime>? data;
  static const fromJsonFactory = _$WorkingTimeResponseListFromJson;
  static const toJsonFactory = _$WorkingTimeResponseListToJson;
  Map<String, dynamic> toJson() => _$WorkingTimeResponseListToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkingTimeResponseList &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkingTimeResponseListExtension on WorkingTimeResponseList {
  WorkingTimeResponseList copyWith(
      {enums.Code? code,
      String? message,
      num? totalTime,
      List<WorkingTime>? data}) {
    return WorkingTimeResponseList(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

@JsonSerializable(explicitToJson: true)
class WorkingTimeResponseObject {
  WorkingTimeResponseObject({
    this.code,
    this.message,
    this.totalTime,
    this.data,
  });

  factory WorkingTimeResponseObject.fromJson(Map<String, dynamic> json) =>
      _$WorkingTimeResponseObjectFromJson(json);

  @JsonKey(
      name: 'code',
      includeIfNull: false,
      toJson: codeToJson,
      fromJson: codeFromJson)
  final enums.Code? code;
  @JsonKey(name: 'message', includeIfNull: false)
  final String? message;
  @JsonKey(name: 'totalTime', includeIfNull: false)
  final num? totalTime;
  @JsonKey(name: 'data', includeIfNull: false)
  final WorkingTime? data;
  static const fromJsonFactory = _$WorkingTimeResponseObjectFromJson;
  static const toJsonFactory = _$WorkingTimeResponseObjectToJson;
  Map<String, dynamic> toJson() => _$WorkingTimeResponseObjectToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WorkingTimeResponseObject &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WorkingTimeResponseObjectExtension on WorkingTimeResponseObject {
  WorkingTimeResponseObject copyWith(
      {enums.Code? code, String? message, num? totalTime, WorkingTime? data}) {
    return WorkingTimeResponseObject(
        code: code ?? this.code,
        message: message ?? this.message,
        totalTime: totalTime ?? this.totalTime,
        data: data ?? this.data);
  }
}

int? accessTypeToJson(enums.AccessType? accessType) {
  return enums.$AccessTypeMap[accessType];
}

enums.AccessType accessTypeFromJson(
  Object? accessType, [
  enums.AccessType? defaultValue,
]) {
  if (accessType is int) {
    return enums.$AccessTypeMap.entries
        .firstWhere((element) => element.value == accessType,
            orElse: () =>
                const MapEntry(enums.AccessType.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AccessTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AccessType.swaggerGeneratedUnknown;
}

List<int> accessTypeListToJson(List<enums.AccessType>? accessType) {
  if (accessType == null) {
    return [];
  }

  return accessType.map((e) => enums.$AccessTypeMap[e]!).toList();
}

List<enums.AccessType> accessTypeListFromJson(
  List? accessType, [
  List<enums.AccessType>? defaultValue,
]) {
  if (accessType == null) {
    return defaultValue ?? [];
  }

  return accessType.map((e) => accessTypeFromJson(e.toString())).toList();
}

int? codeToJson(enums.Code? code) {
  return enums.$CodeMap[code];
}

enums.Code codeFromJson(
  Object? code, [
  enums.Code? defaultValue,
]) {
  if (code is int) {
    return enums.$CodeMap.entries
        .firstWhere((element) => element.value == code,
            orElse: () => const MapEntry(enums.Code.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ?? defaultValue ?? enums.Code.swaggerGeneratedUnknown;
}

List<int> codeListToJson(List<enums.Code>? code) {
  if (code == null) {
    return [];
  }

  return code.map((e) => enums.$CodeMap[e]!).toList();
}

List<enums.Code> codeListFromJson(
  List? code, [
  List<enums.Code>? defaultValue,
]) {
  if (code == null) {
    return defaultValue ?? [];
  }

  return code.map((e) => codeFromJson(e.toString())).toList();
}

int? commentStatusEnumsToJson(enums.CommentStatusEnums? commentStatusEnums) {
  return enums.$CommentStatusEnumsMap[commentStatusEnums];
}

enums.CommentStatusEnums commentStatusEnumsFromJson(
  Object? commentStatusEnums, [
  enums.CommentStatusEnums? defaultValue,
]) {
  if (commentStatusEnums is int) {
    return enums.$CommentStatusEnumsMap.entries
        .firstWhere((element) => element.value == commentStatusEnums,
            orElse: () => const MapEntry(
                enums.CommentStatusEnums.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CommentStatusEnumsMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CommentStatusEnums.swaggerGeneratedUnknown;
}

List<int> commentStatusEnumsListToJson(
    List<enums.CommentStatusEnums>? commentStatusEnums) {
  if (commentStatusEnums == null) {
    return [];
  }

  return commentStatusEnums
      .map((e) => enums.$CommentStatusEnumsMap[e]!)
      .toList();
}

List<enums.CommentStatusEnums> commentStatusEnumsListFromJson(
  List? commentStatusEnums, [
  List<enums.CommentStatusEnums>? defaultValue,
]) {
  if (commentStatusEnums == null) {
    return defaultValue ?? [];
  }

  return commentStatusEnums
      .map((e) => commentStatusEnumsFromJson(e.toString()))
      .toList();
}

int? logEventLevelToJson(enums.LogEventLevel? logEventLevel) {
  return enums.$LogEventLevelMap[logEventLevel];
}

enums.LogEventLevel logEventLevelFromJson(
  Object? logEventLevel, [
  enums.LogEventLevel? defaultValue,
]) {
  if (logEventLevel is int) {
    return enums.$LogEventLevelMap.entries
        .firstWhere((element) => element.value == logEventLevel,
            orElse: () =>
                const MapEntry(enums.LogEventLevel.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$LogEventLevelMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.LogEventLevel.swaggerGeneratedUnknown;
}

List<int> logEventLevelListToJson(List<enums.LogEventLevel>? logEventLevel) {
  if (logEventLevel == null) {
    return [];
  }

  return logEventLevel.map((e) => enums.$LogEventLevelMap[e]!).toList();
}

List<enums.LogEventLevel> logEventLevelListFromJson(
  List? logEventLevel, [
  List<enums.LogEventLevel>? defaultValue,
]) {
  if (logEventLevel == null) {
    return defaultValue ?? [];
  }

  return logEventLevel.map((e) => logEventLevelFromJson(e.toString())).toList();
}

int? metafieldTypeToJson(enums.MetafieldType? metafieldType) {
  return enums.$MetafieldTypeMap[metafieldType];
}

enums.MetafieldType metafieldTypeFromJson(
  Object? metafieldType, [
  enums.MetafieldType? defaultValue,
]) {
  if (metafieldType is int) {
    return enums.$MetafieldTypeMap.entries
        .firstWhere((element) => element.value == metafieldType,
            orElse: () =>
                const MapEntry(enums.MetafieldType.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$MetafieldTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.MetafieldType.swaggerGeneratedUnknown;
}

List<int> metafieldTypeListToJson(List<enums.MetafieldType>? metafieldType) {
  if (metafieldType == null) {
    return [];
  }

  return metafieldType.map((e) => enums.$MetafieldTypeMap[e]!).toList();
}

List<enums.MetafieldType> metafieldTypeListFromJson(
  List? metafieldType, [
  List<enums.MetafieldType>? defaultValue,
]) {
  if (metafieldType == null) {
    return defaultValue ?? [];
  }

  return metafieldType.map((e) => metafieldTypeFromJson(e.toString())).toList();
}

int? nodeTypeEnumToJson(enums.NodeTypeEnum? nodeTypeEnum) {
  return enums.$NodeTypeEnumMap[nodeTypeEnum];
}

enums.NodeTypeEnum nodeTypeEnumFromJson(
  Object? nodeTypeEnum, [
  enums.NodeTypeEnum? defaultValue,
]) {
  if (nodeTypeEnum is int) {
    return enums.$NodeTypeEnumMap.entries
        .firstWhere((element) => element.value == nodeTypeEnum,
            orElse: () =>
                const MapEntry(enums.NodeTypeEnum.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$NodeTypeEnumMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.NodeTypeEnum.swaggerGeneratedUnknown;
}

List<int> nodeTypeEnumListToJson(List<enums.NodeTypeEnum>? nodeTypeEnum) {
  if (nodeTypeEnum == null) {
    return [];
  }

  return nodeTypeEnum.map((e) => enums.$NodeTypeEnumMap[e]!).toList();
}

List<enums.NodeTypeEnum> nodeTypeEnumListFromJson(
  List? nodeTypeEnum, [
  List<enums.NodeTypeEnum>? defaultValue,
]) {
  if (nodeTypeEnum == null) {
    return defaultValue ?? [];
  }

  return nodeTypeEnum.map((e) => nodeTypeEnumFromJson(e.toString())).toList();
}

int? objectTypeToJson(enums.ObjectType? objectType) {
  return enums.$ObjectTypeMap[objectType];
}

enums.ObjectType objectTypeFromJson(
  Object? objectType, [
  enums.ObjectType? defaultValue,
]) {
  if (objectType is int) {
    return enums.$ObjectTypeMap.entries
        .firstWhere((element) => element.value == objectType,
            orElse: () =>
                const MapEntry(enums.ObjectType.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ObjectTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ObjectType.swaggerGeneratedUnknown;
}

List<int> objectTypeListToJson(List<enums.ObjectType>? objectType) {
  if (objectType == null) {
    return [];
  }

  return objectType.map((e) => enums.$ObjectTypeMap[e]!).toList();
}

List<enums.ObjectType> objectTypeListFromJson(
  List? objectType, [
  List<enums.ObjectType>? defaultValue,
]) {
  if (objectType == null) {
    return defaultValue ?? [];
  }

  return objectType.map((e) => objectTypeFromJson(e.toString())).toList();
}

int? pMStatusEnumsToJson(enums.PMStatusEnums? pMStatusEnums) {
  return enums.$PMStatusEnumsMap[pMStatusEnums];
}

enums.PMStatusEnums pMStatusEnumsFromJson(
  Object? pMStatusEnums, [
  enums.PMStatusEnums? defaultValue,
]) {
  if (pMStatusEnums is int) {
    return enums.$PMStatusEnumsMap.entries
        .firstWhere((element) => element.value == pMStatusEnums,
            orElse: () =>
                const MapEntry(enums.PMStatusEnums.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PMStatusEnumsMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PMStatusEnums.swaggerGeneratedUnknown;
}

List<int> pMStatusEnumsListToJson(List<enums.PMStatusEnums>? pMStatusEnums) {
  if (pMStatusEnums == null) {
    return [];
  }

  return pMStatusEnums.map((e) => enums.$PMStatusEnumsMap[e]!).toList();
}

List<enums.PMStatusEnums> pMStatusEnumsListFromJson(
  List? pMStatusEnums, [
  List<enums.PMStatusEnums>? defaultValue,
]) {
  if (pMStatusEnums == null) {
    return defaultValue ?? [];
  }

  return pMStatusEnums.map((e) => pMStatusEnumsFromJson(e.toString())).toList();
}

int? priorityEnumsToJson(enums.PriorityEnums? priorityEnums) {
  return enums.$PriorityEnumsMap[priorityEnums];
}

enums.PriorityEnums priorityEnumsFromJson(
  Object? priorityEnums, [
  enums.PriorityEnums? defaultValue,
]) {
  if (priorityEnums is int) {
    return enums.$PriorityEnumsMap.entries
        .firstWhere((element) => element.value == priorityEnums,
            orElse: () =>
                const MapEntry(enums.PriorityEnums.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PriorityEnumsMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PriorityEnums.swaggerGeneratedUnknown;
}

List<int> priorityEnumsListToJson(List<enums.PriorityEnums>? priorityEnums) {
  if (priorityEnums == null) {
    return [];
  }

  return priorityEnums.map((e) => enums.$PriorityEnumsMap[e]!).toList();
}

List<enums.PriorityEnums> priorityEnumsListFromJson(
  List? priorityEnums, [
  List<enums.PriorityEnums>? defaultValue,
]) {
  if (priorityEnums == null) {
    return defaultValue ?? [];
  }

  return priorityEnums.map((e) => priorityEnumsFromJson(e.toString())).toList();
}

int? relationTypeEnumsToJson(enums.RelationTypeEnums? relationTypeEnums) {
  return enums.$RelationTypeEnumsMap[relationTypeEnums];
}

enums.RelationTypeEnums relationTypeEnumsFromJson(
  Object? relationTypeEnums, [
  enums.RelationTypeEnums? defaultValue,
]) {
  if (relationTypeEnums is int) {
    return enums.$RelationTypeEnumsMap.entries
        .firstWhere((element) => element.value == relationTypeEnums,
            orElse: () => const MapEntry(
                enums.RelationTypeEnums.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$RelationTypeEnumsMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.RelationTypeEnums.swaggerGeneratedUnknown;
}

List<int> relationTypeEnumsListToJson(
    List<enums.RelationTypeEnums>? relationTypeEnums) {
  if (relationTypeEnums == null) {
    return [];
  }

  return relationTypeEnums.map((e) => enums.$RelationTypeEnumsMap[e]!).toList();
}

List<enums.RelationTypeEnums> relationTypeEnumsListFromJson(
  List? relationTypeEnums, [
  List<enums.RelationTypeEnums>? defaultValue,
]) {
  if (relationTypeEnums == null) {
    return defaultValue ?? [];
  }

  return relationTypeEnums
      .map((e) => relationTypeEnumsFromJson(e.toString()))
      .toList();
}

int? statusEnumToJson(enums.StatusEnum? statusEnum) {
  return enums.$StatusEnumMap[statusEnum];
}

enums.StatusEnum statusEnumFromJson(
  Object? statusEnum, [
  enums.StatusEnum? defaultValue,
]) {
  if (statusEnum is int) {
    return enums.$StatusEnumMap.entries
        .firstWhere((element) => element.value == statusEnum,
            orElse: () =>
                const MapEntry(enums.StatusEnum.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$StatusEnumMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.StatusEnum.swaggerGeneratedUnknown;
}

List<int> statusEnumListToJson(List<enums.StatusEnum>? statusEnum) {
  if (statusEnum == null) {
    return [];
  }

  return statusEnum.map((e) => enums.$StatusEnumMap[e]!).toList();
}

List<enums.StatusEnum> statusEnumListFromJson(
  List? statusEnum, [
  List<enums.StatusEnum>? defaultValue,
]) {
  if (statusEnum == null) {
    return defaultValue ?? [];
  }

  return statusEnum.map((e) => statusEnumFromJson(e.toString())).toList();
}

int? statusEnumsToJson(enums.StatusEnums? statusEnums) {
  return enums.$StatusEnumsMap[statusEnums];
}

enums.StatusEnums statusEnumsFromJson(
  Object? statusEnums, [
  enums.StatusEnums? defaultValue,
]) {
  if (statusEnums is int) {
    return enums.$StatusEnumsMap.entries
        .firstWhere((element) => element.value == statusEnums,
            orElse: () =>
                const MapEntry(enums.StatusEnums.swaggerGeneratedUnknown, 0))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$StatusEnumsMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.StatusEnums.swaggerGeneratedUnknown;
}

List<int> statusEnumsListToJson(List<enums.StatusEnums>? statusEnums) {
  if (statusEnums == null) {
    return [];
  }

  return statusEnums.map((e) => enums.$StatusEnumsMap[e]!).toList();
}

List<enums.StatusEnums> statusEnumsListFromJson(
  List? statusEnums, [
  List<enums.StatusEnums>? defaultValue,
]) {
  if (statusEnums == null) {
    return defaultValue ?? [];
  }

  return statusEnums.map((e) => statusEnumsFromJson(e.toString())).toList();
}

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}
